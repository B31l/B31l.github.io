---
title: "Week-3: ì œì•½ ì¶©ì¡± ë¬¸ì œ"
categories: [DS&A]
mathjax: true
---

* content
{:toc}
# ì œì•½ ì¶©ì¡± ë¬¸ì œ

ì œì•½ ì¶©ì¡± ë¬¸ì œ(CSP: Constraint-Satisfaction Problem)ëŠ” ë³µìˆ˜ì˜ ì œì•½ ì¡°ê±´ì„ ì¶©ì¡±í•˜ëŠ” ìƒíƒœë¥¼ ì°¾ì•„ë‚´ëŠ” ìˆ˜í•™ ë¬¸ì œë¥¼ ê°€ë¦¬í‚¨ë‹¤. ë°±íŠ¸ë˜í‚¹ ê²€ìƒ‰ê³¼ ì´ë¥¼ í–¥ìƒì‹œí‚¤ëŠ” íœ´ë¦¬ìŠ¤í‹±ì„ í†µí•©í•œ í”„ë ˆì„ì›Œí¬ë¥¼ êµ¬ì¶•í•˜ì—¬ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

## Constraint

<u>Constraint í´ë˜ìŠ¤</u>

```python
from typing import Generic, TypeVar, Dict, List, Optional
from abc import ABC, abstractmethod

V = TypeVar('V') # ë³€ìˆ˜(Variable) íƒ€ì…
D = TypeVar('D') # ë„ë©”ì¸(Domain) íƒ€ì…


class Constraint(Generic[V, D], ABC):
    """
    * ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤
    """
    def __init__(self, variables:List[V]) -> None:
        self.variables = variables                              # variables     : ì œì•½ ì¡°ê±´ ë³€ìˆ˜

    # ì„œë¸Œí´ë˜ìŠ¤ ë©”ì„œë“œì— ì˜í•´ ì¬ì •ì˜ëœë‹¤.
    @abstractmethod
    def satisfied(self, assignment:Dict[V, D]) -> bool:
        ...
```

**Constraint** í´ë˜ìŠ¤ëŠ” ì œì•½ ì¡°ê±´ ë³€ìˆ˜ì™€ ì´ë¥¼ ì¶©ì¡±í•˜ëŠ”ì§€ ê²€ì‚¬í•˜ëŠ” ë©”ì„œë“œë¡œ êµ¬ì„±ë˜ë©°, ì´ëŠ” ì œì•½ ì¶©ì¡± ë¬¸ì œê°€ ê°€ì§„ ê³ ìœ ì˜ ì œì•½ ì¡°ê±´ì— ë”°ë¼ ì¡°ê¸ˆì”© ë‹¤ë¥´ê²Œ ì¬ì •ì˜ëœë‹¤. `abc` ëª¨ë“ˆì˜ **ABC** í´ë˜ìŠ¤ë¥¼ ìƒì†í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ Constraint í´ë˜ìŠ¤ë¥¼ ì¶”ìƒ í´ë˜ìŠ¤ë¡œ ì •ì˜í•˜ë©´ ê³µí†µëœ í•„ë“œì™€ ë©”ì„œë“œë¥¼ í†µì¼í•  ìˆ˜ ìˆë‹¤. **@abstractmethod** ë°ì½”ë ˆì´í„°ë¥¼ ì‚¬ìš©í•œ ë©”ì„œë“œëŠ” ì¶”ìƒ ë©”ì„œë“œë¡œ ì •ì˜ë˜ë©°, ì´í›„ ì„œë¸Œí´ë˜ìŠ¤ ë©”ì„œë“œì— ì˜í•´ ì¬ì •ì˜ëœë‹¤.

## CSP

<u>CSP í´ë˜ìŠ¤</u>

```python
class CSP(Generic[V, D]):
    """
    * í•µì‹¬ í´ë˜ìŠ¤
    ë³€ìˆ˜            : self.variables
    ë„ë©”ì¸          : self.domains
    ì œì•½ ì¡°ê±´       : self.constraints
    """
    def __init__(self, variables:List[V], domains:Dict[V, List[D]]) -> None:

        # 1. ë³€ìˆ˜ ë° ë„ë©”ì¸ì„ ì €ì¥í•œë‹¤.
        self.variables:List[V] = variables                      # variables     : List[V]
        self.domains:Dict[V, List[D]] = domains                 # domains       : { V : List[D] }

        # 2. ì œì•½ ì¡°ê±´ ì»¬ë ‰ì…˜ì„ ì´ˆê¸°í™”í•œë‹¤.
        self.constraints:Dict[V, List[Constraint[V, D]]] = {}   # constraints   : { V : List[Constraint[V, D]] }
        for variable in self.variables:                         # {}
            self.constraints[variable] = []                     # { ë³€ìˆ˜1 : [], ë³€ìˆ˜2: [], ... }
            if variable not in self.domains:
                raise LookupError("ëª¨ë“  ë³€ìˆ˜ì— ë„ë©”ì¸ì´ í• ë‹¹ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.")

    # 3. ì œì•½ ì¡°ê±´ì„ ì €ì¥í•œë‹¤.
    def add_constraint(self, constraint:Constraint[V, D]) -> None:
        for variable in constraint.variables:                   
            if variable not in self.variables:
                raise LookupError("ì œì•½ ì¡°ê±´ ë³€ìˆ˜ê°€ ì•„ë‹™ë‹ˆë‹¤.")
            else:
                self.constraints[variable].append(constraint)   # { ë³€ìˆ˜1 : [ì œì•½ ì¡°ê±´], ë³€ìˆ˜ 2: [ì œì•½ ì¡°ê±´], ... }

    # ì£¼ì–´ì§„ ë³€ìˆ˜ì˜ ëª¨ë“  ì œì•½ ì¡°ê±´ì„ ê²€ì‚¬í•˜ë©° assignment ê°’ì´ ì¼ê´€ì ì¸ì§€ í™•ì¸í•œë‹¤.
    def consistent(self, variable:V, assignment:Dict[V, D]) -> bool:
        for constraint in self.constraints[variable]:
            if not constraint.satisfied(assignment):
                return False    # ì œì•½ ì¡°ê±´ì„ ì¶©ì¡±í•˜ì§€ ì•ŠìŒ    -> False
        return True         # í• ë‹¹ì´ ëª¨ë“  ì œì•½ ì¡°ê±´ì„ ì¶©ì¡± -> True

    # ë°±íŠ¸ë˜í‚¹(backtracking): ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)ê³¼ ìœ ì‚¬í•œ ë°©ì‹
    def backtracking_search(self, assignment:Dict[V, D] = {}) -> Optional[Dict[V, D]]:

        # assignmentëŠ” ëª¨ë“  ë³€ìˆ˜ê°€ í• ë‹¹ë  ë•Œ ì™„ë£Œëœë‹¤(ê¸°ì € ì¡°ê±´).
        if len(assignment) == len(self.variables):
            return assignment

        # í• ë‹¹ë˜ì§€ ì•Šì€ ëª¨ë“  ë³€ìˆ˜ë¥¼ ê°€ì ¸ì˜¨ë‹¤.
        unsigned:List[V] = [v for v in self.variables if v not in assignment]
        
        # í• ë‹¹ë˜ì§€ ì•Šì€ ì²« ë²ˆì§¸ ë³€ìˆ˜ì˜ ê°€ëŠ¥í•œ ëª¨ë“  ë„ë©”ì¸ ê°’ì„ ê°€ì ¸ì˜¨ë‹¤.
        first:V = unsigned[0]
        for value in self.domains[first]:
            local_assignment = assignment.copy()
            local_assignment[first] = value
            
            # local_assignment ê°’ì´ ì¼ì¹˜í•˜ë©´ ì¬ê·€ í˜¸ì¶œí•œë‹¤.
            if self.consistent(first, local_assignment):
                result:Optional[Dict[V, D]] = self.backtracking_search(local_assignment)
                if result is not None:
                    return result   # ì†”ë£¨ì…˜ ë°˜í™˜
        return None                 # ì†”ë£¨ì…˜ ì—†ìŒ
```

**CSP** í´ë˜ìŠ¤ëŠ” ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì‹œ ë³€ìˆ˜ì™€ ë„ë©”ì¸ì„ ì €ì¥í•˜ë©°, **add_constraint()** ë©”ì„œë“œë¥¼ í†µí•´ ì œì•½ ì¡°ê±´ì„ ì €ì¥í•œë‹¤.

**assignment**ëŠ” ë³€ìˆ˜(key)ì— ëŒ€í•œ ìœ íš¨í•œ ë„ë©”ì¸(value)ì„ ê°–ëŠ” ì‚¬ì „ ìë£Œí˜•ìœ¼ë¡œ, ëª¨ë“  ë³€ìˆ˜ê°€ í• ë‹¹ë  ë•Œ ì†”ë£¨ì…˜ìœ¼ë¡œ ë°˜í™˜ëœë‹¤.

**consistent()** ë©”ì„œë“œëŠ” í• ë‹¹ëœ ê°’ì´ ì œì•½  ì¡°ê±´ì„ ë§Œì¡±ì‹œí‚¤ëŠ” ìœ íš¨í•œ ê°’ì¸ì§€ í™•ì¸í•œë‹¤.

**backtracking_search()** ë©”ì„œë“œëŠ” ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)ê³¼ ìœ ì‚¬í•œ ë°©ì‹ì„ ì‚¬ìš©í•´ ê°’ì„ í• ë‹¹í•œë‹¤. ëª¨ë“  ë³€ìˆ˜ê°€ í• ë‹¹ë  ë•Œê¹Œì§€ ì¬ê·€ í˜¸ì¶œì„ ì‹œí–‰í•˜ë©°, íŠ¹ì • ê¹Šì´ì—ì„œì˜ í• ë‹¹ì´ ì „ë¶€ ì‹¤íŒ¨í•  ê²½ìš° ì´ì „ ì¬ê·€ ìŠ¤íƒìœ¼ë¡œ ëŒì•„ê°„ë‹¤.

---

# 1. í˜¸ì£¼ ì§€ë„ ìƒ‰ì¹  ë¬¸ì œ

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-3-1.png?raw=true)

ìœ„ í˜¸ì£¼ ì§€ë„ë¥¼ ìƒ‰ì¹ í•œë‹¤ê³  ê°€ì •í•œë‹¤. 3ê°€ì§€ ìƒ‰ë§Œ ì‚¬ìš©í•´ì•¼ í•˜ë©°, ì¸ì ‘í•œ ë‘ ì§€ì—­ì€ ê°™ì€ ìƒ‰ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.

ë³€ìˆ˜, ë„ë©”ì¸, ì œì•½ ì¡°ê±´ì„ ì •ì˜í•˜ê³ , ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•œë‹¤.

|           | íƒ€ì…                 | ì„¤ëª…                                       |
| --------- | -------------------- | ------------------------------------------ |
| ë³€ìˆ˜(V)   | str                  | ì§€ì—­ ì´ë¦„                                  |
| ë„ë©”ì¸(D) | str                  | ìƒ‰ìƒ ì´ë¦„                                  |
| ì œì•½ ì¡°ê±´ | Constraint[str, str] | ì¸ì ‘í•œ ë‘ ì§€ì—­ì€ ê°™ì€ ìƒ‰ìœ¼ë¡œ ì¹ í•  ìˆ˜ ì—†ë‹¤. |

<u>ì œì•½ ì¡°ê±´ ì„¤ì •</u>

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional


class MapColoringConstraint(Constraint[str, str]):
    def __init__(self, place1:str, place2:str) -> None:
        super().__init__([place1, place2])
        self.place1:str = place1
        self.place2:str = place2

    def satisfied(self, assignment:Dict[str, str]) -> bool:
        if self.place1 not in assignment or self.place2 not in assignment:
            return True
        return assignment[self.place1] != assignment[self.place2]
```

ì¬ì •ì˜í•œ **satisfied()** ë©”ì„œë“œëŠ” ì¶©ëŒì´ ë°œìƒí•œ ê²½ìš° ë¬¸ì œì˜ ì¡°ê±´ì— ìœ„ë°°ë˜ë¯€ë¡œ Falseë¥¼ ë°˜í™˜í•˜ë©°, ê·¸ ì´ì™¸ì˜ ê²½ìš° Trueë¥¼ ë°˜í™˜í•œë‹¤. 

| ë‘ ì§€ì—­ ì¤‘ í•˜ë‚˜ë¼ë„ í• ë‹¹ì´ ì´ë£¨ì–´ì§€ì§€ ì•Šì€ ê²½ìš°              | ë‘ ì§€ì—­ ëª¨ë‘ í• ë‹¹ì´ ì´ë£¨ì–´ì§€ê³  ì¶©ëŒì´ ë°œìƒí•˜ì§€ ì•Šì€ ê²½ìš°     | ë‘ ì§€ì—­ ëª¨ë‘ í• ë‹¹ì´ ì´ë£¨ì–´ì§€ê³  ì¶©ëŒì´ ë°œìƒí•œ ê²½ìš°            |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/australia-1.png?raw=true) | ![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/australia-2.png?raw=true) | ![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/australia-3.png?raw=true) |
| True                                                         | True                                                         | False                                                        |

> *Note*
>
> í˜¸ì£¼ ì§€ë„ ìƒ‰ì¹  ë¬¸ì œì—ì„œëŠ” ë‘ ì§€ì—­ ì¤‘ í•˜ë‚˜ë¼ë„ ìƒ‰ìƒì´ ì§€ì •ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ì œì•½ ì¡°ê±´ì´ ì¶©ì¡±ë˜ì—ˆë‹¤ê³  ê°„ì£¼í•œë‹¤. ê·¸ ì´ìœ ëŠ” backtracking_search ë©”ì„œë“œì˜ ì‘ë™ ì•Œê³ ë¦¬ì¦˜ì¸ ê¹Šì´ ìš°ì„  íƒìƒ‰ì—ì„œëŠ” í• ë‹¹ì´ ë¶ˆê°€ëŠ¥í•  ë•Œ Noneì„ ë°˜í™˜í•˜ê³  ì¬ê·€ ì²´ì¸ì„ ë‹¤ë¥¸ ì´ì „ í• ë‹¹ì´ ì´ë¤„ì§„ ì§€ì—­ìœ¼ë¡œ ë˜ëŒì•„ê°€ê²Œ í•œë‹¤. íŠ¹ì • ì§€ì—­ì— ëŒ€í•´ ì œì•½ ì¡°ê±´ì„ ê²€ì‚¬í•  ë•Œ, ê·¸ ì§€ì—­ì€ ì´ë¯¸ í• ë‹¹ëœ ì§€ì—­ê³¼ ì•„ì§ í• ë‹¹ë˜ì§€ ì•Šì€ ì§€ì—­ ëª¨ë‘ ì¸ì ‘í•˜ê³  ìˆë‹¤. ë§Œì•½ ì•„ì§ í• ë‹¹ë˜ì§€ ì•Šì€ ì§€ì—­ê³¼ì˜ ì¡°ê±´ ë¹„êµì—ì„œ Falseë¥¼ ë°˜í™˜í•œë‹¤ë©´ í• ë‹¹ì´ ì‹¤íŒ¨í•˜ë¯€ë¡œ ì´ì „ ì¬ê·€ ìŠ¤íƒìœ¼ë¡œ ëŒì•„ê°€ê²Œ ë˜ë©°, ê²°êµ­ ìµœëŒ€ ê¹Šì´ê¹Œì§€ íƒìƒ‰í•˜ì§€ ëª»í•´ ì†”ë£¨ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ë‹¤.

<u>main</u>

```python
if __name__ == "__main__":

    # V
    variables:List[str] = ["ì›¨ìŠ¤í„´ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„", 
                           "ë…¸ë˜ ì¤€ì£¼", 
                           "ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„",
                           "í€¸ì¦ëœë“œ",
                           "ë‰´ì‚¬ìš°ìŠ¤ì›¨ì¼ìŠ¤",
                           "ë¹…í† ë¦¬ì•„",
                           "íƒœì¦ˆë©”ì´ë‹ˆì•„"]

    # D
    domains:Dict[str, List[str]] = {}
    for variable in variables:
        domains[variable] = ["ë¹¨ê°•", "ì´ˆë¡", "íŒŒë‘"]

    # constraint
    csp:CSP[str, str] = CSP(variables, domains)
    csp.add_constraint(MapColoringConstraint("ì›¨ìŠ¤í„´ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„", "ë…¸ë˜ ì¤€ì£¼"))
    csp.add_constraint(MapColoringConstraint("ì›¨ìŠ¤í„´ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„", "ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„"))
    csp.add_constraint(MapColoringConstraint("ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„", "ë…¸ë˜ ì¤€ì£¼"))
    csp.add_constraint(MapColoringConstraint("í€¸ì¦ëœë“œ"             , "ë…¸ë˜ ì¤€ì£¼"))
    csp.add_constraint(MapColoringConstraint("í€¸ì¦ëœë“œ"             , "ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„"))
    csp.add_constraint(MapColoringConstraint("í€¸ì¦ëœë“œ"             , "ë‰´ì‚¬ìš°ìŠ¤ì›¨ì¼ìŠ¤"))
    csp.add_constraint(MapColoringConstraint("ë‰´ì‚¬ìš°ìŠ¤ì›¨ì¼ìŠ¤"       , "ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„"))
    csp.add_constraint(MapColoringConstraint("ë¹…í† ë¦¬ì•„"             , "ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„"))
    csp.add_constraint(MapColoringConstraint("ë¹…í† ë¦¬ì•„"             , "ë‰´ì‚¬ìš°ìŠ¤ì›¨ì¼ìŠ¤"))
    csp.add_constraint(MapColoringConstraint("ë¹…í† ë¦¬ì•„"             , "íƒœì¦ˆë©”ì´ë‹ˆì•„"))
    
    # solution
    solution:Optional[Dict[str, str]] = csp.backtracking_search()
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        print(solution)
```

ì•ì„œ ì •ì˜í•œ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ë³€ìˆ˜, ë„ë©”ì¸, ì œì•½ ì¡°ê±´ì„ ì¶”ê°€í•œë‹¤. ì´í›„ ë°±íŠ¸ë˜í‚¹ì„ í†µí•´ ì†”ë£¨ì…˜ì„ ë„ì¶œí•œë‹¤. 

í›„ìˆ í•  ë‹¤ë¥¸ ëª¨ë“  ë¬¸ì œë„ ì´ì™€ ê°™ì€ êµ¬ì¡°ì˜ ì‹¤í–‰ ê³¼ì •ì„ ê°€ì§„ë‹¤.

<u>terminal</u>

```
{'ì›¨ìŠ¤í„´ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„': 'ë¹¨ê°•', 'ë…¸ë˜ ì¤€ì£¼': 'ì´ˆë¡', 'ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„': 'íŒŒë‘', 'í€¸ì¦ëœë“œ': 'ë¹¨ê°•', 'ë‰´ì‚¬ìš°ìŠ¤ì›¨ì¼ìŠ¤': 'ì´ˆë¡', 'ë¹…í† ë¦¬ì•„': 'ë¹¨ê°•', 'íƒœì¦ˆë©”ì´ë‹ˆì•„': 'ì´ˆë¡'}
```

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/australia-4.png?raw=true)

---

# 2. ì—¬ëŸ í€¸ ë¬¸ì œ

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-3-2.png?raw=true)

ì²´ìŠ¤íŒì— 8ê°œì˜ í€¸ì„ ë°°ì¹˜í•œë‹¤ê³  ê°€ì •í•œë‹¤. ê° í€¸ì€ ì„œë¡œì˜ ê³µê²© ë²”ìœ„(ê°™ì€ ì¤„, ê°™ì€ ëŒ€ê°ì„ )ì— ìœ„ì¹˜í•  ìˆ˜ ì—†ë‹¤.

ë³€ìˆ˜, ë„ë©”ì¸, ì œì•½ ì¡°ê±´ì„ ì •ì˜í•˜ê³ , ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•œë‹¤.

|           | íƒ€ì…                 | ì„¤ëª…                                         |
| --------- | -------------------- | -------------------------------------------- |
| ë³€ìˆ˜(V)   | int                  | í€¸ì˜ ì—´(1 ~ 8)                               |
| ë„ë©”ì¸(D) | int                  | í€¸ì˜ í–‰(1 ~ 8)                               |
| ì œì•½ ì¡°ê±´ | Constraint[int, int] | ëª¨ë“  í€¸ì€ ì„œë¡œ ë‹¤ë¥¸ ì¤„ ë° ëŒ€ê°ì„ ì— ìœ„ì¹˜í•œë‹¤. |

<u>ì œì•½ ì¡°ê±´ ì„¤ì •</u>

```python
class QueensConstraint(Constraint[int, int]):
    def __init__(self, columns:List[int]) -> None:
        super().__init__(columns)
        self.columns:List[int] = columns

    def satisfied(self, assignment:Dict[int, int]) -> bool:
        """
        q1c = í€¸1ì˜ ì—´, q1r = í€¸1ì˜ í–‰
        q2c = í€¸2ì˜ ì—´, q2r = í€¸2ì˜ í–‰
        """
        for q1c, q1r in assignment.items():                     # ëª¨ë“  keyì™€ valueì— ëŒ€í•´ ë°˜ë³µ
            for q2c in range(q1c + 1, len(self.columns) + 1):   # 1. ë‚¨ì€ ì—´ì— ëŒ€í•´ ë°˜ë³µ(ë‘ í€¸ì€ ê°™ì€ í–‰ì— ìœ„ì¹˜í•  ìˆ˜ ì—†ë‹¤)
                if q2c in assignment:
                    q2r:int = assignment[q2c]
                    if q1r == q2r:                              # 2. ë‘ í€¸ì´ ê°™ì€ í–‰ì— ìœ„ì¹˜í•  ìˆ˜ ì—†ë‹¤.
                        return False
                    if abs(q1r - q2r) == abs(q1c - q2c):        # 3. ë‘ í€¸ì´ ê°™ì€ ëŒ€ê°ì„ ì— ìœ„ì¹˜í•  ìˆ˜ ì—†ë‹¤.
                        return False
        return True
```

í€¸ì˜ ì—´ì„ ë³€ìˆ˜ë¡œ ì‚¬ìš©í•˜ë¯€ë¡œ ì œì•½ ì¡°ê±´ ì„¤ì • ì‹œ ë‘ í€¸ì€ ìì—°ìŠ¤ëŸ½ê²Œ ë‹¤ë¥¸ ì—´ì— ë°°ì¹˜ëœë‹¤. ë”°ë¼ì„œ í–‰ì˜ ìœ„ì¹˜ë§Œ ë¹„êµí•˜ë©´ ëœë‹¤.

ê°™ì€ ëŒ€ê°ì„ ì— ìœ„ì¹˜í•˜ëŠ” ëª¨ë“  ê²©ìëŠ” ì—´ê³¼ í–‰ì˜ ì°¨ê°€ ì¼ì •í•˜ë‹¤. ì´ë¥¼ ì´ìš©í•´ ì œì•½ ì¡°ê±´ ì•Œê³ ë¦¬ì¦˜ì„ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.

<u>main</u>

```python
if __name__ == "__main__":
    
    # V
    columns:List[int] = [1, 2, 3, 4, 5, 6, 7, 8]
    
    # D
    rows:Dict[int, List[int]] = {}
    for column in columns:
        rows[column] = [1, 2, 3, 4, 5, 6, 7, 8]
        
    # constraint
    csp:CSP[int, int] = CSP(columns, rows)
    csp.add_constraint(QueensConstraint(columns))
    
    # solution
    solution:Optional[Dict[int, int]] = csp.backtracking_search()
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        print(solution)
```

<u>terminal</u>

```
{1: 1, 2: 5, 3: 8, 4: 6, 5: 3, 6: 7, 7: 2, 8: 4}
```

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/8queens.png?raw=true)

---

# 3. SEND+MORE=MONEY

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-3-3.png?raw=true)

**ë³µë©´ì‚° í¼ì¦**(cryptarithmetic puzzleì˜ ì¼ì¢…ìœ¼ë¡œ, ë¬¸ìë¡œ ì•”í˜¸í™”ëœ ê³„ì‚°ì‹ì„ ë³µí˜¸í™”í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤. ê°™ì€ ë¬¸ìëŠ” ê°™ì€ ìˆ«ìë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.

ë³€ìˆ˜, ë„ë©”ì¸, ì œì•½ ì¡°ê±´ì„ ì •ì˜í•œë‹¤.

|           | íƒ€ì…                 | ì„¤ëª…                                         |
| --------- | -------------------- | -------------------------------------------- |
| ë³€ìˆ˜(V)   | str                  | ë¬¸ì                                         |
| ë„ë©”ì¸(D) | int                  | ë¬¸ìê°€ ì˜ë¯¸í•˜ëŠ” ìˆ«ì(0 ~ 9)                  |
| ì œì•½ ì¡°ê±´ | Constraint[str, int] | ì„œë¡œ ë‹¤ë¥¸ ë¬¸ìëŠ” ê°™ì€ ìˆ«ìë¥¼ ë‚˜íƒ€ë‚¼ ìˆ˜ ì—†ë‹¤. |



<u>ì œì•½ ì¡°ê±´ ì„¤ì •</u>

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional


class SendMoreMoneyConstraint(Constraint[str, int]):
    def __init__(self, letters:List[str]) -> None:
        super().__init__(letters)
        self.letters:List[str] = letters

    def satisfied(self, assignment:Dict[str, int]) -> bool:
        if len(set(assignment.values())) < len(assignment):
            return False
    
        if len(assignment) == len(self.letters):
            s:int = assignment["S"]
            e:int = assignment["E"]
            n:int = assignment["N"]
            d:int = assignment["D"]
            m:int = assignment["M"]
            o:int = assignment["O"]
            r:int = assignment["R"]
            y:int = assignment["Y"]
            send:int = s * 1000 + e * 100 + n * 10 + d
            more:int = m * 1000 + o * 100 + r * 10 + e
            money:int = m * 10000 + o * 1000 + n * 100 + e * 10 + y
            return send + more == money
        return True
```

<u>main</u>

```python
if __name__ == "__main__":

    # V
    letters:List[str] = ["S", "E", "N", "D", "M", "O", "R", "Y"]

    # D
    possible_digits:Dict[str, List[int]] = {}
    for letter in letters:
        possible_digits[letter] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    possible_digits["M"] = [1]

    # constraint
    csp:CSP[str, int] = CSP(letters, possible_digits)
    csp.add_constraint(SendMoreMoneyConstraint(letters))
    
    # solution
    solution:Optional[Dict[str, int]] = csp.backtracking_search()
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        print(solution)
```



<u>terminal</u>

```
{'S': 9, 'E': 5, 'N': 6, 'D': 7, 'M': 1, 'O': 0, 'R': 8, 'Y': 2}
```

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/SENDMOREMONEY.png?raw=true)

---

# 4. ë‹¨ì–´ ê²€ìƒ‰

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-3-4.png?raw=true)

ì˜ë¬¸ìë¡œ êµ¬ì„±ëœ ê²©ìì—ì„œ í–‰ê³¼ ì—´, ëŒ€ê°ì„ ì„ ë”°ë¼ ë°°ì¹˜ëœ íŠ¹ì • ë‹¨ì–´ë¥¼ ì°¾ëŠ”ë‹¤ê³  ê°€ì •í•œë‹¤. ë‹¨ì–´ì˜ ìœ„ì¹˜ëŠ” ê²¹ì¹˜ê±°ë‚˜ ê²©ì ë²”ìœ„ë¥¼ ë²—ì–´ë‚  ìˆ˜ ì—†ë‹¤. ë¬¸ì œë¥¼ ê°„ë‹¨íˆ í•˜ê¸° ìœ„í•´ ê²©ìì— ì¤‘ë³µ ë‹¨ì–´ì˜ ì‚¬ìš©ì„ ë°°ì œí•œë‹¤.

ë³€ìˆ˜, ë„ë©”ì¸, ì œì•½ ì¡°ê±´ì„ ì •ì˜í•œë‹¤.

|           | íƒ€ì…                                | ì„¤ëª…                 |
| --------- | ----------------------------------- | -------------------- |
| ë³€ìˆ˜(V)   | str                                 | ë‹¨ì–´                 |
| ë„ë©”ì¸(D) | List[GridLocation]                  | ë‹¨ì–´ì˜ ìœ„ì¹˜          |
| ì œì•½ ì¡°ê±´ | Constraint[str, List[GridLocation]] | ë‹¨ì–´ëŠ” ê²¹ì¹  ìˆ˜ ì—†ë‹¤. |

```python
from typing import NamedTuple, Dict, List, Optional
from random import choice
from string import ascii_uppercase
from csp import Constraint, CSP

Grid = List[List[str]]


class GridLocation(NamedTuple):
    row:int
    column:int
```

**GridLocation** í´ë˜ìŠ¤ëŠ” `NamedTuple`ì„ ìƒì†ë°›ì•„ ê²©ì í–‰ë ¬ì—ì„œì˜ ì•ŒíŒŒë²³ ìœ„ì¹˜ë¥¼ í‘œì‹œí•˜ëŠ” ì—­í• ì„ ìˆ˜í–‰í•œë‹¤.

```python
def generate_grid(rows:int, columns:int) -> Grid:
    return [[choice(ascii_uppercase) for c in range(columns)] for r in range(rows)]

def display_grid(grid:Grid) -> None:
    for row in grid:
        print(" ".join(row))
```

**generate_grid** í•¨ìˆ˜ëŠ” ë¬´ì‘ìœ„ ì•ŒíŒŒë²³ ëŒ€ë¬¸ìë¡œ ì±„ì›Œì§„ ê²©ìì¸ 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ë©°, **display_grid** í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ì¶œë ¥í•  ìˆ˜ ìˆë‹¤.

**random.choice** í•¨ìˆ˜ëŠ” ì…ë ¥ë°›ì€ Sequenceì—ì„œ ë¬´ì‘ìœ„ í•­ëª©ì„ ë°˜í™˜í•œë‹¤. ì´ë•Œ ì¸ìë¡œ "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ëŒ€ì‹  **string.ascii_uppercase**ë¥¼ ì‚¬ìš©í•´ ê°„ë‹¨í•˜ê²Œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆë‹¤.

<u>ë„ë©”ì¸ ì„¤ì •</u>

```python
def generate_domain(word:str, grid:Grid) -> List[List[GridLocation]]:
    domain:List[List[GridLocation]] = []
    height:int = len(grid)
    width:int = len(grid[0])
    length:int = len(word)
    for row in range(height):
        for col in range(width):
            columns:range = range(col, col + length + 1)
            rows:range = range(row, row + length + 1)
            if col + length <= width:
                # 1. ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ
                domain.append([GridLocation(row, c) for c in columns])
                if row + length <= height:
                    # 2. ëŒ€ê°ì„  ì˜¤ë¥¸ìª½ ì•„ë˜ë¡œ
                    domain.append([GridLocation(r, col + (r - row)) for r in rows])
            if row + length <= height:
                # 3. ìœ„ì—ì„œ ì•„ë˜ë¡œ
                domain.append([GridLocation(r, col) for r in rows])
                if col - length >= 0:
                    # 4. ëŒ€ê°ì„  ì™¼ìª½ ì•„ë˜ë¡œ
                    domain.append([GridLocation(r, col - (r - row)) for r in rows])
    return domain
```

**generate_domain** í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ë„ë©”ì¸ì„ ì„¤ì •í•œë‹¤. ë„ë©”ì¸(ë‹¨ì–´ì˜ ìœ„ì¹˜)ëŠ” ê²©ìë¥¼ ë²—ì–´ë‚  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ê²©ìì˜ í¬ê¸°ì™€ ë‹¨ì–´ì˜ ê¸¸ì´ì— ì˜í–¥ì„ ë°›ëŠ”ë‹¤.

<u>ì œì•½ ì¡°ê±´ ì„¤ì •</u>

```python
class WordSearchConstraint(Constraint[str, List[GridLocation]]):
    def __init__(self, words:List[str]) -> None:
        super().__init__(words)
        self.words:List[str] = words

    def satisfied(self, assignment:Dict[str, List[GridLocation]]) -> bool:
        all_locations = [locs for values in assignment.values() for locs in values]
        return len(set(all_locations)) == len(all_locations)
```

í• ë‹¹ëœ ë‹¨ì–´ ìœ„ì¹˜ì˜ ì¤‘ë³µì„ í™•ì¸í•˜ê¸° ìœ„í•´ **all_locations**ì— ëª¨ë“  ìœ„ì¹˜ë¥¼ ì €ì¥í•œë‹¤. ë¦¬ìŠ¤íŠ¸ë¥¼ ì§‘í•©(set)ìœ¼ë¡œ ë³€í™˜ ì‹œ ëª¨ë“  ì¤‘ë³µ í•­ëª©ì´ ì œê±°ë˜ë¯€ë¡œ ë¹„êµë¥¼ í†µí•´ ì¤‘ë³µ ì—¬ë¶€ë¥¼ ê²€ì‚¬í•  ìˆ˜ ìˆë‹¤.

<u>main</u>

```python
if __name__ == "__main__":

    # V
    grid:Grid = generate_grid(9, 9)

    # D
    words:List[str] = ["MATTHEW", "JOE", "MARY", "SARAH", "SALLY"]
    locations:Dict[str, List[List[GridLocation]]] = {}
    for word in words:
        locations[word] = generate_domain(word, grid)

    # constraint
    csp:CSP[str, List[GridLocation]] = CSP(words, locations)
    csp.add_constraint(WordSearchConstraint(words))
    
    # solution
    solution:Optional[Dict[str, List[GridLocation]]] = csp.backtracking_search()
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        for word, grid_locations in solution.items():
            if choice([True, False]):
                grid_locations.reverse()
            for index, letter in enumerate(word):
                (row, col) = (grid_locations[index].row, grid_locations[index].column)
                grid[row][col] = letter
        display_grid(grid)
```

<u>terminal</u>

```
Y W E H T T A M J
M A R Y D S F Q O
R M B A F A Y A E
O S Y C Y R L R P
R I W Z P A L A Z
K T T H M H A P K
C T L X T I S C C
C E H C S E O R X
M I Z A H L G W Z
```

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/word_search.png?raw=true)

---

# ì—°ìŠµë¬¸ì œ

## ğŸ“ 3-1

1. *Practice question*

   WordSearchConstraint í´ë˜ìŠ¤ë¥¼ ìˆ˜ì •í•˜ì—¬ ì¤‘ë³µ ë‹¨ì–´ë¥¼ í—ˆìš©í•˜ëŠ” ë‹¨ì–´ ê²€ìƒ‰ì„ êµ¬í˜„í•˜ë¼.

3-1

---

## ğŸ“ 3-2

1. *Practice question*

   íšŒë¡œíŒ ë ˆì´ì•„ì›ƒ ë¬¸ì œ

ë‹¨ì–´ ê²€ìƒ‰ ë¬¸ì œ ì•Œê³ ë¦¬ì¦˜ì„ ì‘ìš©í•˜ì—¬ í•´ê²°í•  ìˆ˜ ìˆë‹¤. ê²©ìëŠ” ë¬´ì‘ìœ„ ì˜ë¬¸ì ëŒ€ì‹  ë¹ˆ ì¹¸ìœ¼ë¡œ ì±„ì›Œì§„ë‹¤. ê²½ê³„ë¥¼ ëª…í™•íˆ í‘œì‹œí•˜ê¸° ìœ„í•´ íŠ¹ìˆ˜ë¬¸ìë¥¼ ì‚¬ìš©í•œë‹¤.

```python
def generate_grid(rows:int, columns:int) -> Grid:
    return [["â–¡" for c in range(columns)] for r in range(rows)]
```

ê¸°ì¡´ ì•Œê³ ë¦¬ì¦˜ì˜ DëŠ” ë¬¸ìì—´ íƒ€ì…ìœ¼ì¸ë±ìŠ¤ì™€ ì´ì— ëŒ€ì‘í•˜ëŠ” ë¬¸ìë¡œ ê²©ìë¥¼ ì±„ìš¸ ìˆ˜ ìˆì—ˆë‹¤. 

íšŒë¡œíŒ ë ˆì´ì•„ì›ƒ ë¬¸ì œì—ì„œëŠ” **M x N** ì‚¬ê°í˜•ì˜ ì¹©ì„ ì‚¬ìš©í•œë‹¤. ì‚¬ê°í˜•ì˜ í¬ê¸°ì™€, ê²©ìíŒì— í‘œì‹œí•  ë¬¸ìë¥¼ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ íƒ€ì… Dì— ë¬¸ìì—´ ëŒ€ì‹  íŠœí”Œì„ ì‚¬ìš©í•œë‹¤.

```python
words:List[Tuple[str, int, int]] = [("A", 1, 6),
                                    ("B", 4, 4),
                                    ("C", 3, 3),
                                    ("D", 2, 2),
                                    ("E", 5, 2)]
locations:Dict[str, List[List[GridLocation]]] = {}
for word in words:
    locations[word] = generate_domain(word, grid)
```

**solution**ì„ í™”ë©´ì— í‘œì‹œí•˜ëŠ” ë°©ë²•ì„ ë³€ê²½í•œë‹¤. ê¸°ì¡´ì˜ ë°˜ì „ ìš”ì†Œ ì—­ì‹œ ì‚­ì œí•œë‹¤.

```python
solution:Optional[Dict[str, List[GridLocation]]] = csp.backtracking_search()
if solution is None:
    print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
else:
    for word, grid_locations in solution.items():
        for element in grid_locations:
            row, col = element.row, element.column
            grid[row][col] = word[0]
    display_grid(grid)
```

ì‚¬ê°í˜•ì˜ ë°°ì¹˜ëŠ” ë‹¨ì–´ì˜ ë°°ì¹˜ë³´ë‹¤ ëœ ë³µì¡í•˜ë‹¤. í˜„ì¬ ì¢Œí‘œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‘ ê°œì˜ ê¸¸ì´ ë³€ìˆ˜ë¥¼ í™œìš©í•´ ê³„ì‚°í•˜ì—¬, ì‚¬ê°í˜•ì˜ í¬ê¸°ê°€ ê²©ìì˜ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ë„ë©”ì¸ì˜ í•­ëª©ìœ¼ë¡œ ì¶”ê°€í•œë‹¤.

```python
def generate_domain(word:str, grid:Grid) -> List[List[GridLocation]]:
    domain:List[List[GridLocation]] = []
    height:int = len(grid)
    width:int = len(grid[0])
    length1:int = word[1]
    length2:int = word[2]
    for row in range(height):
        for col in range(width):
            columns:range = range(col, col + length1)
            rows:range = range(row, row + length2)
            if (col + length1 <= width) and (row + length2 <= height):
                domain.append([GridLocation(r, c) for c in columns for r in rows])
    return domain
```

ì „ì²´ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

<u>ì—°ìŠµë¬¸ì œ 3-2.py</u>

```python
from typing import NamedTuple, List, Dict, Optional, Tuple
from csp import Constraint, CSP

Grid = List[List[str]]


class GridLocation(NamedTuple):
    row:int
    column:int


def generate_grid(rows:int, columns:int) -> Grid:
    return [["â–¡" for c in range(columns)] for r in range(rows)]

def display_grid(grid:Grid) -> None:
    for row in grid:
        print(" ".join(row))

def generate_domain(word:str, grid:Grid) -> List[List[GridLocation]]:
    domain:List[List[GridLocation]] = []
    height:int = len(grid)
    width:int = len(grid[0])
    length1:int = word[1]
    length2:int = word[2]
    for row in range(height):
        for col in range(width):
            columns:range = range(col, col + length1)
            rows:range = range(row, row + length2)
            if (col + length1 <= width) and (row + length2 <= height):
                domain.append([GridLocation(r, c) for c in columns for r in rows])
    return domain


class WordSearchConstraint(Constraint[str, List[GridLocation]]):
    def __init__(self, words:List[Tuple[str, int, int]]) -> None:
        super().__init__(words)
        self.words:List[Tuple[str, int, int]] = words

    def satisfied(self, assignment:Dict[str, List[GridLocation]]) -> bool:
        all_locations = [locs for values in assignment.values() for locs in values]
        return len(set(all_locations)) == len(all_locations)


if __name__ == "__main__":

    # V
    grid:Grid = generate_grid(9, 9)

    # D
    words:List[Tuple[str, int, int]] = [("A", 1, 6),
                                        ("B", 4, 4),
                                        ("C", 3, 3),
                                        ("D", 2, 2),
                                        ("E", 5, 2)]
    locations:Dict[str, List[List[GridLocation]]] = {}
    for word in words:
        locations[word] = generate_domain(word, grid)

    # constraint
    csp:CSP[str, List[GridLocation]] = CSP(words, locations)
    csp.add_constraint(WordSearchConstraint(words))
    
    # solution
    solution:Optional[Dict[str, List[GridLocation]]] = csp.backtracking_search()
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        for word, grid_locations in solution.items():
            for element in grid_locations:
                row, col = element.row, element.column
                grid[row][col] = word[0]
        display_grid(grid)
```

<u>terminal</u>

```
A B B B B C C C â–¡
A B B B B C C C â–¡
A B B B B C C C â–¡
A B B B B D D â–¡ â–¡
A â–¡ â–¡ â–¡ â–¡ D D â–¡ â–¡
A E E E E E â–¡ â–¡ â–¡
â–¡ E E E E E â–¡ â–¡ â–¡
â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡
â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡
```

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/ex 3-2.png?raw=true)

---

## ğŸ“ 3-3

1. *Practice question*

   ìŠ¤ë„ì¿  ë¬¸ì œ



ìŠ¤ë„ì¿  ë¬¸ì œëŠ” ì¢Œí‘œ ê°œë…ì„ ì‚¬ìš©í•´ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤. ê°™ì€ í–‰, ì—´, êµ¬ì—­ì€ ì¤‘ë³µì„ í—ˆìš©í•˜ì§€ ì•ŠëŠ” 1~9ì˜ ìˆ«ìë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤. 

- **í–‰**: 0í–‰ ~ 8í–‰
- **ì—´**: 0ì—´ ~ 8ì—´
- **êµ¬ì—­**: 0êµ¬ì—­ ~ 8êµ¬ì—­

ê¸°ì¡´ì˜ GridLocationì„ ë³€í˜•í•œë‹¤.

```python
class GridLocation(NamedTuple):
    row:int
    column:int
    realm:int = 3 * (row // 3) + column // 3
```

realmì€ ë‚´ë¶€ì ìœ¼ë¡œ ê³„ì‚°ëœë‹¤.

KEY: GridLocation, VALUE: int ok?

3 x 3 í¬ê¸°ê°€ ì•„ë‹Œ í¼ì¦ì— ëŒ€í•´ì„œëŠ” 3, 9 ëŒ€ì‹  ìƒìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

- SIZE: êµ¬ì—­ì˜ í¬ê¸°(= 3)
- WIDTH: ìŠ¤ë„ì¿  í¼ì¦ì˜ í¬ê¸°(= 9 = math.pow(SIZE, 2))



satisfied: í˜„ì¬ GridLocationì˜ row, columnì— ëŒ€í•´

- ê°™ì€ rowë¥¼ ê°€ì§€ëŠ” ì§‘í•©ì˜ ì›ì†Œê°€ ë  ìˆ˜ ì—†ë‹¤.
- ê°™ì€ columnì„ ê°€ì§€ëŠ” ì§‘í•©ì˜ ì›ì†Œê°€ ë  ìˆ˜ ì—†ë‹¤.

- ê°™ì€ êµ¬ì—­ì— ì†í•˜ëŠ” ì§‘í•©ì˜ ì›ì†Œê°€ ë  ìˆ˜ ì—†ë‹¤.



ì˜ˆë¥¼ ë“¤ì–´ row=3, column=5ì¼ ë•Œ realm=4ì´ë‹¤

`if assignment[GridLocation[3][5]] in rows[GridLocation.row]: return False`

