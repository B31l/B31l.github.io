---
layout: post
meta: "Week-2"
title: "Week-2: ê²€ìƒ‰ ë¬¸ì œ"
categories: Classic
tags: Python
---

* content
{:toc}
# ì„œë¡ 

ì„¸ ê°œì˜ ë¬¸ì œì— ì‚¬ìš©ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì€ ì œë„¤ë¦­ í”„ë¡œê·¸ë˜ë° ê¸°ë²•ì„ í†µí•´ ì¼ë°˜í™”í•œ ë’¤ ê´‘ë²”ìœ„í•œ ë¬¸ì œì— ì ìš©í•  ìˆ˜ ìˆë‹¤.

ë³¸ ë¬¸ì„œì—ì„œ ì œë„¤ë¦­ í”„ë¡œê·¸ë˜ë°ì„ ì‚¬ìš©í•œ ì±•í„°ëŠ” ğŸ’¾ë¥¼, ì—°ìŠµë¬¸ì œë¥¼ í‘¼ ì±•í„°ëŠ” ğŸ“ì„ í‘œì‹œí–ˆë‹¤.

ì‹œì‘í•˜ê¸° ì•ì„œ ë‹¤ìŒ ëª¨ë“ˆì„ importí•´ íƒ€ì… íŒíŠ¸ì™€ í™ ì‚¬ìš©ì„ ì¤€ë¹„í•œë‹¤.

```python
# import
from __future__ import annotations
from typing import TypeVar, Iterable, Sequence, Generic, List, Callable, Set, Deque, Dict, Any, Optional
from typing_extensions import Protocol
from heapq import heappush, heappop
```

---

# DNA ê²€ìƒ‰

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-2-1.png?raw=true)

```python
# import
from enum import IntEnum
from typing import Tuple, List
```

## ê°œìš” : êµ¬ì¡° í‘œí˜„í•˜ê¸°

- **ë‰´í´ë ˆì˜¤íƒ€ì´ë“œ**(Nucleotide)

  A, C, G, T ì¤‘ í•˜ë‚˜ë¡œ í‘œí˜„í•œë‹¤.

```python
Nucleotide:IntEnum = IntEnum('Nucleotide', ('A', 'C', 'G', 'T'))
```

> *Note*
>
> **Enum** ëª¨ë“ˆì„ ì‚¬ìš©í•´ íŒŒì´ì¬ì—ì„œë„ ì—´ê±° íƒ€ì…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. í›„ìˆ í•  ì´ì§„ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì—ì„œ ë‰´í´ë ˆì˜¤íƒ€ì´ë“œì— ëŒ€í•œ ë¹„êµê°€ ë°œìƒí•˜ë¯€ë¡œ ë¹„êµ ì—°ì‚°ìë¥¼ ì§€ì›í•˜ëŠ” **IntEnum** íƒ€ì…ì„ ì‚¬ìš©í•œë‹¤. 

- **ì½”ëˆ**(Codon)

  ì„¸ ê°œì˜ ë‰´í´ë ˆì˜¤íƒ€ì´ë“œë¡œ êµ¬ì„±ëœë‹¤.

```python
Codon = Tuple[Nucleotide, Nucleotide, Nucleotide]
```

  ![](https://sandbox.dodona.be/en/activities/1424446086/description/Yn99UqMgqip_9ACf/media/codons.png)

  ğŸ›´ <https://dodona.ugent.be/en/activities/1424446086/>

- **ìœ ì „ì**(Gene)

  ë‹¤ìˆ˜ì˜ ì½”ëˆìœ¼ë¡œ êµ¬ì„±ëœë‹¤. 
  
```python
Gene = List[Codon]
```

> *Note*
>
> **íƒ€ì… ì•¨ë¦¬ì–´ìŠ¤**(Type alias)ë¥¼ ì‚¬ìš©í•´ ê¸´ íƒ€ì…ëª… ëŒ€ì‹  ì§§ì€ ë³„ì¹­ì„ ì§€ì •í•¨ìœ¼ë¡œì¨, íƒ€ì… íŒíŠ¸ê°€ ê¸¸ì–´ì§ˆ ë•Œ ë°œìƒí•˜ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ Codonì€ 3ê°œì˜ Nucleotideë¡œ êµ¬ì„±ëœ Tuple íƒ€ì…ì´ë¯€ë¡œ Tuple[Nucleotide, Nucleotide, Nucleotide]ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ê¸´ íƒ€ì…ëª…ì€ ë³€ìˆ˜ ì„ ì–¸ ê³¼ì •ì´ ë²ˆê±°ë¡œìš¸ ë¿ ì•„ë‹ˆë¼ ì½”ë“œì˜ ì§ê´€ì„±ê³¼ ê°„ê²°ì„±ì„ í•´ì¹˜ë¯€ë¡œ Codonìœ¼ë¡œ ì§§ê²Œ í‘œí˜„í•œë‹¤.

ê²€ìƒ‰ ì‘ì—…ì„ ì‹œí–‰í•˜ê¸° ì•ì„œ ì£¼ì–´ì§„ ë‰´í´ë ˆì˜¤íƒ€ì´ë“œë¡œ êµ¬ì„±ëœ ë¬¸ìì—´ì„ 3ê¸€ìì”© ëŠì–´ì„œ ìœ ì „ì ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•œë‹¤.

```python
def string_to_gene(s:str) -> Gene:
    gene:Gene = []
    for i in range(0, len(s), 3):
        if (i + 2) >= len(s):
            return gene
        codon:Codon = (Nucleotide[s[i]]), Nucleotide[s[i+1]], Nucleotide[s[i+2]]
        gene.append(codon)
    return gene

gene_str:str = "ACGTGGCTCTCTAACGTACGTACGTACGGGGTTTATATATACCCTAGGACTCCCTTT"
my_gene:Gene = string_to_gene(gene_str)
```

## ì„ í˜• ê²€ìƒ‰

ìœ ì „ì ë¦¬ìŠ¤íŠ¸ê°€ íŠ¹ì • ì½”ëˆ(Key)ë¥¼ í¬í•¨í•˜ê³  ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ê³¼ì •ì„ **ê²€ìƒ‰**ì´ë¼ê³  í•˜ë©°, ë‘ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

**ì„ í˜• ê²€ìƒ‰**(ë˜ëŠ” ìˆœì°¨ ê²€ìƒ‰)ì€ ìœ ì „ì ë¦¬ìŠ¤íŠ¸ì˜ ëª¨ë“  ì½”ëˆì— ëŒ€í•´ Keyì™€ ë¹„êµí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì´ë£¨ì–´ì§„ë‹¤. ë§Œì•½ ê°’ì´ ê°™ë‹¤ë©´ ê²€ìƒ‰ ì„±ê³µì´ë¯€ë¡œ Trueë¥¼ ë¦¬í„´í•˜ê³ , ê°’ì´ ë‹¤ë¥´ë‹¤ë©´ ë‹¤ìŒ ì½”ëˆìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤. Keyì™€ ê°™ì€ ì½”ëˆì´ í•˜ë‚˜ë„ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ê²€ìƒ‰ ì‹¤íŒ¨ì´ë¯€ë¡œ Falseë¥¼ ë¦¬í„´í•œë‹¤.

ì„ í˜• ê²€ìƒ‰ì€ ë¦¬ìŠ¤íŠ¸ ë‚´ í•­ëª©ì˜ ê°œìˆ˜ê°€ Nì¼ ë•Œ ìµœëŒ€ Në²ˆì˜ ë¹„êµê°€ ì´ë£¨ì–´ì§€ë©°, ë”°ë¼ì„œ **O(N)**ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°–ëŠ”ë‹¤.

```python
def linear_contains(gene:Gene, key_codon:Codon) -> bool:
    for codon in gene:
        if codon == key_codon:
            return True
    return False
```

## ğŸ’¾ ì„ í˜• ê²€ìƒ‰ì˜ ì¼ë°˜í™”

ë°©ê¸ˆ ì‘ì„±í•œ ì•Œê³ ë¦¬ì¦˜ì€ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì—ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤. ë”°ë¼ì„œ ì¼ë°˜í™” ê³¼ì •ì„ ê±°ì¹˜ëŠ” ê³¼ì •ì´ í•„ìš”í•˜ë‹¤.

| ê¸°ì¡´ ì•Œê³ ë¦¬ì¦˜                                                | ì¼ë°˜í™” ì•Œê³ ë¦¬ì¦˜                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| ê²€ìƒ‰í•  ê°’: `Codon`<br>3ê°œì˜ Nucleotide íƒ€ì…ìœ¼ë¡œ êµ¬ì„±ëœ Tuple íƒ€ì… | ê²€ìƒ‰í•  ê°’ `T`<br>ì‚¬ìš©ì ì •ì˜ íƒ€ì…ìœ¼ë¡œ, ì–´ë–¤ íƒ€ì…ë„ ìƒê´€ì—†ìŒ  |
| ê²€ìƒ‰ì˜ ë²”ìœ„: `Gene`<br>Codon íƒ€ì…ìœ¼ë¡œ êµ¬ì„±ëœ List íƒ€ì…       | ê²€ìƒ‰ì˜ ë²”ìœ„ `Iterable[T]`<br>Të¡œ êµ¬ì„±ëœ Iterable(str, list, tuple, dict, set ë“±) íƒ€ì… |

`TypeVar`ì„ ì‚¬ìš©í•´ ì‚¬ìš©ì ì •ì˜ íƒ€ì… `T`ë¥¼ í‘œí˜„í•œë‹¤.

```python
T = TypeVar('T')
```

ì´ì œ Codonê³¼ Geneì„ ê°ê° Tì™€ Iterable[T]ë¡œ ì¹˜í™˜í•´ ì„ í˜• ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ ì¼ë°˜í™”í•œë‹¤. 

```python
def linear_contains(iterable:Iterable[T], key:T) -> bool:
    for item in iterable:
        if item == key:
            return True
    return False
```

## ì´ì§„ ê²€ìƒ‰

ì´ì§„ ê²€ìƒ‰ì€ ìœ ì „ì ë¦¬ìŠ¤íŠ¸ì˜ ì„ì˜ì˜ ì½”ëˆê³¼ Keyì˜ ëŒ€ì†Œ ê´€ê³„ë¥¼ ë¹„êµí•œ ë’¤, íƒìƒ‰ ë²”ìœ„ë¥¼ ì¢íˆëŠ” ë°©ì‹ìœ¼ë¡œ ì´ë£¨ì–´ì§„ë‹¤. ì„ì˜ì˜ ê°’ì´ ì°¾ê³ ì í•˜ëŠ” ê°’ë³´ë‹¤ í¬ë‹¤ë©´ ë” ì‘ì€ ë²”ìœ„ì—ì„œ ì„ì˜ì˜ ê°’ì„ ì¬ì§€ì •í•˜ë©°, ë°˜ëŒ€ë¡œ ì„ì˜ì˜ ê°’ì´ ì°¾ê³ ì í•˜ëŠ” ê°’ë³´ë‹¤ ì‘ë‹¤ë©´ ë” í° ë²”ìœ„ì—ì„œ ì„ì˜ì˜ ê°’ì„ ì¬ì§€ì •í•œë‹¤. ë§Œì•½ ë‘ ê°’ì´ ê°™ë‹¤ë©´ ê²€ìƒ‰ ì„±ê³µì´ë¯€ë¡œ Trueë¥¼ ë¦¬í„´í•˜ê³ , íƒìƒ‰ ë²”ìœ„ë¥¼ ë” ì´ìƒ ì¢íˆì§€ ëª»í•œë‹¤ë©´ ê²€ìƒ‰ ì‹¤íŒ¨ì´ë¯€ë¡œ Falseë¥¼ ë¦¬í„´í•œë‹¤.

ë‹¨, ìœ„ ë°©ë²•ì´ ì„±ë¦½í•˜ê¸° ìœ„í•´ì„œëŠ” ìœ ì „ì ë¦¬ìŠ¤íŠ¸ê°€ ì •ë ¬ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤.

ì´ì§„ ê²€ìƒ‰ì€ ë¦¬ìŠ¤íŠ¸ ë‚´ í•­ëª©ì˜ ê°œìˆ˜ê°€ Nì¼ ë•Œ ìµœëŒ€ logNë²ˆì˜ ë¹„êµê°€ ì´ë£¨ì–´ì§€ë©°, ë”°ë¼ì„œ **O(logN)**ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°–ëŠ”ë‹¤.

```python
def binary_contains(gene:Gene, key_codon:Codon) -> bool:
    low:int = 0
    high:int = len(gene) - 1
    while low <= high:
        mid:int = (low + high) // 2
        if gene[mid] < key_codon:
            low = mid + 1
        elif gene[mid] > key_codon:
            high = mid - 1
        else:
            return True
    return False
```

## ğŸ’¾ ì´ì§„ ê²€ìƒ‰ì˜ ì¼ë°˜í™”

ì„ í˜• ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ì´ì§„ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ ì—­ì‹œ ì¼ë°˜í™”í•  ìˆ˜ ìˆë‹¤.

| ê¸°ì¡´ ì•Œê³ ë¦¬ì¦˜                                                | ì¼ë°˜í™” ì•Œê³ ë¦¬ì¦˜                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| ê²€ìƒ‰í•  ê°’: `Codon`<br>3ê°œì˜ Nucleotide íƒ€ì…ìœ¼ë¡œ êµ¬ì„±ëœ Tuple íƒ€ì… | ê²€ìƒ‰í•  ê°’ `C`<br>ì‚¬ìš©ì ì •ì˜ íƒ€ì…ìœ¼ë¡œ, ë¹„êµ ì—°ì‚°ì„ ì§€ì›í•´ì•¼ í•¨ |
| ê²€ìƒ‰ì˜ ë²”ìœ„: `Gene`<br>Codon íƒ€ì…ìœ¼ë¡œ êµ¬ì„±ëœ List íƒ€ì…       | ê²€ìƒ‰ì˜ ë²”ìœ„ `Sequence[C]`<br>Cë¡œ êµ¬ì„±ëœ Sequence(str, list, tuple) íƒ€ì… |

ì´ì§„ ê²€ìƒ‰ì€ ì„ í˜• ê²€ìƒ‰ê³¼ ë‹¤ë¥´ê²Œ ë¹„êµ ì—°ì‚°ì´ ì´ë£¨ì–´ì§€ë¯€ë¡œ ì´ë¥¼ ì§€ì›í•˜ëŠ” ìƒˆë¡œìš´ ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì„ ë§Œë“¤ì–´ì•¼ í•œë‹¤. ë˜í•œ ê²€ìƒ‰ì˜ ë²”ìœ„ê°€ ì •ë ¬ë˜ì–´ ìˆì–´ì•¼ í•˜ë¯€ë¡œ Iterable ëŒ€ì‹  Sequenceë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

> *Note*
>
> **Sequence** íƒ€ì…ì€ Iterable íƒ€ì… ì¤‘ì—ì„œë„ ìˆœì„œê°€ ìˆëŠ” íƒ€ì…ì„ ì˜ë¯¸í•œë‹¤. ì¦‰, ì¸ë±ì‹±ê³¼ ìŠ¬ë¼ì´ì‹±ì„ ì§€ì›í•´ì•¼ í•œë‹¤. **ì •ë ¬** ì—­ì‹œ í•­ëª©ì„ ìˆœì„œëŒ€ë¡œ ì¬ë°°ì—´í•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ë¯€ë¡œ, ì˜¤ì§ Sequence íƒ€ì…ì—ì„œë§Œ ì§€ì›í•œë‹¤.

`TypeVar`ì„ ì‚¬ìš©í•´ ë¹„êµ ì—°ì‚°ì„ ì§€ì›í•˜ëŠ” ì‚¬ìš©ì ì •ì˜ íƒ€ì… `C`ë¥¼ í‘œí˜„í•œë‹¤.

```python
C = TypeVar("C", bound="Comparable")
```

ë¹„êµ ì—°ì‚°ìë¥¼ êµ¬í˜„í•˜ëŠ” Comparable í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•œë‹¤.

```python
class Comparable(Protocol):
    def __eq__(self, other:Any) -> bool:
        ...
    def __lt__(self:C, other:C) -> bool:
        ...
    def __gt__(self:C, other:C) -> bool:
        return (not self < other) and self != other
    def __le__(self:C, other:C) -> bool:
        return self < other or self == other
    def __ge__(self:C, other:C) -> bool:
        return not self < other
```

ì´ì œ Codonê³¼ Geneì„ ê°ê° Cì™€ Sequence[C]ë¡œ ì¹˜í™˜í•´ ì„ í˜• ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ ì¼ë°˜í™”í•œë‹¤. 

```python
def binary_contains(sequence:Sequence[C], key:C) -> bool:
    low:int = 0
    high:int = len(sequence) - 1
    while low <= high:
        mid:int = (low + high) // 2
        if sequence[mid] < key:
            low = mid + 1
        elif sequence[mid] > key:
            high= mid - 1
        else:
            return True
        return False
```

## ğŸ“ ì—°ìŠµë¬¸ì œ 2-1

1. *Q*

   dna_search.pyì—ì„œ ìˆ«ìê°€ 100ë§Œ ê°œì¸ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ë¼. ê·¸ë¦¬ê³  ì„ í˜• ê²€ìƒ‰ì˜ linear_contains( )ì™€ ì´ì§„ ê²€ìƒ‰ì˜ binary_contains( ) í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª‡ëª‡ ìˆ«ìë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ì¸¡ì •í•˜ë¼.

ì´ì§„ ê²€ìƒ‰ì˜ ì‹œê°„ë³µì¡ë„ëŠ” O(logN)ì´ë¯€ë¡œ, O(N)ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§€ëŠ” ì„ í˜• ê²€ìƒ‰ì— ë¹„í•´ í›¨ì”¬ íš¨ìœ¨ì ì´ë‹¤.

| ì„ í˜• ê²€ìƒ‰ | ì´ì§„ ê²€ìƒ‰ |
| --------- | --------- |
| O(N)      | O(logN)   |

ë‘ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì˜ íš¨ìœ¨ ì°¨ì´ë¥¼ ì§ê´€ì ìœ¼ë¡œ ì•Œ ìˆ˜ ìˆë„ë¡ time ëª¨ë“ˆì„ ì‚¬ìš©í•´ íŠ¹ì • ìˆ«ìë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ì¸¡ì •í•˜ë©°, ì¶©ë¶„íˆ í° í¬ê¸°ì˜ ë¦¬ìŠ¤íŠ¸ì—ì„œ ê²€ìƒ‰ì„ ì‹¤í–‰í•œë‹¤.

```python
from generic_search import linear_contains, binary_contains
import time

my_list = [x for x in range(1_000_000)]
test = [55555, 714285, 1000000]
```

**ì„ í˜• ê²€ìƒ‰**

```python
for i in test:
    start = time.time()
    linear_contains(my_list, i)
    end = time.time()
    print(f"{i}ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : {(end - start) * 1000} ms")
```

```
55555ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 1.9969940185546875 ms
714285ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 21.904706954956055 ms
1000000ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 33.91003608703613 ms
```

**ì´ì§„ ê²€ìƒ‰**

```python
for i in test:
    start = time.time()
    binary_contains(my_list, i)
    end = time.time()
    print(f"{i}ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : {(end - start) * 1000} ms")
```

```
55555ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 0.0 ms  
714285ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 0.0 ms 
1000000ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 0.0 ms
```

ì„ í˜• ê²€ìƒ‰ì—ì„œëŠ” Nì´ ìµœëŒ€ 100ë§Œì´ë©°, ìˆ«ìì˜ í¬ê¸°ê°€ ì»¤ì§ˆìˆ˜ë¡ ê²€ìƒ‰ì— í•„ìš”í•œ ë¹„êµ íšŸìˆ˜ê°€ ë§ì•„ì§€ë¯€ë¡œ ê²€ìƒ‰í•˜ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì€ ìˆ«ìì™€ ë¹„ë¡€í•œë‹¤.

ì„ í˜• ê²€ìƒ‰ ì—­ì‹œ ë¹ ë¥¸ ì†ë„ë¡œ ì´ë£¨ì–´ì§€ì§€ë§Œ, ì´ì§„ ê²€ìƒ‰ì—ì„œ logNì€ 20ë„ ì±„ ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì„ í˜• ê²€ìƒ‰ê³¼ëŠ” ë¹„êµí•  ìˆ˜ ì—†ì„ ì •ë„ë¡œ ë¹ ë¥´ë‹¤.

---

# ë¯¸ë¡œ ì°¾ê¸°

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-2-2.png?raw=true)

```python
# import
from enum import Enum
from typing import List, NamedTuple, Callable, Optional
import random
from math import sqrt
from generic_search import Node, node_to_path, dfs, bfs, astar
```

## ê°œìš” : ë¯¸ë¡œ ìƒì„±í•˜ê¸°

2ì°¨ì› ê²©ìì˜ ë¯¸ë¡œë¥¼ ìƒì„±í•œ ë’¤, ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë¯¸ë¡œ ì°¾ê¸° ì•Œê³ ë¦¬ì¦˜ì„ ì‘ì„±í•œë‹¤. 

`Cell` í´ë˜ìŠ¤ì—ì„œëŠ” ë¯¸ë¡œì—ì„œì˜ ê° ì¹¸ì˜ ìƒíƒœë¥¼ í‘œì‹œí•œë‹¤.

```python
class Cell(str, Enum):
    EMPTY   = " "
    BLOCKED = "X"
    START   = "S"
    GOAL    = "G"
    PATH    = "*"
```

`MazeLocation` í´ë˜ìŠ¤ì—ì„œëŠ” **ë„¤ì„ë“œíŠœí”Œ**(NamedTuple)ì„ ì‚¬ìš©í•´ ë¯¸ë¡œì—ì„œ ê° ì¹¸ì˜ ìœ„ì¹˜ë¥¼ í–‰ê³¼ ì—´ë¡œ ë‚˜íƒ€ë‚¸ë‹¤.

```python
class MazeLocation(NamedTuple):
    row:int
    column:int
```

> *Note*
>
> **ë„¤ì„ë“œíŠœí”Œ**(NamedTuple)ì—ì„œëŠ” ì‚¬ìš©ìê°€ í•­ëª©ì— ì´ë¦„ì„ ë¶™ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. í´ë˜ìŠ¤ì²˜ëŸ¼ ì„ ì–¸í•˜ê³  ì ‘ê·¼í•˜ì§€ë§Œ í´ë˜ìŠ¤ì— ë¹„í•´ ì ì€ ë©”ëª¨ë¦¬ ê³µê°„ì„ ì‚¬ìš©í•œë‹¤. ê¸°ì¡´ íŠœí”Œì˜ ì„±ì§ˆë„ ê°€ì§€ê³  ìˆê¸°ì— í•­ëª©ì€ ë¶ˆë³€í•˜ë©° ì¸ë±ìŠ¤ ë°©ì‹ì„ ì‚¬ìš©í•´ í•­ëª©ì— ì ‘ê·¼í•  ìˆ˜ë„ ìˆë‹¤.

`Maze` í´ë˜ìŠ¤ì—ì„œëŠ” ë¯¸ë¡œë¥¼ ìƒì„±í•œë‹¤.

```python
class Maze:
    def __init__(self, rows:int = 10, columns:int = 10,
                sparseness:float = 0.2,
                start:MazeLocation = MazeLocation(0, 0),
                goal:MazeLocation = MazeLocation(9, 9)) -> None:
        self._rows:int = rows
        self._columns:int = columns
        self.start:MazeLocation = start
        self.goal:MazeLocation = goal
        self._grid:List[List[Cell]] = [[Cell.EMPTY for c in range(columns)] for r in range(rows)]
        self._randomly_fill(rows, columns, sparseness)
        self._grid[start.row][start.column] = Cell.START
        self._grid[goal.row][goal.column] = Cell.GOAL
        
    def _randomly_fill(self, rows:int, columns:int, sparseness:float):
        for row in range(rows):
            for column in range(columns):
                if random.uniform(0, 1.0) < sparseness:
                    self._grid[row][column] = Cell.BLOCKED

    def __repr__(self) -> str:
        output:str = ""
        for row in self._grid:
            output += " ".join([c.value for c in row]) + "\n"
        return output

    def goal_test(self, ml:MazeLocation) -> bool:
        return ml == self.goal

    def successors(self, ml:MazeLocation) -> List[MazeLocation]:
        locations:List[MazeLocation] = []
        if ml.row + 1    < self._rows    and self._grid[ml.row + 1][ml.column] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row + 1, ml.column))
        if ml.row - 1    >= 0            and self._grid[ml.row - 1][ml.column] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row - 1, ml.column))
        if ml.column + 1 < self._columns and self._grid[ml.row][ml.column + 1] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row, ml.column + 1))
        if ml.column - 1 >= 0            and self._grid[ml.row][ml.column - 1] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row, ml.column - 1))
        return locations

    def mark(self, path:List[MazeLocation]):
        for maze_location in path:
            self._grid[maze_location.row][maze_location.column] = Cell.PATH
        self._grid[self.start.row][self.start.column] = Cell.START
        self._grid[self.goal.row][self.goal.column] = Cell.GOAL

    def clear(self, path:List[MazeLocation]):
        for maze_location in path:
            self._grid[maze_location.row][maze_location.column] = Cell.EMPTY
        self._grid[self.start.row][self.start.column] = Cell.START
        self._grid[self.goal.row][self.goal.column] = Cell.GOAL
```

- `__init__`: í¬ê¸°(rows, columns) ë° ë§‰íŒ ê³µê°„ì´ ì°¨ì§€í•˜ëŠ” ë¹„ìœ¨(sparseness)ì„ ë°”íƒ•ìœ¼ë¡œ ë¯¸ë¡œë¥¼ ìƒì„±í•œ ë’¤, íŠ¹ì • ì¹¸ì— ì‹œì‘ ìœ„ì¹˜ì™€ ì¢…ë£Œ ìœ„ì¹˜ë¥¼ í‘œì‹œí•œë‹¤.
- `_randomly_fill`: ë¯¸ë¡œì˜ ì¼ì • ë¶€ë¶„ì„ ë¬´ì‘ìœ„ë¡œ ë§‰íŒ ê³µê°„ Cell.BLOCKEDìœ¼ë¡œ ë°”ê¾¼ë‹¤. sparsenessê°€ 0.2ë©´ ì•½ 20%ì˜ ê³µê°„ì´ ë§‰íˆê²Œ ëœë‹¤.
- `__repr__`: ë¯¸ë¡œë¥¼ ì¶œë ¥í•œë‹¤.
- `goal_test`: ë§ì´ ì¢…ë£Œ ìœ„ì¹˜ì— ë„ë‹¬í–ˆëŠ”ì§€ í™•ì¸í•œë‹¤.
- `successors`: í•´ë‹¹ ìœ„ì¹˜ì—ì„œ ë§ì´ ì´ë™ ê°€ëŠ¥í•œ ìœ„ì¹˜ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜í•œë‹¤. ë¯¸ë¡œì˜ ê°€ì¥ìë¦¬ì— ìœ„ì¹˜í•˜ê±°ë‚˜ ìƒí•˜ì¢Œìš°ì— ë§‰íŒ ê³µê°„ì´ ìˆë‹¤ë©´ ê·¸ë§Œí¼ ê²½ë¡œëŠ” ì œí•œëœë‹¤.
- `mark`: ë§ì˜ ì´ë™ ê²½ë¡œë¥¼ Cell.PATHë¡œ í‘œì‹œí•œë‹¤.
- `clear`: ë¯¸ë¡œë¥¼ ì´ˆê¸°í™”í•œë‹¤. ëª¨ë“  ì¹¸ì„ Cell.EMPTYë¡œ ë°”ê¾¸ë©´ ëœë‹¤. 

ë¯¸ë¡œê°€ ì˜ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸í•œë‹¤.

```python
if __name__ == "__main__":
    m:Maze = Maze()
    print(m)
```

```python
S               X  

  X
    X     X       X

          X
X     X
      X       X

    X X X     X   G
```

## ğŸ’¾ Nodeì™€ ê²½ë¡œ ì¶œë ¥

ë¯¸ë¡œì—ì„œì˜ ê²½ë¡œëŠ” ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/maze-1.png?raw=true)

ë¯¸ë¡œì˜ ì‹œì‘ ìœ„ì¹˜ëŠ” íŠ¸ë¦¬ì˜ ë£¨íŠ¸ì— ì¡´ì¬í•œë‹¤. ì´í›„ successors í•¨ìˆ˜ì— ì˜í•´ ê°ˆ ìˆ˜ ìˆëŠ” ë…¸ë“œê°€ ìµœëŒ€ 4ê°œ í‘œì‹œëœë‹¤. `Node` í´ë˜ìŠ¤ì— ë…¸ë“œì˜ ì†ì„±ì„ ì‘ì„±í•œë‹¤.

```python
class Node(Generic[T]):
    def __init__(self, state:T, parent:Optional[Node], cost:float = 0.0, heuristic:float = 0.0):
        self.state:T = state
        self.parent:Optional[Node] = parent
        self.cost:float = cost
        self.heuristic:float = heuristic

    def __lt__(self, other:Node) -> bool:
        return (self.cost + self.heuristic) < (other.cost + other.heuristic)
```

- stateì™€ parentëŠ” ë¯¸ë¡œì˜ ê²½ë¡œ ì¶œë ¥ì— ì‚¬ìš©ëœë‹¤.
- costì™€ heuristic ë° lt ë¹„êµ ë©”ì„œë“œëŠ” A* ì•Œê³ ë¦¬ì¦˜ì—ì„œ ë…¸ë“œê°€ ê°€ì§€ëŠ” ë¹„ìš©ì„ ê³„ì‚°í•˜ëŠ” ë° ì‚¬ìš©ëœë‹¤. 



ë¯¸ë¡œì˜ ì¢…ë£Œ ìœ„ì¹˜ ë…¸ë“œê¹Œì§€ ì´ë™í•˜ë©´ íƒìƒ‰ ê³¼ì •ì´ ëë‚˜ë©°, `parent`(ë¶€ëª¨ ë…¸ë“œ)ë¥¼ ì‚¬ìš©í•´ ì‹œì‘ ìœ„ì¹˜ ë…¸ë“œ(ë£¨íŠ¸)ì—ì„œ ì¢…ë£Œ ìœ„ì¹˜ ë…¸ë“œê¹Œì§€ì˜ ê²½ë¡œë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜í•œë‹¤.

```python
def node_to_path(node:Node[T]) -> List[T]:
    path:List[T] = [node.state]
    while node.parent is not None:
        node = node.parent
        path.append(node.state)
    path.reverse()
    return path
```



## ğŸ’¾ ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/maze-2.png?raw=true)

ë§‰ë‹¤ë¥¸ ì§€ì ì— ë„ë‹¬í•˜ì—¬ ìµœì¢… ê²°ì • ì§€ì ìœ¼ë¡œ ëŒì•„ì˜¤ê¸° ì „ê¹Œì§€ ê°€ëŠ¥í•œ ê¹Šê²Œ íƒìƒ‰í•œë‹¤.

ì´ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•œ ìë£Œêµ¬ì¡°ë¡œ **ìŠ¤íƒ**(Stack)ì„ ì‚¬ìš©í•œë‹¤. ë‚´ë¶€ êµ¬ì¡°ë¡œëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•œë‹¤.

```python
class Stack(Generic[T]):
    def __init__(self) -> None:
        self._container:List[T] = []

    @property
    def empty(self) -> bool:
        return not self._container
    def push(self, item:T) -> None:
        self._container.append(item)
    def pop(self) -> T:
        return self._container.pop()
    def __repr__(self) -> str:
        return repr(self._container)
```

> *Note*
>
> **@property** ë°ì½”ë ˆì´í„°ë¥¼ ì‚¬ìš©í•´ ë©”ì„œë“œê°€ get ì—­í• ì„ í•œë‹¤ëŠ” ê²ƒì„ ëª…ì‹œí•  ìˆ˜ ìˆë‹¤.

ì´ë™í•  ë•Œë§ˆë‹¤ ë…¸ë“œë¥¼ pushí•˜ë©°, ë§‰ë‹¤ë¥¸ ê¸¸ì— ì´ë¥´ë©´ popí•œ ë’¤ ìƒˆë¡œìš´ ìì‹ ë…¸ë“œë¥¼ ì°¾ëŠ”ë‹¤.

```python
def dfs(initial:T, 
        goal_test:Callable[[T], bool], 
        successors:Callable[[T], List[T]]) -> Optional[Node[T]]:
    frontier:Stack[Node[T]] = Stack()
    frontier.push(Node(initial, None))
    explored:Set[T] = {initial}

    while not frontier.empty:
        current_node:Node[T] = frontier.pop()
        current_state:T = current_node.state
        if goal_test(current_state):
            return current_node
        for child in successors(current_state):
            if child in explored:
                continue
            explored.add(child)
            frontier.push(Node(child, current_node))
    return None
```

**ì‹¤í–‰**

```python
if __name__ == "__main__":
    solution1:Optional[Node[MazeLocation]] = dfs(m.start, m.goal_test, m.successors)
    if solution1 is None: print("ê¹Šì´ ìš°ì„  íƒìƒ‰ìœ¼ë¡œ ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        path1:List[MazeLocation] = node_to_path(solution1)
        m.mark(path1)
        print(m)
        m.clear(path1)
```

```python
S * * * * * * * X
              * *
  X   * * * *   *
    X *   X * * * X
  * * *
  *       X
X * * X
    * X       X
    * * * * * * * *
    X X X     X   G
```

PATHì˜ ê¸¸ì´ëŠ” 33ê°œë¡œ, ë§‰ë‹¤ë¥¸ ê¸¸ì— ë“¤ì–´ì„œì•¼ ê²½ë¡œë¥¼ ë°”ê¾¸ëŠ” ì‹ìœ¼ë¡œ ì´ë™í•˜ê¸° ë•Œë¬¸ì— ë¹„íš¨ìœ¨ì ì¸ ì›€ì§ì„ì„ ë³´ì—¬ì¤€ë‹¤. 

## ğŸ’¾ ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS)

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/maze-3.png?raw=true)

íƒìƒ‰ì˜ ê° ë°˜ë³µë§ˆë‹¤ ì¶œë°œ ì§€ì ì—ì„œ í•œ ê³„ì¸µì˜ ë…¸ë“œë¥¼ ê°€ê¹Œìš´ ì§€ì ë¶€í„° ìˆœì°¨ì ìœ¼ë¡œ íƒìƒ‰í•¨ìœ¼ë¡œì¨ í•­ìƒ ìµœë‹¨ ê²½ë¡œë¥¼  ì°¾ëŠ”ë‹¤.

ì´ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•œ ìë£Œêµ¬ì¡°ë¡œ **í**(Queue)ë¥¼ ì‚¬ìš©í•œë‹¤. 

ìŠ¤íƒê³¼ ë‹¤ë¥´ê²Œ ë¦¬ìŠ¤íŠ¸ëŠ” íì˜ ë‚´ë¶€ êµ¬ì¡°ë¡œ ì í•©í•˜ì§€ ì•Šë‹¤. ì œì¼ ì•ì˜ ì¸ë±ìŠ¤ë¥¼ ì œê±°í•˜ëŠ” dequeue ê³¼ì •ì—ì„œì˜ ì‹œê°„ë³µì¡ë„ê°€ O(N)ìœ¼ë¡œ ë¹„íš¨ìœ¨ì ì´ê¸° ë•Œë¬¸ì´ë‹¤. ë¦¬ìŠ¤íŠ¸ ëŒ€ì‹  ë±(Deque)ì„ ì‚¬ìš©í•˜ë©´ O(1)ì˜ ìƒìˆ˜ ì‹œê°„ë³µì¡ë„ë¡œ dequeueë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

```python
class Queue(Generic[T]):
    def __init__(self) -> None:
        self._container:Deque[T] = Deque()

    @property
    def empty(self) -> bool:
        return not self._container
    def push(self, item:T) -> None:
        self._container.append(item)
    def pop(self) -> T:
        return self._container.popleft()
    def __repr__(self) -> str:
        return repr(self._container)
```

ìŠ¤íƒ ëŒ€ì‹  íë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ì ë§Œ ì œì™¸í•˜ë©´ dfs ì•Œê³ ë¦¬ì¦˜ê³¼ ì „ì²´ì ì¸ êµ¬ì¡°ê°€ ê°™ë‹¤.

```python
def bfs(initial:T, 
        goal_test:Callable[[T], bool], 
        successors:Callable[[T], List[T]]) -> Optional[Node[T]]:
    frontier:Queue[Node[T]] = Queue()
    frontier.push(Node(initial, None))
    explored:Set[T] = {initial}

    while not frontier.empty:
        current_node:Node[T] = frontier.pop()
        current_state:T = current_node.state
        if goal_test(current_state):
            return current_node
        for child in successors(current_state):
            if child in explored:
                continue
            explored.add(child)
            frontier.push(Node(child, current_node))
    return None
```

**ì‹¤í–‰**

```python
if __name__ == "__main__":
    solution2:Optional[Node[MazeLocation]] = bfs(m.start, m.goal_test, m.successors)
    if solution2 is None: print("ë„ˆë¹„ ìš°ì„  íƒìƒ‰ìœ¼ë¡œ ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        path2:List[MazeLocation] = node_to_path(solution2)
        m.mark(path2)
        print(m)
        m.clear(path2)
```

```python
S               X
*
* X
*   X     X       X
*
* *       X
X *   X
  *   X       X
  * * * * * * * *
    X X X     X * G
```

PATHì˜ ê°œìˆ˜ëŠ” 17ê°œë¡œ, ê¹Šì´ ìš°ì„  íƒìƒ‰ì— ë¹„í•´ ê°œì„ ëœ ì›€ì§ì„ì„ ë³´ì—¬ì¤€ë‹¤.

## ğŸ’¾ A* ì•Œê³ ë¦¬ì¦˜

A* ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ ì•„ì´ë””ì–´ëŠ” íœ´ë¦¬ìŠ¤í‹±(heuristic)ì´ë©°, ì´ëŠ” ì¢…ë£Œ ìœ„ì¹˜ê¹Œì§€ì˜ ì´ë™ì— í•„ìš”í•œ ìµœì†Œ ë¹„ìš©ì„ ì˜ë¯¸í•œë‹¤.

ì´ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•œ ìë£Œêµ¬ì¡°ë¡œ **ìš°ì„ ìˆœìœ„ í**(PriorityQueue)ë¥¼ ì‚¬ìš©í•œë‹¤. ë‚´ë¶€ êµ¬ì¡°ë¡œëŠ” **í™**(heap)ì„ ì‚¬ìš©í•œë‹¤.

```python
class PriorityQueue(Generic[T]):
    def __init__(self) -> None:
        self._container: List[T] = []
    
    @property
    def empty(self) -> bool:
        return not self._container
    def push(self, item:T) -> None:
        heappush(self._container, item)
    def pop(self) -> T:
        return heappop(self._container)
    def __repr__(self) -> str:
        return repr(self._container)
```

A* ì•Œê³ ë¦¬ì¦˜ì—ì„œ ê° ë…¸ë“œ ì‚¬ì´ì˜ ë¹„ìš©(cost)ì€ 1ë¡œ ê³ ì •ëœë‹¤. ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ í˜„ì¬ ìœ„ì¹˜ì—ì„œ ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ë…¸ë“œê°€ ê°€ì§„ ìµœì € ë¹„ìš©ì„ ê³„ì‚°í•œ ë’¤, ë¯¸ë¡œì˜ ë§ì€ ê°€ì¥ ì ì€ íœ´ë¦¬ìŠ¤í‹±ì„ ê°€ì§„ ë…¸ë“œì˜ ìœ„ì¹˜ë¡œ ì´ë™í•œë‹¤. ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œ ì—­ì‹œ ë¹„ìš©ì´ ê³„ì‚°ë˜ë¯€ë¡œ ì¼ë¶€ ë…¸ë“œëŠ” ë‘ ë²ˆ ë°©ë¬¸ë  ìˆ˜ ìˆë‹¤.

ê° ë…¸ë“œì˜ ìµœì†Œ ë¹„ìš©ì„ valueë¡œ ì €ì¥í•˜ê¸° ìœ„í•´ Set ëŒ€ì‹  Dictë¥¼ ì‚¬ìš©í•œë‹¤.

```python
def astar(initial:T, 
          goal_test:Callable[[T], bool], 
          successors:Callable[[T], List[T]], 
          heuristic:Callable[[T], float]) -> Optional[Node[T]]:
    frontier:PriorityQueue[Node[T]] = PriorityQueue()
    frontier.push(Node(initial, None, 0.0, heuristic(initial)))
    explored:Dict[T, float] = {initial: 0.0}

    while not frontier.empty:
        current_node:Node[T] = frontier.pop()
        current_state:T = current_node.state
        if goal_test(current_state):
            return current_node
        for child in successors(current_state):
            new_cost:float = current_node.cost + 1
            if child not in explored or explored[child] > new_cost:
                explored[child] = new_cost
                frontier.push(Node(child, current_node, new_cost, heuristic(child)))
    return None
```

>*Note*
>
>astar ì•Œê³ ë¦¬ì¦˜ì€ ë§¤ê°œë³€ìˆ˜ë¡œ í•¨ìˆ˜ê°€ ì‚¬ìš©ë˜ë©°, ì´ì— ëŒ€í•œ íƒ€ì… íŒíŠ¸ë¡œ Callableì„ ì‚¬ìš©í•œë‹¤. íŒŒì´ì¬ì—ì„œëŠ” 1ê¸‰ ê°ì²´ë¡œì„œì˜ í•¨ìˆ˜ë¥¼ ì§€ì›í•˜ê¸° ë•Œë¬¸ì—, í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë„˜ê¸°ê±°ë‚˜ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤. ì´ì²˜ëŸ¼ ìˆœìˆ˜ í•¨ìˆ˜ë¥¼ ì¡°í•©í•˜ëŠ” í”„ë¡œê·¸ë˜ë° ë°©ì‹ì„ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì´ë¼ê³  í•œë‹¤.

## ë§¨í•´íŠ¼ ê±°ë¦¬

ìµœë‹¨ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ê°€ì¥ ì¼ë°˜ì ì¸ ë°©ë²•ì€ í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬ë¥¼ í™œìš©í•œ ë°©ë²•ì´ë‹¤. xì¢Œí‘œì˜ ì°¨ì´ì˜ ì œê³±ê³¼ yì¢Œí‘œì˜ ì°¨ì´ì˜ ì œê³±ì„ êµ¬í•œ ë’¤, ì´ë“¤ í•©ì˜ ì œê³±ê·¼ì´ ë°”ë¡œ ë‘ ì§€ì  ì‚¬ì´ì˜ ìµœë‹¨ê±°ë¦¬ì´ë‹¤. ì´ë ‡ê²Œ êµ¬í•œ ê±°ë¦¬ë¥¼ **ìœ í´ë¦¬ë“œ ê±°ë¦¬**ë¼ê³  í•œë‹¤.

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/distance-1.png?raw=true)

ìœ í´ë¦¬ë“œ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

```python
# ìœ í´ë¦¬ë“œ ê±°ë¦¬
def euclidean_distance(goal:MazeLocation) -> Callable[[MazeLocation], float]:
    def distance(ml:MazeLocation) -> float:
        xdist:int = ml.column - goal.column
        ydist:int = ml.row - goal.row
        return sqrt((xdist * xdist) + (ydist * ydist))
    return distance
```

í•˜ì§€ë§Œ ê²©ìë¡œ ì´ë£¨ì–´ì§„ ë¯¸ë¡œì—ì„œ ëŒ€ê°ì„  ì´ë™ì€ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©°, ì˜¤ë¡œì§€ ìƒí•˜ì¢Œìš°ë¡œë§Œ ì´ë™ë§Œ ê°€ëŠ¥í•˜ë‹¤. ì´ ë•Œ ë‘ ì§€ì  ì‚¬ì´ì˜ ìµœë‹¨ê±°ë¦¬ëŠ” íƒì‹œ ê¸°í•˜í•™ì—ì„œ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì¸ **ë§¨í•´íŠ¼ ê±°ë¦¬**ë¡œ í‘œì‹œí•  ìˆ˜ ìˆë‹¤.

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/distance-2.png?raw=true)

ë§¨í•´íŠ¼ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

```python
# ë§¨í•´íŠ¼ ê±°ë¦¬
def manhattan_distance(goal:MazeLocation) -> Callable[[MazeLocation], float]:
    def distance(ml:MazeLocation) -> float:
        xdist:int = abs(ml.column - goal.column)
        ydist:int = abs(ml.row - goal.row)
        return (xdist + ydist)
    return distance
```

A* ì•Œê³ ë¦¬ì¦˜ì€ ê¸°ì¡´ì˜ ì•Œê³ ë¦¬ì¦˜ê³¼ ë‹¤ë¥´ê²Œ ì¶”ê°€ë¡œ, íœ´ë¦¬ìŠ¤í‹±ì˜ êµ¬í˜„ì„ ìœ„í•œ ë§¨í•´íŠ¼ ê±°ë¦¬ í•¨ìˆ˜ë¥¼ ì¸ìˆ˜ë¡œ ë°›ëŠ”ë‹¤.

**ì‹¤í–‰**

```python
if __name__ == "__main__":
    distance:Callable[[MazeLocation], float] = manhattan_distance(m.goal)
    solution3:Optional[Node[MazeLocation]] = astar(m.start, m.goal_test, m.successors, distance)
    if solution3 is None: print("A* ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        path3:List[MazeLocation] = node_to_path(solution3)
        m.mark(path3)
        print(m)
```

```python
S               X
*
* X
*   X     X       X
* *
  * * * * X
X     X * * * * * *
      X       X   *
                  *
    X X X     X   G
```

PATHì˜ ê°œìˆ˜ëŠ” 17ê°œë¡œ, BFS ë°©ì‹ì˜ ê²°ê³¼ì™€ ê°™ì§€ë§Œ ëª©í‘œ ì§€ì ê¹Œì§€ ë¹„ìš©(ê±°ë¦¬) ê³„ì‚°ì„ ë°”íƒ•ìœ¼ë¡œ ì´ë™í•˜ë¯€ë¡œ ëŒ€ê°ì„ ì— ê°€ê¹Œìš´ ëª¨ì–‘ì˜ ê²½ë¡œê°€ ê·¸ë ¤ì§„ë‹¤.

## ğŸ“ ì—°ìŠµë¬¸ì œ 2-2

1. *Q*

   dfs( ), bfs( ), astar( ) í•¨ìˆ˜ì— ì¹´ìš´í„°ë¥¼ ì¶”ê°€í•˜ì—¬ ë™ì¼í•œ ë¯¸ë¡œë¥¼ ê²€ìƒ‰í•˜ëŠ” ì§€ì ì˜ ìˆ˜ë¥¼ í™•ì¸í•˜ë¼. í†µê²Œì ìœ¼ë¡œ ì˜ë¯¸ ìˆëŠ” ê²°ê³¼ë¥¼ ì–»ê¸° ìœ„í•´ 100ê°œì˜ ë¯¸ë¡œ ìƒ˜í”Œì— ëŒ€í•´ ì¡°ì‚¬í•œë‹¤.

ê²€ìƒ‰í•˜ëŠ” ì§€ì ì˜ ìˆ˜ë¥¼ í™•ì¸í•˜ê¸° ìœ„í•´ Node í´ë˜ìŠ¤ì— count ì†ì„±ì„ ì¶”ê°€í•œ ë’¤, node_to_path í´ë˜ìŠ¤ì— ì´ë¥¼ ì¶œë ¥í•˜ê¸° ìœ„í•œ ì•Œê³ ë¦¬ì¦˜ì„ ì‘ì„±í•œë‹¤.

```python
class Node(Generic[T]):
    def __init__(self, state:T, parent:Optional[Node], cost:float = 0.0, heuristic:float = 0.0):
        self.state:T = state
        self.parent:Optional[Node] = parent
        self.cost:float = cost
        self.heuristic:float = heuristic
        self.count:int = 0 #â˜…
    def __lt__(self, other:Node) -> bool:
        return (self.cost + self.heuristic) < (other.cost + other.heuristic)
```

```python
def node_to_path(node:Node[T]) -> List[T]:
    counter:int = 0 #â˜…
    path:List[T] = [node.state]
    while node.parent is not None:
        counter += node.count #â˜…
        node = node.parent
        path.append(node.state)
    path.reverse()
    return counter #â˜…
```

dfs( ), bfs( ), aster( ) í•¨ìˆ˜ì—ì„œ ìì‹ ë…¸ë“œì— ëŒ€í•œ ë¹„êµë¥¼ ìˆ˜í–‰í•  ë•Œë§ˆë‹¤ í•´ë‹¹ ë…¸ë“œì˜ countë¥¼ 1 ì¦ê°€ì‹œí‚¨ë‹¤.

```python
def dfs
    ...
        for child in successors(current_state):
            current_node.count += 1 #â˜…
            if child in explored:
    ...
```

```python
def bfs
    ...
        for child in successors(current_state):
            current_node.count += 1 #â˜…
            if child in explored:
    ...
```

```python
def astar
    ...
        for child in successors(current_state):
            new_cost:float = current_node.cost + 1
            if child not in explored or explored[child] > new_cost:
                current_node.count += 1 #â˜…
                explored[child] = new_cost
    ...
```

ì´ì œ ì„¸ ì•Œê³ ë¦¬ì¦˜ì„ ë¹„êµí•œë‹¤.

```python
from typing import Dict

if __name__ == "__main__":
    main_count:int = 0
    solutions:Dict[str, int] = {"dfs" : 0, "bfs" : 0, "astar" : 0}
    while main_count < 100:
        m:Maze = Maze()
        solution1:Optional[Node[MazeLocation]] = dfs(m.start, m.goal_test, m.successors)
        solution2:Optional[Node[MazeLocation]] = bfs(m.start, m.goal_test, m.successors)
        distance:Callable[[MazeLocation], float] = manhattan_distance(m.goal)
        solution3:Optional[Node[MazeLocation]] = astar(m.start, m.goal_test, m.successors, distance)
        if (solution1 and solution2 and solution3) is not None:
            main_count += 1
            solutions["dfs"] += node_to_path(solution1)
            solutions["bfs"] += node_to_path(solution2)
            solutions["astar"] += node_to_path(solution3)
    print(solutions)
```

```
{'dfs': 9493, 'bfs': 5149, 'astar': 2819}
```

 íƒìƒ‰ ë¶ˆê°€ëŠ¥í•œ ë¯¸ë¡œë¥¼ ì œì™¸í•œ 100ê°œì˜ ë¯¸ë¡œ ìƒ˜í”Œì— ëŒ€í•´ ì¡°ì‚¬í–ˆë‹¤. 

ì¡°ì‚¬ ê²°ê³¼ dfsì—ì„œ ê°€ì¥ ë§ì€ ì§€ì (í‰ê·  94.9)ì„ ê²€ìƒ‰í–ˆìœ¼ë©°, astarì—ì„œ ê°€ì¥ ì ì€ ì§€ì (í‰ê·  28.2)ì„ ê²€ìƒ‰í–ˆë‹¤.

---

# ì„ êµì‚¬ì™€ ì‹ì¸ì¢…

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-2-3.png?raw=true)

```python
# import
from __future__ import annotations
from typing import List, Optional
from generic_search import bfs, Node, node_to_path
```

## ê°œìš” : ë¬¸ì œ ë‚˜íƒ€ë‚´ê¸°

ì„ êµì‚¬ì™€ ì‹ì¸ì¢… ë¬¸ì œì˜ ì¡°ê±´ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

- ì„¸ ëª…ì˜ ì„ êµì‚¬ì™€ ì„¸ëª…ì˜ ì‹ì¸ì¢…ì´ ê°• ì„œìª½ì— ìˆë‹¤. 
- ì´ë“¤ì€ ë‘ ëª…ì´ íƒˆ ìˆ˜ ìˆëŠ” ë°°ë¥¼ ê°–ê³  ìˆìœ¼ë©°, ë°°ë¥¼ íƒ€ê³  ë™ìª½ìœ¼ë¡œ ì´ë™í•´ì•¼ í•œë‹¤. 
- ê°• ì–‘ìª½ì— ì„ êµì‚¬ë³´ë‹¤ ë§ì€ ì‹ì¸ì¢…ì´ ìˆë‹¤ë©´ ì‹ì¸ì¢…ì€ ì„ êµì‚¬ë¥¼ ì¡ì•„ë¨¹ëŠ”ë‹¤. 
- ê°•ì„ ê±´ë„ ë•Œ ë°°ì—ëŠ” ì ì–´ë„ í•œ ëª…ì´ íƒ‘ìŠ¹í•´ì•¼ í•œë‹¤.

ìœ„ ì¡°ê±´ì„ ë°”íƒ•ìœ¼ë¡œ ì„ êµì‚¬ì™€ ì‹ì¸ì¢…ì˜ ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” í´ë˜ìŠ¤ë¥¼ ì‘ì„±í•˜ê³ , ì´ë¥¼ í†µí•´ ë¬¸ì œ í•´ê²°ì„ ì‹œë„í•  ìˆ˜ ìˆë‹¤.

```python
MAX_NUM:int = 3

class MCState:
    def __init__(self, missionaries:int, cannibals:int, boat:bool) -> None:
        self.wm:int = missionaries
        self.wc:int = cannibals
        self.em:int = MAX_NUM - self.wm
        self.ec:int = MAX_NUM - self.wc
        self.boat:bool = boat

    def __repr__(self) -> str:
        return (f"ì„œìª½ ê°•ë‘‘ì—ëŠ” {self.wm}ëª…ì˜ ì„ êµì‚¬ì™€ {self.wc}ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.\n"
                f"ë™ìª½ ê°•ë‘‘ì—ëŠ” {self.em}ëª…ì˜ ì„ êµì‚¬ì™€ {self.ec}ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.\n"
                f"ë°°ëŠ” {'ì„œ' if self.boat else 'ë™'}ìª½ì— ìˆë‹¤.")
    
    def goal_test(self) -> bool:
        return self.is_legal and self.em == MAX_NUM and self.ec == MAX_NUM

    @property
    def is_legal(self) -> bool:
        if self.wm < self.wc and self.wm > 0:
            return False
        if self.em < self.ec and self.em > 0:
            return False
        return True

    def successors(self) -> List[MCState]:
        sucs:List[MCState] = []
        if self.boat:   # ì„œìª½ ê°•ë‘‘ì— ìˆëŠ” ë°°
            if self.wm > 1:
                sucs.append(MCState(self.wm - 2, self.wc, not self.boat))
            if self.wm > 0:
                sucs.append(MCState(self.wm - 1, self.wc, not self.boat))
            if self.wc > 1:
                sucs.append(MCState(self.wm, self.wc - 2, not self.boat))
            if self.wc > 0:
                sucs.append(MCState(self.wm, self.wc - 1, not self.boat))
            if (self.wc > 0) and (self.wm > 0):
                sucs.append(MCState(self.wm - 1, self.wc - 1, not self.boat))
        else:           # ë™ìª½ ê°•ë‘‘ì— ìˆëŠ” ë°°
            if self.em > 1:
                sucs.append(MCState(self.wm + 2, self.wc, not self.boat))
            if self.em > 0:
                sucs.append(MCState(self.wm + 1, self.wc, not self.boat))
            if self.ec > 1:
                sucs.append(MCState(self.wm, self.wc + 2, not self.boat))
            if self.ec > 0:
                sucs.append(MCState(self.wm, self.wc + 1, not self.boat))
            if (self.ec > 0) and (self.em > 0):
                sucs.append(MCState(self.wm + 1, self.wc + 1, not self.boat))
        return [x for x in sucs if x.is_legal]
```

- `__init__`: ì‚¬ëŒ ìˆ˜ì™€ ë³´íŠ¸ì˜ ìœ„ì¹˜ë¥¼ ì„¤ì •í•œë‹¤.
- `__repr__`: ê°• ì–‘ìª½ì˜ ì‚¬ëŒ ìˆ˜ë¥¼ ì¶œë ¥í•œë‹¤.
- `goal_test`: ëª¨ë“  ì„ êµì‚¬ì™€ ì‹ì¸ì¢…ì´ ë¬´ì‚¬íˆ ë™ìª½ìœ¼ë¡œ ì´ë™í–ˆëŠ”ì§€ í™•ì¸í•œë‹¤.
- `is_legal`: ê°• ì–´ëŠ ìª½ì´ë“  ì‹ì¸ì¢…ì˜ ìˆ˜ê°€ ì„ êµì‚¬ì˜ ìˆ˜ë³´ë‹¤ ë§ì„ ìˆ˜ ì—†ë„ë¡ ì œí•œí•œë‹¤.
- `successors`: ë°°ì— íƒ‘ìŠ¹ ê°€ëŠ¥í•œ ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜í•œë‹¤.

goal_testì™€ successorsì˜ ê¸°ëŠ¥ì´ ìµìˆ™í•˜ë‹¤. ìš°ë¦¬ëŠ” ì´ë¯¸ ë¯¸ë¡œ ì°¾ê¸° ì•Œê³ ë¦¬ì¦˜ì˜ Maze í´ë˜ìŠ¤ì—ì„œë„ ë™ì¼í•œ ë©”ì„œë“œë¥¼ êµ¬í˜„í•œ ì  ìˆë‹¤. ë‘ ë©”ì„œë“œëŠ” ì•ì„œ êµ¬í˜„í•œ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ í•¨ìˆ˜ì˜ ì¸ìˆ˜ë¡œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆë‹¤. ë‹¤ì‹œ ë§í•´ì„œ ì„ êµì‚¬ì™€ ì‹ì¸ì¢… ë¬¸ì œ ì—­ì‹œ ì¼ë°˜í™”ë¥¼ ì ìš©í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.

## ì œë„¤ë¦­ í”„ë¡œê·¸ë˜ë°ì˜ í˜

ë¶ˆí•„ìš”í•œ ì´ë™ì´ ë°œìƒí•˜ëŠ” ê¹Šì´ ìš°ì„  íƒìƒ‰ì´ë‚˜ íœ´ë¦¬ìŠ¤í‹±ì„ ìš”êµ¬í•˜ëŠ” A* ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ëŠ” ëŒ€ì‹ , **ë„ˆë¹„ ìš°ì„  íƒìƒ‰**ì„ ì‚¬ìš©í•´ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.

`display_solution` ë©”ì„œë“œëŠ” ì†”ë£¨ì…˜ ê²½ë¡œë¥¼ ì¶œë ¥í•˜ë©°, ë¯¸ë¡œ ì°¾ê¸° ì•Œê³ ë¦¬ì¦˜ì˜ Maze í´ë˜ìŠ¤ì—ì„œ êµ¬í˜„í•œ mark ë©”ì„œë“œì™€ ìœ ì‚¬í•œ ê¸°ëŠ¥ì„ í•œë‹¤.

```python
def display_solution(path:List[MCState]):
    if len(path) == 0:
        return
    old_state:MCState = path[0]
    print(old_state)
    for current_state in path[1:]:
        if current_state.boat:
            print("{}ëª…ì˜ ì„ êµì‚¬ì™€ {}ëª…ì˜ ì‹ì¸ì¢…ì´ ë™ìª½ ê°•ë‘‘ì—ì„œ ì„œìª½ ê°•ë‘‘ìœ¼ë¡œ ê°”ë‹¤.\n"
                  .format(old_state.em - current_state.em, old_state.ec - current_state.ec))
        else:
            print("{}ëª…ì˜ ì„ êµì‚¬ì™€ {}ëª…ì˜ ì‹ì¸ì¢…ì´ ë™ìª½ ê°•ë‘‘ì—ì„œ ì„œìª½ ê°•ë‘‘ìœ¼ë¡œ ê°”ë‹¤.\n"
                  .format(old_state.wm - current_state.wm, old_state.wc - current_state.wc))
        print(current_state)
        old_state = current_state
```

ì‚¬ìš©ì ì§€ì • íƒ€ì… Tì—ëŠ” MCStateë¥¼, ë‚˜ë¨¸ì§€ ë‘ ì¸ìˆ˜ë¡œëŠ” MCStateì˜ í´ë˜ìŠ¤ ë©”ì„œë“œì¸ goal_testì™€ successorsë¥¼ ì§€ì •í•œë‹¤.

**ì‹¤í–‰**

```python
if __name__ == "__main__":
    start:MCState = MCState(MAX_NUM, MAX_NUM, True)
    solution:Optional[Node[MCState]] = bfs(start, MCState.goal_test, MCState.successors)
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    else:
        path:List[MCState] = node_to_path(solution)
        display_solution(path)
```

```
ì„œìª½ ê°•ë‘‘ì—ëŠ” 3ëª…ì˜ ì„ êµì‚¬ì™€ 3ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë™ìª½ ê°•ë‘‘ì—ëŠ” 0ëª…ì˜ ì„ êµì‚¬ì™€ 0ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë°°ëŠ” ì„œìª½ì— ìˆë‹¤.
0ëª…ì˜ ì„ êµì‚¬ì™€ 2ëª…ì˜ ì‹ì¸ì¢…ì´ ë™ìª½ ê°•ë‘‘ì—ì„œ ì„œìª½ ê°•ë‘‘ìœ¼ë¡œ ê°”ë‹¤.

...

ì„œìª½ ê°•ë‘‘ì—ëŠ” 0ëª…ì˜ ì„ êµì‚¬ì™€ 0ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë™ìª½ ê°•ë‘‘ì—ëŠ” 3ëª…ì˜ ì„ êµì‚¬ì™€ 3ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë°°ëŠ” ë™ìª½ì— ìˆë‹¤.
```

## ğŸ“ ì—°ìŠµë¬¸ì œ 2-3

1. *Q*

   ì„ êµì‚¬ì™€ ì‹ì¸ì¢… ìˆ˜ë¥¼ ë³€í˜•í•˜ì—¬ ë¬¸ì œë¥¼ í’€ì–´ë³´ë¼.

ì„ êµì‚¬ì™€ ì‹ì¸ì¢…ì˜ ìˆ˜ê°€ ë‹¤ë¥¸ ê²½ìš°ì—ë„ ê°•ì„ ê±´ë„ˆëŠ” ë°©ë²•ì„ ì¶œë ¥í•´ì•¼ í•œë‹¤.

```python
MISS:List[int] = []
CANN:List[int] = []
```

ë¦¬ìŠ¤íŠ¸ `MISS`ì™€ `CANN`ëŠ” MCState ê°ì²´ê°€ ìƒì„±ë  ë•Œë§ˆë‹¤ ë§¤ê°œë³€ìˆ˜ë¡œ ë“¤ì–´ì˜¨ ì„ êµì‚¬ì™€ ì‹ì¸ì¢…ì˜ ìˆ˜ë¥¼ ì €ì¥í•œë‹¤. ë¦¬ìŠ¤íŠ¸ì˜ 0ë²ˆ ì¸ë±ìŠ¤ëŠ” ì²˜ìŒ ì‹œì‘í•  ë•Œ ì„œìª½ ê°•ë‘‘ì— ì¡´ì¬í•˜ëŠ” ì„ êµì‚¬ì™€ ì‹ì¸ì¢…ì˜ ìˆ˜ê°€ ì €ì¥ëœë‹¤. ì´í›„ ê¸°ì¡´ ì•Œê³ ë¦¬ì¦˜ì˜ MAX_NUM ëŒ€ì‹  ë¦¬ìŠ¤íŠ¸ì˜ 0ë²ˆ ì¸ë±ìŠ¤ì˜ í•­ëª©ì„ ì‚¬ìš©í•œë‹¤.

MCState í´ë˜ìŠ¤ì˜ ë‚´ìš©ì„ ìˆ˜ì •í•œë‹¤.

```python
def __init__(self, missionaries:int, cannibals:int, boat:bool) -> None:
        MISS.append(missionaries)
        CANN.append(cannibals)
        self.wm:int = missionaries
        self.wc:int = cannibals
        self.em:int = MISS[0] - self.wm
        self.ec:int = CANN[0] - self.wc
        self.boat:bool = boat
```

```python
def goal_test(self) -> bool:
    return self.is_legal and self.em == MISS[0] and self.ec == CANN[0]
```

4ëª…ì˜ ì„ êµì‚¬ì™€ 3ëª…ì˜ ì‹ì¸ì¢…ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš° ê·¸ì— ë§ê²Œ ì¸ìë¥¼ ìˆ˜ì •í•œ ìˆ˜ ì‹¤í–‰í•œë‹¤.

**ì‹¤í–‰**

```python
if __name__ == "__main__":
    start:MCState = MCState(4, 3, True)
    solution:Optional[Node[MCState]] = bfs(start, MCState.goal_test, MCState.successors)
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    else:
        path:List[MCState] = node_to_path(solution)
        display_solution(path)
```

```
ì„œìª½ ê°•ë‘‘ì—ëŠ” 4ëª…ì˜ ì„ êµì‚¬ì™€ 3ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë™ìª½ ê°•ë‘‘ì—ëŠ” 0ëª…ì˜ ì„ êµì‚¬ì™€ 0ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë°°ëŠ” ì„œìª½ì— ìˆë‹¤.
0ëª…ì˜ ì„ êµì‚¬ì™€ 2ëª…ì˜ ì‹ì¸ì¢…ì´ ë™ìª½ ê°•ë‘‘ì—ì„œ ì„œìª½ ê°•ë‘‘ìœ¼ë¡œ ê°”ë‹¤.

...

ì„œìª½ ê°•ë‘‘ì—ëŠ” 0ëª…ì˜ ì„ êµì‚¬ì™€ 0ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë™ìª½ ê°•ë‘‘ì—ëŠ” 4ëª…ì˜ ì„ êµì‚¬ì™€ 3ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë°°ëŠ” ë™ìª½ì— ìˆë‹¤.
```

