---
layout: post
meta: "Week-8"
title: "Week-8: ì ëŒ€ì  íƒìƒ‰"
categories: Classic
tags: Python
mathjax: true
---

* content
{:toc}
# ê°œìš”







---

# ì œë„¤ë¦­

## ë³´ë“œê²Œì„ êµ¬ì„± ìš”ì†Œ

<u>board.py</u>

```python
# ë³´ë“œê²Œì„ êµ¬ì„± ìš”ì†Œ

from __future__ import annotations
from typing import NewType, List
from abc import ABC, abstractmethod

# ê²Œì„ì—ì„œì˜ ì´ë™ì„ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ íƒ€ì…
# íƒ€ì… ì—˜ë¦¬ì–´ìŠ¤ì˜ ë‘ íƒ€ì…ì€ ë™ë“±í•˜ì§€ë§Œ, NewTypeì€ í•œ íƒ€ì…ì„ ë‹¤ë¥¸ íƒ€ì…ì˜ ì„œë¸Œ íƒ€ì…ìœ¼ë¡œ ì„ ì–¸í•œë‹¤.
Move = NewType("Move", int)


class Piece:
    @property
    def opposite(self) -> Piece:
        raise NotImplementedError("ì„œë¸Œí´ë˜ìŠ¤ë¡œ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.")


class Board(ABC):
    # ëˆ„êµ¬ ì°¨ë¡€ì¸ê°€?
    @property
    @abstractmethod
    def turn(self) -> Piece:
        ...

    # í˜„ì¬ ìœ„ì¹˜ì—ì„œ ìƒˆ ìœ„ì¹˜ë¡œ ì´ë™í•œë‹¤.
    @abstractmethod
    def move(self, location:Move) -> Board:
        ...

    # ë§ì€ í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì–´ë””ë¡œ ì›€ì§ì¼ ìˆ˜ ìˆëŠ”ê°€?
    @property
    @abstractmethod
    def legal_moves(self) -> List[Move]:
        ...

    # ì´ê²¼ëŠ”ê°€?
    @property
    @abstractmethod
    def is_win(self) -> bool:
        ...

    # ë¬´ìŠ¹ë¶€ì¸ê°€?
    @property
    def is_draw(self) -> bool:
        return (not self.is_win) and (len(self.legal_moves) == 0)

    # í”Œë ˆì´ì–´ì˜ ë§ ìœ„ì¹˜ë¥¼ í‰ê°€í•˜ì—¬ ì–´ëŠ ìª½ì´ ìœ ë¦¬í•œì§€ í™•ì¸í•œë‹¤.
    @abstractmethod
    def evaluate(self, player:Piece) -> float:
        ...
```



## ìµœì†ŒìµœëŒ€ ì•Œê³ ë¦¬ì¦˜

```python
# ìµœì†ŒìµœëŒ€ ì•Œê³ ë¦¬ì¦˜

from __future__ import annotations
from board import Piece, Board, Move


def minmax(board:Board, 
           maximizing:bool, 
           original_player:Piece, 
           max_depth:int = 8) -> float:
    # ê¸°ì € ì¡°ê±´
    if board.is_win or board.is_draw or max_depth == 0:
        return board.evaluate(original_player)

    # ì¬ê·€ ì¡°ê±´
    # ìµœëŒ€í™”: ê°€ì¥ ë†’ì€ í‰ê°€ë¥¼ ë°›ëŠ” ì›€ì§ì„ì„ ì°¾ëŠ”ë‹¤.
    if maximizing:  
        best_eval:float = float("-inf") # ê°€ì¥ ë‚®ì€ ì ìˆ˜ë¡œ ì‹œì‘
        for move in board.legal_moves:
            result:float = minmax(board.move(move), 
                                  False, 
                                  original_player, 
                                  max_depth - 1)
            best_eval = max(result, best_eval)
        return best_eval
    # ìµœì†Œí™”: ê°€ì¥ ë‚®ì€ í‰ê°€ë¥¼ ë°›ëŠ” ì›€ì§ì„ì„ ì°¾ëŠ”ë‹¤.
    else:
        worst_eval:float = float("inf") # ê°€ì¥ ë†’ì€ ì ìˆ˜ë¡œ ì‹œì‘
        for move in board.legal_moves:
            result = minmax(board.move(move), 
                            True, 
                            original_player, 
                            max_depth - 1)
            worst_eval = min(result, worst_eval)
        return worst_eval


def alphabeta(board:Board, 
              maximizing:bool, 
              original_player:Piece, 
              max_depth:int = 8, 
              alpha:float = float("-inf"), 
              beta:float = float("inf")) -> float:
    if board.is_win or board.is_draw or max_depth == 0:
        return board.evaluate(original_player)

    if maximizing:
        for move in board.legal_moves:
            result: float = alphabeta(board.move(move), False, original_player, max_depth - 1, alpha, beta)
            alpha = max(result, alpha)
            if beta <= alpha:
                break
        return alpha
    else:
        for move in board.legal_moves:
            result = alphabeta(board.move(move), True, original_player, max_depth - 1, alpha, beta)
            beta = min(result, beta)
            if beta <= alpha:
                break
        return beta


def find_best_move(board:Board, max_depth:int = 8) -> Move:
    best_eval:float = float("-inf")
    best_move:Move = Move(-1)
    for move in board.legal_moves:
        result:float = alphabeta(board.move(move), False, board.turn, max_depth)
        if result > best_eval:
            best_eval = result
            best_move = move
    return best_move
```





---

# ì ìš©: í‹±íƒí† 

```python
# í‹±íƒí†  ìƒíƒœ ê´€ë¦¬

from __future__ import annotations
from typing import List
from enum import Enum
from board import Piece, Board, Move


class TTTPiece(Piece, Enum):
    X = "X"
    O = "O"
    E = " "

    @property
    def opposite(self) -> TTTPiece:
        if self == TTTPiece.X:
            return TTTPiece.O
        elif self == TTTPiece.O:
            return TTTPiece.X
        else:
            return TTTPiece.E

    def __str__(self) -> str:   # repr ì‚¬ìš© X
        return self.value


class TTTBoard(Board):
    def __init__(self, 
                 position:List[TTTPiece] = [TTTPiece.E] * 9,
                 turn:TTTPiece = TTTPiece.X) -> None:
        self.position:List[TTTPiece] = position
        self._turn:TTTPiece = turn

    @property
    def turn(self) -> Piece:
        return self._turn

    def move(self, location:Move) -> Board:
        temp_position:List[TTTPiece] = self.position.copy()
        temp_position[location] = self._turn
        return TTTBoard(temp_position, self._turn.opposite)

    @property
    def legal_moves(self) -> List[Move]:
        return [Move(l) for l in range(len(self.position)) if self.position[l] == TTTPiece.E]

    #   0 | 1 | 2
    # ----+---+----
    #   3 | 4 | 5
    # ----+---+----
    #   6 | 7 | 8
      
    @property
    def is_win(self) -> bool:
        return self.position[0] == self.position[1] and self.position[0] == self.position[2] and self.position[0] != TTTPiece.E or\
               self.position[3] == self.position[4] and self.position[3] == self.position[5] and self.position[3] != TTTPiece.E or\
               self.position[6] == self.position[7] and self.position[6] == self.position[8] and self.position[6] != TTTPiece.E or\
               self.position[0] == self.position[3] and self.position[0] == self.position[6] and self.position[0] != TTTPiece.E or\
               self.position[1] == self.position[4] and self.position[1] == self.position[7] and self.position[1] != TTTPiece.E or\
               self.position[2] == self.position[5] and self.position[2] == self.position[8] and self.position[2] != TTTPiece.E or\
               self.position[0] == self.position[4] and self.position[0] == self.position[8] and self.position[0] != TTTPiece.E or\
               self.position[2] == self.position[4] and self.position[2] == self.position[6] and self.position[2] != TTTPiece.E

    def evaluate(self, player:Piece) -> float:
        if self.is_win and self.turn == player:
            return -1
        elif self.is_win and self.turn != player:
            return 1
        else:
            return 0

    def __repr__(self) -> str:
        return f"""
        {self.position[0]}|{self.position[1]}|{self.position[2]}
        -----
        {self.position[3]}|{self.position[4]}|{self.position[5]}
        -----
        {self.position[6]}|{self.position[7]}|{self.position[8]}
        """
```



```python
from minmax import find_best_move
from tictactoe import TTTBoard
from board import Move, Board

board:Board = TTTBoard()
def get_player_move() -> Move:
    player_move:Move = Move(-1)
    while player_move not in board.legal_moves:
        play:int = int(input("ì´ë™í•  ìœ„ì¹˜ë¥¼ ì…ë ¥í•˜ì„¸ìš” (0-8): "))
        player_move = Move(play)
    return player_move

if __name__ == "__main__":
    while True:
        human_move:Move = get_player_move()
        board = board.move(human_move)
        if board.is_win:
            print("ë‹¹ì‹ ì´ ì´ê²¼ìŠµë‹ˆë‹¤!")
            break
        elif board.is_draw:
            print("ë¹„ê²¼ìŠµë‹ˆë‹¤!")
            break
        computer_move:Move = find_best_move(board)
        print(f"ì»´í“¨í„°ê°€ {computer_move}(ìœ¼)ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.")
        board = board.move(computer_move)
        print(board)
        if board.is_win:
            print("ì»´í“¨í„°ê°€ ì´ê²¼ìŠµë‹ˆë‹¤!")
            break
        elif board.is_draw:
            print("ë¹„ê²¼ìŠµë‹ˆë‹¤!")
            break
```



---

# ì ìš©: ì»¤ë„¥íŠ¸í¬











---

# ì—°ìŠµë¬¸ì œ

## ğŸ“ 8-1

1. *Practice question*

   í‹±íƒí† ì— ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•˜ì—¬ **legal_moves**, **is_win**, **is_draw** ì†ì„±ì´ ì˜ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•˜ë¼.



## ğŸ“ 8-2

1. *Practice question*

   ì»¤ë„¥íŠ¸í¬ì— ëŒ€í•œ ìµœì†ŒìµœëŒ€ ì•Œê³ ë¦¬ì¦˜ì˜ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ë¼.



## ğŸ“ 8-3

1. *Practice question*

   **tictactoe_ai.py**ì™€ **connectfour_ai.py**ì˜ ì½”ë“œëŠ” ê±°ì˜ ë¹„ìŠ·í•˜ë‹¤. ì´ ë‘ ì½”ë“œë¥¼ ë‘ ê²Œì„ ëª¨ë‘ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ë‘ ë©”ì„œë“œë¡œ ì‘ì„±í•˜ì—¬ ë¦¬íŒ©í† ë§í•˜ë¼.



## ğŸ“ 8-4

1. *Practice question*

   ì»´í“¨í„° í”Œë ˆì´ì–´ê°€ ìì‹ ê³¼ ê²Œì„í•  ìˆ˜ ìˆë„ë¡ **connectfour_ai.py** ì½”ë“œë¥¼ ë³€ê²½í•´ë³´ì. ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ì™€ ë‘ ë²ˆì§¸ í”Œë ˆì´ì–´ ì¤‘ ëˆ„ê°€ ë” ë§ì´ ì´ê¸°ëŠ”ê°€? ë§¤ë²ˆ ê°™ì€ ì„ ìˆ˜ê°€ ì´ê¸°ëŠ”ê°€?



## ğŸ“ 8-5

1. *Practice question*

   **connectfour_ai.py**ì—ì„œ í‰ê°€ ë°©ë²•ì„ ìµœì í™”í•˜ì—¬ ê°™ì€ ì‹œê°„ ë‚´ì— ë” ë†’ì€ íƒìƒ‰ ê¸¸ì´ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ë°©ë²•ì„ ì°¾ì•„ë³´ë¼(ê¸°ì¡´ ì½”ë“œë¥¼ í”„ë¡œíŒŒì¼ë§í•˜ê±°ë‚˜ ë‹¤ë¥¸ ë°©ë²•ì„ ì‚¬ìš©í•´ë„ ì¢‹ë‹¤).



## ğŸ“ 8-6

1. *Practice question*

   í•©ë²•ì ì¸ ì²´ìŠ¤ ì´ë™ ìƒì„± ë° ì²´ìŠ¤ ê²Œì„ ìƒíƒœ ìœ ì§€ ê´€ë¦¬ë¥¼ ìœ„í•´ ì´ ì¥ì—ì„œ ê°œë°œí•œ **alphabeta()** í•¨ìˆ˜ë¥¼ íŒŒì´ì¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ì—¬ ì²´ìŠ¤ AIë¥¼ ê°œë°œí•˜ë¼.

â€‹	
