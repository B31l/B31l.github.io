---
layout: post
title: "Week-3: ì œì•½ ì¶©ì¡± ë¬¸ì œ"
meta: "Week-3"
categories: Classic
tags: Python
---

* content
{:toc}
# ì œì•½ ì¶©ì¡± ë¬¸ì œ

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-3.png?raw=true)

```python
from typing import Generic, TypeVar, Dict, List, Optional
from abc import ABC, abstractmethod
```

```python
V = TypeVar('V') # ë³€ìˆ˜(Variable) íƒ€ì…
D = TypeVar('D') # ë„ë©”ì¸(Domain) íƒ€ì…
```



## Constraint

```python
class Constraint(Generic[V, D], ABC):
    """
    * ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤
    ì œì•½ ì¡°ê±´ ë³€ìˆ˜  : Constraint.variables
    """
    def __init__(self, variables:List[V]) -> None:
        self.variables = variables                              # variables     : ì œì•½ ì¡°ê±´ ë³€ìˆ˜

    # ì œì•½ ì¡°ê±´ì´ ì¶©ì¡±ë˜ì—ˆëŠ”ì§€ ê²€ì‚¬í•œë‹¤.
    @abstractmethod
    def satisfied(self, assignment:Dict[V, D]) -> bool:
        ...
```



## CSP

- ë³€ìˆ˜
- ë„ë©”ì¸
- ì œì•½ ì¡°ê±´

```python
class CSP(Generic[V, D]):
    """
    * í•µì‹¬ í´ë˜ìŠ¤
    ë³€ìˆ˜            : self.variables
    ë„ë©”ì¸          : self.domains
    ì œì•½ ì¡°ê±´       : self.constraints
    """
    def __init__(self, variables:List[V], domains:Dict[V, List[D]]) -> None:

        # 1. ë³€ìˆ˜ ë° ë„ë©”ì¸ì„ ì €ì¥í•œë‹¤.
        self.variables:List[V] = variables                      # variables     : List[V]
        self.domains:Dict[V, List[D]] = domains                 # domains       : { V : List[D] }

        # 2. ì œì•½ ì¡°ê±´ ì»¬ë ‰ì…˜ì„ ì´ˆê¸°í™”í•œë‹¤.
        self.constraints:Dict[V, List[Constraint[V, D]]] = {}   # constraints   : { V : List[Constraint[V, D]] }
        for variable in self.variables:                         # {}
            self.constraints[variable] = []                     # { ë³€ìˆ˜1 : [], ë³€ìˆ˜2: [], ... }
            if variable not in self.domains:
                raise LookupError("ëª¨ë“  ë³€ìˆ˜ì— ë„ë©”ì¸ì´ í• ë‹¹ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.")

    # 3. ì œì•½ ì¡°ê±´ì„ ì €ì¥í•œë‹¤.
    def add_constraint(self, constraint:Constraint[V, D]) -> None:
        for variable in constraint.variables:                   
            if variable not in self.variables:
                raise LookupError("ì œì•½ ì¡°ê±´ ë³€ìˆ˜ê°€ ì•„ë‹™ë‹ˆë‹¤.")
            else:
                self.constraints[variable].append(constraint)   # { ë³€ìˆ˜1 : [ì œì•½ ì¡°ê±´1, ì œì•½ ì¡°ê±´ 2, ...], ë³€ìˆ˜ 2: [], ... }

    # ì£¼ì–´ì§„ ë³€ìˆ˜ì˜ ëª¨ë“  ì œì•½ ì¡°ê±´ì„ ê²€ì‚¬í•˜ë©° assignment ê°’ì´ ì¼ê´€ì ì¸ì§€ í™•ì¸í•œë‹¤.
    def consistent(self, variable:V, assignment:Dict[V, D]) -> bool:
        for constraint in self.constraints[variable]:
            if not constraint.satisfied(assignment):
                return False    # ì œì•½ ì¡°ê±´ì„ ì¶©ì¡±í•˜ì§€ ì•ŠìŒ    -> False
            return True         # í• ë‹¹ì´ ëª¨ë“  ì œì•½ ì¡°ê±´ì„ ì¶©ì¡± -> True

    # ë°±íŠ¸ë˜í‚¹(backtracking): ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)ê³¼ ìœ ì‚¬í•œ ë°©ì‹
    def backgracking_search(self, assignment:Dict[V, D] = {}) -> Optional[Dict[V, D]]:

        # assignmentëŠ” ëª¨ë“  ë³€ìˆ˜ê°€ í• ë‹¹ë  ë•Œ ì™„ë£Œëœë‹¤(ê¸°ì € ì¡°ê±´).
        if len(assignment) == len(self.variables):
            return assignment

        # í• ë‹¹ë˜ì§€ ì•Šì€ ëª¨ë“  ë³€ìˆ˜ë¥¼ ê°€ì ¸ì˜¨ë‹¤.
        unsigned:List[V] = [v for v in self.variables if v not in assignment]
        
        # í• ë‹¹ë˜ì§€ ì•Šì€ ì²« ë²ˆì§¸ ë³€ìˆ˜ì˜ ê°€ëŠ¥í•œ ëª¨ë“  ë„ë©”ì¸ ê°’ì„ ê°€ì ¸ì˜¨ë‹¤.
        first:V = unsigned[0]
        for value in self.domains[first]:
            local_assignment = assignment.copy()
            local_assignment[first] = value
            
            # local_assignment ê°’ì´ ì¼ì¹˜í•˜ë©´ ì¬ê·€ í˜¸ì¶œí•œë‹¤.
            if self.consistent(first, local_assignment):
                result:Optional[Dict[V, D]] = self.backgracking_search(local_assignment)
                if result is not None:
                    return result   # ì†”ë£¨ì…˜ ë°˜í™˜
        return None                 # ì†”ë£¨ì…˜ ì—†ìŒ
```



---

# 1. í˜¸ì£¼ ì§€ë„ ìƒ‰ì¹  ë¬¸ì œ

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional

class MapColoringConstraint(Constraint[str, str]):
    def __init__(self, place1:str, place2:str) -> None:
        super().__init__([place1, place2])
        self.place1:str = place1
        self.place2:str = place2

    def satisfied(self, assignment:Dict[str, str]) -> bool:
        if self.place1 not in assignment or self.place2 not in assignment:
            return True
        return assignment[self.place1] != assignment[self.place2]
```

```python
if __name__ == "__main__":
    variables:List[str] = ["ì›¨ìŠ¤í„´ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„", 
                           "ë…¸ë˜ ì¤€ì£¼", 
                           "ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„",
                           "í€¸ì¦ëœë“œ",
                           "ë‰´ì‚¬ìš°ìŠ¤ì›¨ì¼ìŠ¤",
                           "ë¹…í† ë¦¬ì•„",
                           "íƒœì¦ˆë©”ì´ë‹ˆì•„"]
    domains:Dict[str, List[str]] = {}
    for variable in variables:
        domains[variable] = ["ë¹¨ê°•", "ì´ˆë¡", "íŒŒë‘"]
    csp:CSP[str, str] = CSP(variables, domains)
    csp.add_constraint(MapColoringConstraint("ì›¨ìŠ¤í„´ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„", "ë…¸ë˜ ì¤€ì£¼"))
    csp.add_constraint(MapColoringConstraint("ì›¨ìŠ¤í„´ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„", "ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„"))
    csp.add_constraint(MapColoringConstraint("ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„", "ë…¸ë˜ ì¤€ì£¼"))
    csp.add_constraint(MapColoringConstraint("í€¸ì¦ëœë“œ"             , "ë…¸ë˜ ì¤€ì£¼"))
    csp.add_constraint(MapColoringConstraint("í€¸ì¦ëœë“œ"             , "ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„"))
    csp.add_constraint(MapColoringConstraint("í€¸ì¦ëœë“œ"             , "ë‰´ì‚¬ìš°ìŠ¤ì›¨ì¼ìŠ¤"))
    csp.add_constraint(MapColoringConstraint("ë‰´ì‚¬ìš°ìŠ¤ì›¨ì¼ìŠ¤"       , "ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„"))
    csp.add_constraint(MapColoringConstraint("ë¹…í† ë¦¬ì•„"             , "ì‚¬ìš°ìŠ¤ ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„"))
    csp.add_constraint(MapColoringConstraint("ë¹…í† ë¦¬ì•„"             , "ë‰´ì‚¬ìš°ìŠ¤ì›¨ì¼ìŠ¤"))
    csp.add_constraint(MapColoringConstraint("ë¹…í† ë¦¬ì•„"             , "íƒœì¦ˆë©”ì´ë‹ˆì•„"))
    
    solution:Optional[Dict[str, str]] = csp.backgracking_search()
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        print(solution)
```

---



# 2. ì—¬ëŸ í€¸ ë¬¸ì œ

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional

class QueensConstraint(Constraint[int, int]):
    def __init__(self, columns:List[int]) -> None:
        super().__init__(columns)
        self.columns:List[int] = columns

    def satisfied(self, assignment:Dict[int, int]) -> bool:
        for q1c, q1r in assignment.items():
            for q2c in range(q1c + 1, len(self.columns) + 1):
                if q2c in assignment:
                    q2r:int = assignment[q2c]
                    if q1r == q2r:                          # 2. ê°™ì€ í–‰?
                        return False
                    if abs(q1r - q2r) == abs(q1c - q2c):    # 3. ê°™ì€ ëŒ€ê°ì„ ?
                        return False
        return True
```

```python
if __name__ == "__main__":
    columns:List[int] = [1, 2, 3, 4, 5, 6, 7, 8]    # V
    rows:Dict[int, List[int]] = {}                  # D
    for column in columns:
        rows[column] = [1, 2, 3, 4, 5, 6, 7, 8]
    csp:CSP[int, int] = CSP(columns, rows)
    csp.add_constraint(QueensConstraint(columns))
    solution:Optional[Dict[int, int]] = csp.backgracking_search()
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        print(solution)
```



---

# 3. SEND+MORE=MONEY

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional

class SendMoreMoneyConstraint(Constraint[str, int]):
    def __init__(self, letters:List[str]) -> None:
        super().__init__(letters)
        self.letters:List[str] = letters

    def satisfied(self, assignment:Dict[str, int]) -> bool:
        if len(set(assignment.values())) < len(assignment):
            return False
    
        if len(assignment) == len(self.letters):
            s:int = assignment["S"]
            e:int = assignment["E"]
            n:int = assignment["N"]
            d:int = assignment["D"]
            m:int = assignment["M"]
            o:int = assignment["O"]
            r:int = assignment["R"]
            y:int = assignment["Y"]
            send:int = s * 1000 + e * 100 + n * 10 + d
            more:int = m * 1000 + o * 100 + r * 10 + e
            money:int = m * 10000 + o * 1000 + n * 100 + e * 10 + y
            return send + more == money
        return True
```

```python
if __name__ == "__main__":
    letters:List[str] = ["S", "E", "N", "D", "M", "O", "R", "Y"]
    possible_digits:Dict[str, List[int]] = {}
    for letter in letters:
        possible_digits[letter] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    possible_digits["M"] = [1]
    csp:CSP[str, int] = CSP(letters, possible_digits)
    csp.add_constraint(SendMoreMoneyConstraint(letters))
    solution:Optional[Dict[str, int]] = csp.backgracking_search()
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        print(solution)
```



---

# 4. ë‹¨ì–´ ê²€ìƒ‰

## ê°œìš”

```python
from typing import NamedTuple, Dict, List, Optional
from random import choice
from string import ascii_uppercase
from csp import Constraint, CSP

Grid = List[List[str]]


class GridLocation(NamedTuple):
    row:int
    column:int
```

```python
def generate_grid(rows:int, columns:int) -> Grid:
    return [[choice(ascii_uppercase) for c in range(columns)] for r in range(rows)]

def display_grid(grid:Grid) -> None:
    for row in grid:
        print("".join(row))
```

```python
def generate_domain(word:str, grid:Grid) -> List[List[GridLocation]]:
    domain:List[List[GridLocation]] = []
    height:int = len(grid)
    width:int = len(grid[0])
    length:int = len(word)
    for row in range(height):
        for col in range(width):
            columns:range = range(col, col + length + 1)
            rows:range = range(row, row + length + 1)
            if col + length <= width:
                # 1. 
                domain.append([GridLocation(row, c) for c in columns])
                if row + length <= height:
                    # 2.
                    domain.append([GridLocation(r, col + (r - row)) for r in rows])
            if row + length <= height:
                # 3.
                domain.append([GridLocation(r, col) for r in rows])
                if col - length >= 0:
                    # 4.
                    domain.append([GridLocation(r, col - (r - row)) for r in rows])
    return domain
```

## ì‹¤í–‰

```python
class WordSearchConstraint(Constraint[str, List[GridLocation]]):
    def __init__(self, words:List[str]) -> None:
        super().__init__(words)
        self.words:List[str] = words

    def satisfied(self, assignment:Dict[str, List[GridLocation]]) -> bool:
        all_locations = [locs for values in assignment.values() for locs in values]
        return len(set(all_locations)) == len(all_locations)
```

```python
if __name__ == "__main__":
    grid:Grid = generate_grid(9, 9)
    words:List[str] = ["MATTHEW", "JOE", "MARY", "SARAH", "SALLY"]
    locations:Dict[str, List[List[GridLocation]]] = {}
    for word in words:
        locations[word] = generate_domain(word, grid)
    csp:CSP[str, List[GridLocation]] = CSP(words, locations)
    csp.add_constraint(WordSearchConstraint(words))
    solution:Optional[Dict[str, List[GridLocation]]] = csp.backgracking_search()
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        for word, grid_locations in solution.items():
            if choice([True, False]):
                grid_locations.reverse()
            for index, letter in enumerate(word):
                (row, col) = (grid_locations[index].row, grid_locations[index].column)
                grid[row][col] = letter
        display_grid(grid)
```



## ğŸ“ ì—°ìŠµë¬¸ì œ 3-1

1. *Q*

   WordSearchConstraint í´ë˜ìŠ¤ë¥¼ ìˆ˜ì •í•˜ì—¬ ì¤‘ë³µ ë‹¨ì–´ë¥¼ í—ˆìš©í•˜ëŠ” ë‹¨ì–´ ê²€ìƒ‰ì„ êµ¬í˜„í•˜ë¼.

3-1

---

## ğŸ“ ì—°ìŠµë¬¸ì œ 3-2

1. *Q*

   íšŒë¡œíŒ ë ˆì´ì•„ì›ƒ ë¬¸ì œ



## ğŸ“ ì—°ìŠµë¬¸ì œ 3-3

1. *Q*

   ìŠ¤ë„ì¿  ë¬¸ì œ

