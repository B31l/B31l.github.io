---
title: "[Algorithm] Halting Problem"
subtitle: "Proof that computers can't do everything"
tags: Algorithm
---







---









---





알고리즘은 주어진 문제를 해결하기 위한 절차나 방법을 의미한다.

이 [영상](https://www.youtube.com/watch?v=92WHN-pAFCs&ab_channel=udiprod)에서는 알고리즘으로 해결할 수 없는 문제에 대해서 소개한다.



# 알고리즘

알고리즘은 다음과 같은 특징을 가진다.

1. `입력 & 출력` (Input & Output)

   알고리즘은 반드시 하나 이상의 출력값을 가진다. (입력은 없을 수도 있음)

1. `유한성` (Finiteness)

   알고리즘은 한정된 수의 작업을 하며, 반드시 유한한 횟수(시간) 내에 종료해야 한다.

3. `명확성` (Definiteness)

   알고리즘의 각 단계는 명확하게 정의되어야 한다.

4. `유효성` (Effectiveness)

   알고리즘의 모든 명령들은 실행 가능해야 한다.







# 완벽한 기계

`machine_A`는 주어진 연산 문제를 완벽하게 해결하는 알고리즘이다. 

(이 문서에서는 사칙연산을 하는 알고리즘만 작성하겠다.)

```python
def machine_A (num_a, num_b, operator):
    if operator == "+":
        return num_a + num_b;
    if operator == "-":
        return num_a - num_b;
    if operator == "*":
        return num_a * num_b;
    if operator == "/":
        return num_a / num_b;
    else:
        pass
```

> **In [1]**


```python
machine_A (3, 5, "+")
```

> **Out [1]**


    8



`machine_C`는 체커판의 현재 상태가 주어지면 최적의 수를 출력하는 알고리즘이다.

다음 수를 예측하는 알고리즘은 매우 복잡하다. 이 문서에서는 print 함수를 통해 간단하게 표현하겠다.


```python
def machine_C (pieces):
    result = "Do the best play in player's turn"
    return result
```

machine_C에 체커판의 배열을 입력하면, 플레이어가 할 수 있는 최적의 수를 출력한다.

> **In [2]**


```python
import numpy as np
# 0 is blank, 1 is player1, 2 is player 2
pieces = np.array([[0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                   [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                   [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                   [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                  
                   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  
                   [0, 2, 0, 2, 0, 2, 0, 2, 0, 2],
                   [2, 0, 2, 0, 2, 0, 2, 0, 2, 0],
                   [0, 2, 0, 2, 0, 2, 0, 2, 0, 2],
                   [2, 0, 2, 0, 2, 0, 2, 0, 2, 0]])

machine_C (pieces)
```

> **Out [2]**

    machine_C (pieces)

---





# 정지 문제

machine_A에 체커판의 배열을 입력하면 어떻게 될까?

> **In [3]**

```python
machine_A (pieces, 2)
```

> **Out [3]**


    ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last)
    <ipython-input-13-923d387e2ab2> in <module>
    ----> 1 machine_A (pieces)
    
    TypeError: machine_A() missing 2 required positional arguments: 'num_b' and 'operator'

machine_A는 이러한 입력을 처리하도록 설계되지 않았기 때문에, machine_A의 작동은 멈춰 버린다. (Stuck)

machine_C에 연산식을 입력해도 같은 문제가 일어난다.



> **In [4]**

```python
machine_C (3, 5, "+")
```

> **Out [4]**


    ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last)
    <ipython-input-15-a5cc8fa42fed> in <module>
    ----> 1 machine_C (3, 5, "+")
    
    TypeError: machine_C() takes 1 positional argument but 3 were given

---





# machine_H

정지 문제를 해결하는 알고리즘 `machine_H (P, I)`이 있다고 가정하자.

`P`에 테스트할 알고리즘을, `I`에 그 알고리즘에 필요한 입력값을 대입하면, 알고리즘이 멈추지 않을지 결정한다.

machine_A에 [3, 2, "+"]를 입력하면 5를 리턴하므로 알고리즘이 멈추지 않는다.

즉, machine_H는 True를 출력한다.

> **In [5]**

```python
machine_H (machine_A, [3, 2, "+"])
```

> **Out [5]**

```
True
```

과연 machine_H는 존재하는가?

---





# 정지 정리

machine_H의 존재 여부를 증명하기 위해서, 2개의 machine을 추가로 생성한다.

`machine_P`는 값을 입력받으면, 입력받은 값의 복사본을 두 개 리턴한다.

```python
def machine_P (x):
    return x, x
```

> **In [6]**

```python
machine_P(2)
print(machine_P(2)[0])
print(machine_P(2)[1])
```

> **Out [6]**

```
2
2
```



`machine_N`은 True를 입력받으면 False를, False를 입력받으면 True를 리턴한다.

```python
def machine_N (x):
    if x == True:
        return False
    if x == False:
        return True
```

> **In [7]**
>
> ```python
> print(machine_N(True))
> print(machine_N(False))
> ```

> **Out [7]**
>
> ```
> False
> True
> ```









---

## 참고 자료

> https://arisu1000.tistory.com/27673
>
> http://www.ktword.co.kr/test/view/view.php?m_temp1=635

