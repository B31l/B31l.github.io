---
layout: post
meta: "Week-2"
title: "Week-2: ê²€ìƒ‰ ë¬¸ì œ[ì—°ìŠµë¬¸ì œ]"
categories: Classic
tags: Python
---

* content
{:toc}
# ğŸ“ ì—°ìŠµë¬¸ì œ 2-1

1. *Q*

   dna_search.pyì—ì„œ ìˆ«ìê°€ 100ë§Œ ê°œì¸ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ë¼. ê·¸ë¦¬ê³  ì„ í˜• ê²€ìƒ‰ì˜ linear_contains( )ì™€ ì´ì§„ ê²€ìƒ‰ì˜ binary_contains( ) í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª‡ëª‡ ìˆ«ìë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ì¸¡ì •í•˜ë¼.

ì´ì§„ ê²€ìƒ‰ì˜ ì‹œê°„ë³µì¡ë„ëŠ” O(logN)ì´ë¯€ë¡œ, O(N)ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§€ëŠ” ì„ í˜• ê²€ìƒ‰ì— ë¹„í•´ í›¨ì”¬ íš¨ìœ¨ì ì´ë‹¤.

| ì„ í˜• ê²€ìƒ‰ | ì´ì§„ ê²€ìƒ‰ |
| --------- | --------- |
| O(N)      | O(logN)   |

ë‘ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì˜ íš¨ìœ¨ ì°¨ì´ë¥¼ ì§ê´€ì ìœ¼ë¡œ ì•Œ ìˆ˜ ìˆë„ë¡ time ëª¨ë“ˆì„ ì‚¬ìš©í•´ íŠ¹ì • ìˆ«ìë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ì¸¡ì •í•˜ë©°, ì¶©ë¶„íˆ í° í¬ê¸°ì˜ ë¦¬ìŠ¤íŠ¸ì—ì„œ ê²€ìƒ‰ì„ ì‹¤í–‰í•œë‹¤.

```python
from generic_search import linear_contains, binary_contains
import time

my_list = [x for x in range(1_000_000)]
test = [55555, 714285, 1000000]
```

**ì„ í˜• ê²€ìƒ‰**

```python
for i in test:
    start = time.time()
    linear_contains(my_list, i)
    end = time.time()
    print(f"{i}ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : {(end - start) * 1000} ms")
```

```
55555ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 1.9969940185546875 ms
714285ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 21.904706954956055 ms
1000000ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 33.91003608703613 ms
```

**ì´ì§„ ê²€ìƒ‰**

```python
for i in test:
    start = time.time()
    binary_contains(my_list, i)
    end = time.time()
    print(f"{i}ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : {(end - start) * 1000} ms")
```

```
55555ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 0.0 ms  
714285ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 0.0 ms 
1000000ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 0.0 ms
```

ì„ í˜• ê²€ìƒ‰ì—ì„œëŠ” Nì´ ìµœëŒ€ 100ë§Œì´ë©°, ìˆ«ìì˜ í¬ê¸°ê°€ ì»¤ì§ˆìˆ˜ë¡ ê²€ìƒ‰ì— í•„ìš”í•œ ë¹„êµ íšŸìˆ˜ê°€ ë§ì•„ì§€ë¯€ë¡œ ê²€ìƒ‰í•˜ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì€ ìˆ«ìì™€ ë¹„ë¡€í•œë‹¤.

ì„ í˜• ê²€ìƒ‰ ì—­ì‹œ ë¹ ë¥¸ ì†ë„ë¡œ ì´ë£¨ì–´ì§€ì§€ë§Œ, ì´ì§„ ê²€ìƒ‰ì—ì„œ logNì€ 20ë„ ì±„ ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì„ í˜• ê²€ìƒ‰ê³¼ëŠ” ë¹„êµí•  ìˆ˜ ì—†ì„ ì •ë„ë¡œ ë¹ ë¥´ë‹¤.

---

# ğŸ“ ì—°ìŠµë¬¸ì œ 2-2

1. *Q*

   dfs( ), bfs( ), astar( ) í•¨ìˆ˜ì— ì¹´ìš´í„°ë¥¼ ì¶”ê°€í•˜ì—¬ ë™ì¼í•œ ë¯¸ë¡œë¥¼ ê²€ìƒ‰í•˜ëŠ” ì§€ì ì˜ ìˆ˜ë¥¼ í™•ì¸í•˜ë¼. í†µê²Œì ìœ¼ë¡œ ì˜ë¯¸ ìˆëŠ” ê²°ê³¼ë¥¼ ì–»ê¸° ìœ„í•´ 100ê°œì˜ ë¯¸ë¡œ ìƒ˜í”Œì— ëŒ€í•´ ì¡°ì‚¬í•œë‹¤.

ê²€ìƒ‰í•˜ëŠ” ì§€ì ì˜ ìˆ˜ë¥¼ í™•ì¸í•˜ê¸° ìœ„í•´ Node í´ë˜ìŠ¤ì— count ì†ì„±ì„ ì¶”ê°€í•œ ë’¤, node_to_path í´ë˜ìŠ¤ì— ì´ë¥¼ ì¶œë ¥í•˜ê¸° ìœ„í•œ ì•Œê³ ë¦¬ì¦˜ì„ ì‘ì„±í•œë‹¤.

```python
class Node(Generic[T]):
    def __init__(self, state:T, parent:Optional[Node], cost:float = 0.0, heuristic:float = 0.0):
        self.state:T = state
        self.parent:Optional[Node] = parent
        self.cost:float = cost
        self.heuristic:float = heuristic
        self.count:int = 0 #â˜…
    def __lt__(self, other:Node) -> bool:
        return (self.cost + self.heuristic) < (other.cost + other.heuristic)
```

```python
def node_to_path(node:Node[T]) -> List[T]:
    counter:int = 0 #â˜…
    path:List[T] = [node.state]
    while node.parent is not None:
        counter += node.count #â˜…
        node = node.parent
        path.append(node.state)
    path.reverse()
    return counter #â˜…
```

dfs( ), bfs( ), aster( ) í•¨ìˆ˜ì—ì„œ ìì‹ ë…¸ë“œì— ëŒ€í•œ ë¹„êµë¥¼ ìˆ˜í–‰í•  ë•Œë§ˆë‹¤ í•´ë‹¹ ë…¸ë“œì˜ countë¥¼ 1 ì¦ê°€ì‹œí‚¨ë‹¤.

```python
def dfs
    ...
        for child in successors(current_state):
            current_node.count += 1 #â˜…
            if child in explored:
    ...
```

```python
def bfs
    ...
        for child in successors(current_state):
            current_node.count += 1 #â˜…
            if child in explored:
    ...
```

```python
def astar
    ...
        for child in successors(current_state):
            new_cost:float = current_node.cost + 1
            if child not in explored or explored[child] > new_cost:
                current_node.count += 1 #â˜…
                explored[child] = new_cost
    ...
```

ì´ì œ ì„¸ ì•Œê³ ë¦¬ì¦˜ì„ ë¹„êµí•œë‹¤.

```python
from typing import Dict

if __name__ == "__main__":
    main_count:int = 0
    solutions:Dict[str, int] = {"dfs" : 0, "bfs" : 0, "astar" : 0}
    while main_count < 100:
        m:Maze = Maze()
        solution1:Optional[Node[MazeLocation]] = dfs(m.start, m.goal_test, m.successors)
        solution2:Optional[Node[MazeLocation]] = bfs(m.start, m.goal_test, m.successors)
        distance:Callable[[MazeLocation], float] = manhattan_distance(m.goal)
        solution3:Optional[Node[MazeLocation]] = astar(m.start, m.goal_test, m.successors, distance)
        if (solution1 and solution2 and solution3) is not None:
            main_count += 1
            solutions["dfs"] += node_to_path(solution1)
            solutions["bfs"] += node_to_path(solution2)
            solutions["astar"] += node_to_path(solution3)
    print(solutions)
```

```
{'dfs': 9493, 'bfs': 5149, 'astar': 2819}
```

 íƒìƒ‰ ë¶ˆê°€ëŠ¥í•œ ë¯¸ë¡œë¥¼ ì œì™¸í•œ 100ê°œì˜ ë¯¸ë¡œ ìƒ˜í”Œì— ëŒ€í•´ ì¡°ì‚¬í–ˆë‹¤. 

ì¡°ì‚¬ ê²°ê³¼ dfsì—ì„œ ê°€ì¥ ë§ì€ ì§€ì (í‰ê·  94.9)ì„ ê²€ìƒ‰í–ˆìœ¼ë©°, astarì—ì„œ ê°€ì¥ ì ì€ ì§€ì (í‰ê·  28.2)ì„ ê²€ìƒ‰í–ˆë‹¤.

---

# ğŸ“ ì—°ìŠµë¬¸ì œ 2-3

1. *Q*

   ì„ êµì‚¬ì™€ ì‹ì¸ì¢… ìˆ˜ë¥¼ ë³€í˜•í•˜ì—¬ ë¬¸ì œë¥¼ í’€ì–´ë³´ë¼.

ì„ êµì‚¬ì™€ ì‹ì¸ì¢…ì˜ ìˆ˜ê°€ ë‹¤ë¥¸ ê²½ìš°ì—ë„ ê°•ì„ ê±´ë„ˆëŠ” ë°©ë²•ì„ ì¶œë ¥í•´ì•¼ í•œë‹¤.

```python
MISS:List[int] = []
CANN:List[int] = []
```

ë¦¬ìŠ¤íŠ¸ `MISS`ì™€ `CANN`ëŠ” MCState ê°ì²´ê°€ ìƒì„±ë  ë•Œë§ˆë‹¤ ë§¤ê°œë³€ìˆ˜ë¡œ ë“¤ì–´ì˜¨ ì„ êµì‚¬ì™€ ì‹ì¸ì¢…ì˜ ìˆ˜ë¥¼ ì €ì¥í•œë‹¤. ë¦¬ìŠ¤íŠ¸ì˜ 0ë²ˆ ì¸ë±ìŠ¤ëŠ” ì²˜ìŒ ì‹œì‘í•  ë•Œ ì„œìª½ ê°•ë‘‘ì— ì¡´ì¬í•˜ëŠ” ì„ êµì‚¬ì™€ ì‹ì¸ì¢…ì˜ ìˆ˜ê°€ ì €ì¥ëœë‹¤. ì´í›„ ê¸°ì¡´ ì•Œê³ ë¦¬ì¦˜ì˜ MAX_NUM ëŒ€ì‹  ë¦¬ìŠ¤íŠ¸ì˜ 0ë²ˆ ì¸ë±ìŠ¤ì˜ í•­ëª©ì„ ì‚¬ìš©í•œë‹¤.

MCState í´ë˜ìŠ¤ì˜ ë‚´ìš©ì„ ìˆ˜ì •í•œë‹¤.

```python
def __init__(self, missionaries:int, cannibals:int, boat:bool) -> None:
        MISS.append(missionaries)
        CANN.append(cannibals)
        self.wm:int = missionaries
        self.wc:int = cannibals
        self.em:int = MISS[0] - self.wm
        self.ec:int = CANN[0] - self.wc
        self.boat:bool = boat
```

```python
def goal_test(self) -> bool:
    return self.is_legal and self.em == MISS[0] and self.ec == CANN[0]
```

4ëª…ì˜ ì„ êµì‚¬ì™€ 3ëª…ì˜ ì‹ì¸ì¢…ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš° ê·¸ì— ë§ê²Œ ì¸ìë¥¼ ìˆ˜ì •í•œ ìˆ˜ ì‹¤í–‰í•œë‹¤.

**ì‹¤í–‰**

```python
if __name__ == "__main__":
    start:MCState = MCState(4, 3, True)
    solution:Optional[Node[MCState]] = bfs(start, MCState.goal_test, MCState.successors)
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    else:
        path:List[MCState] = node_to_path(solution)
        display_solution(path)
```

```
ì„œìª½ ê°•ë‘‘ì—ëŠ” 4ëª…ì˜ ì„ êµì‚¬ì™€ 3ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë™ìª½ ê°•ë‘‘ì—ëŠ” 0ëª…ì˜ ì„ êµì‚¬ì™€ 0ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë°°ëŠ” ì„œìª½ì— ìˆë‹¤.
0ëª…ì˜ ì„ êµì‚¬ì™€ 2ëª…ì˜ ì‹ì¸ì¢…ì´ ë™ìª½ ê°•ë‘‘ì—ì„œ ì„œìª½ ê°•ë‘‘ìœ¼ë¡œ ê°”ë‹¤.

...

ì„œìª½ ê°•ë‘‘ì—ëŠ” 0ëª…ì˜ ì„ êµì‚¬ì™€ 0ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë™ìª½ ê°•ë‘‘ì—ëŠ” 4ëª…ì˜ ì„ êµì‚¬ì™€ 3ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.
ë°°ëŠ” ë™ìª½ì— ìˆë‹¤.
```

