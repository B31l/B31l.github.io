---
title: "DFD"
categories: [소프트웨어공학]
mathjax: true
---

* content
{:toc}
> 야채 볶음밥을 만드는 과정을 설명한 다음 사례를 읽고 자료흐름도(DFD)를 작성해 보라.
>
> 1. 감자, 양파, 당근 등의 야채를 깨끗이 씻어 껍질을 벗긴 후, 잘게 썰어 준비한다.
> 2. 적당한 크기의 팬에 식용유를 두른 후 열을 가한다.
> 3. 준비한 야채를 넣어 야채가 익을 동안 볶는다. 이때 감자나 당근을 먼저 익힌 후 양파는 나중에 넣어 볶는다. 약간의 소금을 넣어 간을 맞춘다.
> 4. 적당량의 밥을 함께 넣어 야채가 골고루 섞일 때 까지 함께 볶는다.
> 5. 별도의 팬에 기름을 두른 후 계란을 얇게 펴서 부친다.
> 6. 완성된 볶음밥을 접시에 담아낸 후 준비한 계란 부침을 얻고 적당량의 케챱, 참깨 등을 뿌린다. 
>
> [정답](https://github.com/B31l/B31l/blob/main/_posts/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99/20221020-05-%EC%95%BC%EC%B1%84%20%EB%B3%B6%EC%9D%8C%EB%B0%A5.png?raw=true)

# 데이터 흐름도

| 💡 정의<br>데이터 흐름도<sup>Data-flow diagram, DFD</sup>     |
| ------------------------------------------------------------ |
| 구조적 분석 및 설계에서, 시스템을 구성하는 **프로세스 간의 데이터 흐름**을 중심으로 처리과정을 분석하는 **모형화 도구**이다.<br>자료 흐름도라고도 한다. |

- 소단위 명세서를 한 페이지에 작성할 수 있는 수준까지 시스템을 분할
- **하향식 분할**<sub>전체 설명 => 구성 요소 설명</sub>의 원리를 적용
- **자료의 흐름**<sup>Data Flow</sup>**에 중점**(제어의 흐름<sup>Control Flow</sup>은 중요시하지 않음)

## DFD의 구성요소

![](https://github.com/B31l/B31l/blob/main/_posts/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99/20221020-01-DFD.png?raw=true)

![](https://github.com/B31l/B31l/blob/main/_posts/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99/20221020-02-DFD%EC%9D%98%20%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C.png?raw=true)

## DFD의 작성 원칙

> 
>
> - Black hole: 입력만 있어서는 안 된다.
> - Miracle: 출력만 있어서는 안 된다.
> - 객체 간의 직접적인 데이터 흐름은 안 된다.
> - 데이터 저장소 간의 직접적인 데이터 흐름은 안 된다.
> - 입력 데이터 흐름은 반드시 변환 후 출력 흐름을 전제로 한다.

- **자료 보존의 원칙**

  출력 자료 흐름은 반드시 입력 자료 흐름을 이용해 생성

  ![](https://github.com/B31l/B31l/blob/main/_posts/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99/20221020-03-%EC%9E%90%EB%A3%8C%20%EB%B3%B4%EC%A1%B4%EC%9D%98%20%EC%9B%90%EC%B9%99.png?raw=true)

- **최소 자료 입력의 원칙**

  출력 자료를 산출하는 데 필요한 최소의 자료 흐름만 입력

  ![](https://github.com/B31l/B31l/blob/main/_posts/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B3%B5%ED%95%99/20221020-04-%EC%B5%9C%EC%86%8C%20%EC%9E%90%EB%A3%8C%20%ED%9D%90%EB%A6%84%EC%9D%98%20%EC%9B%90%EC%B9%99.png?raw=true)

- 독립성의 원칙

- 지속성의 원칙

- 순차 처리의 원칙

- 영구성의 원칙

- 자료 변환의 원칙

## 자료 흐름 분할

- 자료 흐름 관점을 기반으로 **배경도**<sub>Level 0</sub> 및 **분할도**<sub>Level 1</sub>를 작성한다. 

  | 배경도 | ㅎㅇ |
  | ------ | ---- |
  |        |      |

  

- 처리 순서에 따라 요구되는 자료들을 식별하게 한다.

- 입력 자료 흐름과 출력 자료 흐름 사이의 균형을 고려하게 한다.

- 애매모호한 처리들을 구별할 수 있도록 도와준다.

- 상대적으로 소규모 시스템에 적용하기에 적합하다.

- Level 0<sub>업무배경도</sub>

  경계를 찾아낸다.

- Level 1<sub>분할도</sub>

- Level 2<sub>분할도</sub>



| 📒 Note<br>입력 자료 흐름과 출력 자료 흐름 사이의 균형        |
| ------------------------------------------------------------ |
| 상위 단계와 하위 단계의 입·출력 자료 흐름 개수가 동일해야 한다(입력끼리, 출력끼리) |

자료 흐름 분할은 상대적으로 소규모 시스템에 적용하기에 적합하다.





# 자료사전<sup>DD<sub>(Data Dictionary)</sub></sup>

# 소단위 명세서<sup>Mini-Spec</sup>

자료사전

소단위명세서 Mini Spec

모듈 간의 계층 구조 (그리고 이에 대한 평가)

- 도구
  - 구조적 언어: 절차적 표현에 유리하다.
  - Decision Table(의사결정표)     -> 규칙에 따른 의사 결정 표현 시 유리하다.
  - Decision Tree(의사결정트리)   -> 규칙에 따란 의사 결정 표현 시 유리하다.
  - pre-post condition
- 평가 방법
  - 응집력(응집도)
  - 결합도



![image-20221123144337266](C:\Users\rnfhr\AppData\Roaming\Typora\typora-user-images\image-20221123144337266.png)

---

DT1을 DT2로 확장 (elementary rule)



<29 of 54>

- condition 하나 당 2개의 elementary rule이 존재해야 한다(Y or N)

- 각 elementary rule은 서로 달라야 한다.

- 각 elementary rule은 

- k개의 조건에 대해 2<sup>k</sup> rule

- 같은 elementary rule이 있으면 **중복 명세** (DT2에서 C1:Y와 C2Y의 경우가 있겠네요)

- 동일한 룰에 대해서 취해지는 액션이 다른 경우를 **모호한 명세**라고 함.

  예를 들어 R11과 R22가 있겠네요~

- 모호성 -> 눈에만 그렇게 보일수도 있고 실제로 애매할 수도 있다는거임~

- 모호성이 논리적으로 불가능하다면 눈에 보기에는 그렇다 라고 말할 수 있다.

  예를 들어 x>60 그리고 x<40 이건 동시에 일어날 수 없는 일이죠? 그러므로!!!!! 보기에 애매모호한 규칙이다 라고 부르갰읍니다. 아직 발생한건 아니고 보기에만 논리적으로 안맞는다 이것을 "보기에는 모호한 규칙" 

- 그렇기에 "보기에 애매한 규칙"은 에러가 아닙니다



- 만약 보기에 애매한 규칙이 real이면 이것을 모순<sup>contradiction</sup>이라고 부르갯읍니다
- **Contradictory Specification.** (모순된) 이라고 부름



<32 of 54>

그냥 PPT 보샘

논리적인 에러가 존재하다면 추정을 해야한다.



USE OF KARNAUGH MAPS (K - map)

카나프맵을 이용해서 steel의 grade를 측정하는 예시가 있어요 정말로 기분좋아지는거야

3개의 condition들은 독립적이고, decision table은 incomplete하다(빈구멍이 존재하는거에요~)

근데 K-map 사용 안했으면 이러한 사실을 알 수 없었을 것! 든든하다 K-map!



<36 of 54>

또 다른 예시가 있어요~정말로기분좋아지는거야

<37>

? 이건 incomplete 한 거고

A1A4 이렇게 2개잇는건 모호한 거에요~



### **REDUNDANCY ELIMINATION**

중복 제거

이거 아시죠? xy + xy^ 를 x로 하는거 이런거 이산수학에서 배운거

그리고 카나프맵에서 어떻게 합치는지도 배웠으니까 아시리라고믿습니다~

<45>**EXAMPLE-REDUCTION OF RULES IN WORD STATEMENT**

에서 예시가있어요~

이걸 덱압축 하는 내용입니다~^^



<49 of 54> 이것도 예시임. 기차 예매 시스템이네요

**Sometimes Decision trees are more appropriate to explain to a user how decisions are taken**

> 교수?가?시험문제를 어떻게내느냐? 굉장히 어렵게 내자면은 <34 of 54>의 그 왼쪽 그림을 오른쪽 Decision Tree로 바꿔라. 같은 거죠. 하지만 그렇게 내고 싶지 않다네요. **구조적언어.Decision Tree.Decision Table 비교**라고 강조함
>
> Decision Tree를 제시해주고, Decision Table로 바꿔봐라 도 할 수 있갰죠~`??~???
>
> **SOME PEOPLE FIND DECISION TREE EASIER TO UNDERSTAND**
>
> - **Observe incompleteness evident in the equivalent Decision Table is not evident in the Decision tree**
>
>   아주 답을 가르켜준다고 말함. 위에 내용 잘 분석하셈. 이건 Decision Table의 장점
>
> - **If the testing sequence is specified and is to be strictly followed the Decision tree is simple to understand.**
>
>   테스트할때 순서를ㄹ 따라야한다면, Decision Tree가 더 이해하기 쉽다. 이건Decision Tree의 장점

<53>

아예 3개를 비교했네요 꼭 외우샘

![image-20221124150402583](C:\Users\rnfhr\AppData\Roaming\Typora\typora-user-images\image-20221124150402583.png)

- 가독성(Readable) 측면에서는 Structured English가 최고다



그렇다면 언제 Structured English, Decision Table, Decision Tree를 사용할 것인가?

- **Use Structured English if there are many loops and actions are complex**

  action(순차, 반복)에 초점이 맞춰져 있는 경우 Structured English는 좋다.

  근데 action(조건)은 별!루

- **Use Decision tables when there are** **a large number of** **conditions to** **check** **and logic is complex**

  조건이 너무 많고 논리가 복잡할 때에는 Decision Table로 기분이 좋아지는거야~

- **Use Decision trees when sequencing of conditions is important and if there are not many conditions to be tested**

  얘는 조건이 많지 않아야된대
