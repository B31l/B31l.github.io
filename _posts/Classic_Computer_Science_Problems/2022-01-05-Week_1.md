---
layout: post
title: "🎲 (2) 압축 알고리즘"
meta: "Compress & Decompresss"
categories: Classic_Computer_Science_Problems
tags: Python
---
* content
{:toc}

# ?

저장 공간이 제한될 경우 파일을 압축할 필요가 있으며, 이 때 **압축 알고리즘**이 사용된다.

다양한 압축 알고리즘이 존재하지만, 궁극적으로는 다음 기능을 구현해야 한다.

- **압축(compress)**

  부호화(encoding) 과정을 거쳐 원본 파일을 압축 파일로 변환한다.

- **압축 풀기(decomporess)**

  복호화(decoding) 과정을 거쳐 압축 파일을 원본 파일로 변환한다.

---

# **유전 정보 압축**

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-00.jpg?raw=true)

DNA는 4가지 종류(A, C, G, T)의 뉴클레오타이드(nucleotide)로 구성된다. 

만약 `n`개의 뉴클레오타이드로 구성된 염기서열을 문자열로 작성할 경우, 각 문자의 크기는 8비트이므로 총 `8n`비트의 저장공간이 필요하다. (UTF-8 기준)

| 문자 | 8bit     |
| ---- | -------- |
| A    | 01000001 |
| C    | 01000011 |
| G    | 01000111 |
| T    | 01010100 |

하지만 4가지 종류의 문자를 나타내는 데에는 2개의 비트만 있어도 충분하다. 

각 문자의 크기를 2비트로 압축한다면 필요한 저장공간은`2n`비트로 감소하며, 최대 75%의 저장 공간을 절약할 수 있다. 

| 문자 | 2bit |
| ---- | ---- |
| A    | 00   |
| C    | 01   |
| G    | 10   |
| T    | 11   |

이 아이디어로 유전 정보를 압축하는 알고리즘을 작성한다.

## 1. compress

뉴클레오타이드의 수만큼 2비트 문자열을 추가하며, 추가할 때마다 쉬프트 연산자 `<<`를 사용해 2비트씩 왼쪽으로 이동한다.

예를 들어 문자열 **ATGC**을 인수로 넘기면, 대응하는 2비트 문자열을 초기값 1 뒤에 차례대로 추가한다. 

비트 단위 연산에서 비트 추가는 `|=` 연산자를 사용한다.

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-01.png?raw=true)

압축 과정을 파이썬으로 구현하면 다음과 같다.

```python
def compress(gene:str) -> str:
    bit_string:int = 1
    for nucleotide in gene.upper():
        bit_string <<= 2
        if   nucleotide == "A": bit_string |= 0b00
        elif nucleotide == "C": bit_string |= 0b01
        elif nucleotide == "G": bit_string |= 0b10
        elif nucleotide == "T": bit_string |= 0b11
        else: 
            raise ValueError(f"Invalid nucleotide: { nucleotide }")
    return bit_string
```

- **In [1]**

  ```python
  from sys import getsizeof
  
  original = "ATGC"
  compressed = compress(original)
  print(f"{ original }: { getsizeof(original) }바이트")
  print(f"{ bin(compressed) }: { getsizeof(compressed) }바이트")
  ```

- **Out [1]**

  ```
  ATGC: 53바이트
  0b100111001: 28바이트
  ```

`sys.getsizeof()` 메서드를 사용해 바이트를 확인할 수 있다.

> 파이썬 객체 시스템의 내제된 오버헤드 때문에 저장공간의 크기를 28바이트 미만으로 줄일 수는 없다.

> bit_string의 초기값을 0으로 설정해도 괜찮지 않을까? 단순히 첫 번째 자리만 1에서 0으로 바뀐 값인 **000111001**을 반환할 것이라고 예측할 수도 있다. 하지만 반환되는 값은 **111001**이다. 
>
> 이유는 간단하다. bit_string은 정수형이기 때문에 0으로 시작하는 앞 자릿수를 모두 제거해 반환하기 때문이다. 따라서 변환 오류를 방지하기 위해서 bit_string의 초기값은 반드시 1로 설정해야 한다. 

## 2. decompress

bit_string의 끝 부분부터 2개씩 비트 문자열을 읽은 뒤, 뉴클레오타이드로 변환한 값을 gene에  추가한다. 

처음 bit_string을 만들 때 비트 1로 시작했기 때문에 해당 비트를 제외해야 하므로, 전체 길이에서 1을 뺀 값만큼 반복을 시행한다.

복호화 과정에서 역순으로 읽었기 때문에 gene에는 뒤집힌 값이 저장되어 있다. 따라서 `[::1]`을 사용해 원래 값으로 변환한 뒤 반환해야 한다.

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-02.png?raw=true)

압축 해제 과정을 파이썬으로 구현하면 다음과 같다.

```python
def decompress(bit_string:str) -> str:
    gene:str = ""
    for i in range(0, bit_string.bit_length() - 1, 2):
        bits:int = bit_string >> i & 0b11
        if   bits == 0b00: gene += "A"
        elif bits == 0b01: gene += "C"
        elif bits == 0b10: gene += "G"
        elif bits == 0b11: gene += "T"
        else: 
            raise ValueError(f"Invalid bits: { bits }")
    return gene[::-1] # Reverse
```

- **In [2]**

  ```python
  decompressed = decompress(compressed)
  print(f"{ decompressed }: { getsizeof(decompressed) }")
  ```

- **Out [2]**

  ```
  ATGC: 53
  ```

원본 데이터 `original`와, 압축 후 해제 과정을 거친 데이터 `decompressed`가 같음을 확인할 수 있다.

## 3. 시간 복잡도 분석

`n`: 부호화 및 복호화 과정에서의 입력값의 길이

| 메서드     | 시간복잡도 |
| ---------- | ---------- |
| compress   | O(n)       |
| decompress | O(n)       |

## 4. Dictionary vs If statement

조건문 대신 파이썬의 **사전 자료형**를 사용해 구현할 수도 있다. 이 때 Dictionary는 뉴클레오타이드와 그에 해당하는 비트를  각각 Key와 Value로 갖는다. 

조건문을 사용하면 각 반복 당 최대 4번 비교해야 하며, 사전 자료형을 사용하면 해시 충돌이 발생할 수 있다. 

하지만 결과적으로는 두 방법 모두 `O(n)`의 시간 복잡도를 가진다.

---

# **허프만 부호화**

유전 데이터는 4가지 종류의 문자로만 구성된 **고정 길이 코드(fixed length code)**이다. 압축 과정이 어렵지 않지만 문자의 종류가 많아질수록 이 방법은 한계에 부딪힌다. 예를 들어 ASCII 문서는 최대 128가지의 문자로 구성되며, 유니코드의 경우 한글 수만 해도 11,172개이다. 각 문자에 해당하는 비트 문자열을 일일이 지정하는 것은 비효율적이며 높은 압축률을 기대할 수 없다. 

**가변 길이 코드(variable length code)**를 사용하면 고정 길이 코드의 문제점을 해결할 수 있다. 대표적인 알고리즘인 **허프만 부호화(Huffman coding)** 과정에서는 각 문자의 등장 빈도를 바탕으로 트리를 만든 뒤, 노드의 위치에 따라 서로 다른 비트 문자열을 부여한다. 이 때 부여되는 가변 길이 코드는 어떤 비트 문자열이 다른 비트 문자열의 접두어가 될 수 없다는 규칙을 갖는 **접두어 코드(prefix code)**이다. 

예를 들어 문자 A와 B에 다음과 같은 비트 문자열을 부여한다. 이 때 11은 110의 접두어이므로 접두어 코드의 조건을 만족하지 못한다. 

```
A: 11
B: 110
```

접두어 코드를 사용하면 복호화 과정에서 빠른 해석을 할 수 있다.

## 1. compress

허프만 부호화 과정을 통해 문자열 **GOOGOLPLEX**를 압축한다. 

우선 주어진 문자열을 문자 단위로 분해한 다음, 각 문자가 등장하는 빈도수를 기준으로 오름차순으로 정렬한다.

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-03.png?raw=true)

가장 작은 빈도수를 가진 두 문자 E, P를 자식 노드로 갖는 서브트리를 만든다. 이후 빈도수를 기준으로 다시 오름차순으로 정렬한다. 트리가 완성될 때까지 이 과정을 반복한다.

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-04.png?raw=true)

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-05.png?raw=true)

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-06.png?raw=true)

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-07.png?raw=true)

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-08.png?raw=true)

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-09.png?raw=true)

> 완성된 허프만 트리에서 데이터 노드는 항상 리프에 위치한다. 

특정 노드에 해당하는 비트 문자열을 구하기 위해서는 루트에서 노드까지의 경로를 모두 계산해야 한다. 이 때 루트를 기준으로 왼쪽 노드는 0, 오른쪽 노드는 1의 비트를 갖는다. 예를 들어 데이터 E가 위치한 노드의 비트 문자열은 루트에서 출발해 오른쪽(`1`) -> 왼쪽(`0`) -> 오른쪽(`1`) -> 왼쪽(`0`)의 순서로 이동 후 각각의 비트를 모두 합친 값인 `1010`이다.

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/compress-10.png?raw=true)

데이터의 빈도수가 높을수록 짧은 비트 문자열이 부여된 것을 확인할 수 있다. 또한 각 비트 문자열은 접두어 코드의 조건을 만족한다.

허프만 부호화 사용한 압축 과정을 파이썬으로 구현하면 다음과 같다.

```python

```



## 2. decompress

허프만 부호화 사용한 압축 해제 과정을 파이썬으로 구현하면 다음과 같다.

```python
```



---

# Reference

- <https://clansim.tistory.com/73>
- <https://velog.io/@junhok82/%ED%97%88%ED%94%84%EB%A7%8C-%EC%BD%94%EB%94%A9Huffman-coding>

