---
layout: post
meta: "Week-8"
title: "Week-8: ì ëŒ€ì  íƒìƒ‰"
categories: Classic
tags: Python
mathjax: true
---

* content
{:toc}
# ê°œìš”

í‹±íƒí† , ì»¤ë„¥íŠ¸í¬, ì²´ìŠ¤ ë“±ì˜ ê²Œì„ì—ì„œ í”Œë ˆì´ì–´ëŠ” ìƒëŒ€ì™€ **ì ëŒ€ì ì¸ ê´€ê³„**ë¥¼ ê°€ì§€ê³  ìˆë‹¤. í•œ ì‚¬ëŒì´ ìœ ë¦¬í•˜ë‹¤ëŠ” ê²ƒì€ ë‹¤ì‹œ ë§í•´ì„œ ë‹¤ë¥¸ ì‚¬ëŒì´ ë¶ˆë¦¬í•˜ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. ê²Œì„ì—ì„œ ìŠ¹ë¦¬í•˜ê¸° ìœ„í•´ì„œëŠ” ìˆ˜ë¥¼ ì˜ˆì¸¡í•˜ê³  ìµœì ì˜ ì´ë™ì„ ì„ íƒí•´ ì´ì ì„ ì‚´ë ¤ì•¼ í•˜ë©°, ì´ ê³¼ì •ì—ì„œ ì ëŒ€ì  íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•œë‹¤. 

---

# ì œë„¤ë¦­

## ë³´ë“œê²Œì„ êµ¬ì„± ìš”ì†Œ

<u>board.py</u>

```python
# ë³´ë“œê²Œì„ êµ¬ì„± ìš”ì†Œ

from __future__ import annotations
from typing import NewType, List
from abc import ABC, abstractmethod

# ê²Œì„ì—ì„œì˜ ì´ë™ì„ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ íƒ€ì…
# íƒ€ì… ì—˜ë¦¬ì–´ìŠ¤ì˜ ë‘ íƒ€ì…ì€ ë™ë“±í•˜ì§€ë§Œ, NewTypeì€ í•œ íƒ€ì…ì„ ë‹¤ë¥¸ íƒ€ì…ì˜ ì„œë¸Œ íƒ€ì…ìœ¼ë¡œ ì„ ì–¸í•œë‹¤.
Move = NewType("Move", int)


class Piece:
    @property
    def opposite(self) -> Piece:
        raise NotImplementedError("ì„œë¸Œí´ë˜ìŠ¤ë¡œ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.")


class Board(ABC):
    # ëˆ„êµ¬ ì°¨ë¡€ì¸ê°€?
    @property
    @abstractmethod
    def turn(self) -> Piece:
        ...

    # í˜„ì¬ ìœ„ì¹˜ì—ì„œ ìƒˆ ìœ„ì¹˜ë¡œ ì´ë™í•œë‹¤.
    @abstractmethod
    def move(self, location:Move) -> Board:
        ...

    # ë§ì€ í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì–´ë””ë¡œ ì›€ì§ì¼ ìˆ˜ ìˆëŠ”ê°€?
    @property
    @abstractmethod
    def legal_moves(self) -> List[Move]:
        ...

    # ì´ê²¼ëŠ”ê°€?
    @property
    @abstractmethod
    def is_win(self) -> bool:
        ...

    # ë¬´ìŠ¹ë¶€ì¸ê°€?
    @property
    def is_draw(self) -> bool:
        return (not self.is_win) and (len(self.legal_moves) == 0)

    # í”Œë ˆì´ì–´ì˜ ë§ ìœ„ì¹˜ë¥¼ í‰ê°€í•˜ì—¬ ì–´ëŠ ìª½ì´ ìœ ë¦¬í•œì§€ í™•ì¸í•œë‹¤.
    @abstractmethod
    def evaluate(self, player:Piece) -> float:
        ...
```

ê° í”Œë ˆì´ì–´ëŠ” ìì‹ ì˜ í„´ì´ ë˜ë©´ í˜„ì¬ ìƒí™©ì„ ë°”íƒ•ìœ¼ë¡œ ìµœì ì˜ ìˆ˜ë¥¼ ê³„ì‚°í•œ í›„ ìƒˆë¡œìš´ ìœ„ì¹˜ì— ë§ì„ ë†“ëŠ”ë‹¤. ì´ë¯¸ ë§ì´ ìœ„ì¹˜í•œ ê³³ì—ëŠ” ë§ì„ ë†“ì„ ìˆ˜ ì—†ë‹¤. í„´ì´ ëë‚˜ë©´ ìŠ¹ë¦¬ ë˜ëŠ” ë¬´ìŠ¹ë¶€ë¥¼ í™•ì¸í•œ í›„ ìƒëŒ€ë°©ì˜ í„´ìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤.

ê²Œì„ì˜ ê°œë…ê³¼ ì§„í–‰ì„ **Piece** ë° **Board** í´ë˜ìŠ¤ì— ì‘ì„±í•œë‹¤. ë‘ í´ë˜ìŠ¤ëŠ” ê°ê° í”Œë ˆì´ì–´ì™€ ê²Œì„ íŒì„ ì˜ë¯¸í•œë‹¤.

## ìµœì†ŒìµœëŒ€ ì•Œê³ ë¦¬ì¦˜

<u>minmax.py</u>

```python
from __future__ import annotations
from board import Piece, Board, Move


def minmax(board:Board, 
           maximizing:bool, 
           original_player:Piece, 
           max_depth:int = 8) -> float:
    # ê¸°ì € ì¡°ê±´ - ì¢…ë£Œ ìœ„ì¹˜ ë˜ëŠ” ìµœëŒ€ ê¹Šì´ì— ë„ë‹¬í•œë‹¤.
    if board.is_win or board.is_draw or max_depth == 0:
        return board.evaluate(original_player)

    # ì¬ê·€ ì¡°ê±´ - ìì‹ ì˜ ì´ìµì„ ê·¹ëŒ€í™”í•˜ê±°ë‚˜ ìƒëŒ€ì˜ ì´ìµì„ ìµœì†Œí™”í•œë‹¤.
    # ìµœëŒ€í™” - ê°€ì¥ ë†’ì€ í‰ê°€ë¥¼ ë°›ëŠ” ì›€ì§ì„ì„ ì°¾ëŠ”ë‹¤.
    if maximizing:  
        best_eval:float = float("-inf") # ê°€ì¥ ë‚®ì€ ì ìˆ˜ë¡œ ì‹œì‘
        for move in board.legal_moves:
            result:float = minmax(board.move(move), 
                                  False, 
                                  original_player, 
                                  max_depth - 1)
            best_eval = max(result, best_eval)
        return best_eval
    # ìµœì†Œí™” - ê°€ì¥ ë‚®ì€ í‰ê°€ë¥¼ ë°›ëŠ” ì›€ì§ì„ì„ ì°¾ëŠ”ë‹¤.
    else:
        worst_eval:float = float("inf") # ê°€ì¥ ë†’ì€ ì ìˆ˜ë¡œ ì‹œì‘
        for move in board.legal_moves:
            result = minmax(board.move(move), 
                            True, 
                            original_player, 
                            max_depth - 1)
            worst_eval = min(result, worst_eval)
        return worst_eval
```

ìì‹ ì˜ ì´ë“ì€ ìµœëŒ€í™”í•˜ê³ , ìƒëŒ€ì˜ ì´ë“ì€ ìµœì†Œí™”í•˜ëŠ” ìˆ˜ë¥¼ ì°¾ì•„ì•¼ í•œë‹¤. ìµœì†ŒìµœëŒ€ ì•Œê³ ë¦¬ì¦˜ì€ íƒìƒ‰ ê¹Šì´ë§Œí¼ ì¬ê·€ í˜¸ì¶œì„ ì‚¬ìš©í•˜ë©°, ê° ê¹Šì´ëŠ” **Board** í´ë˜ìŠ¤ì˜ **evaluate()** ë©”ì„œë“œì—ì„œ ì„ ì–¸í•œ ì ìˆ˜ë¥¼ ê°€ì§€ê³  ìˆë‹¤. ê¸°ì € ì¡°ê±´ì— ë„ë‹¬í•  ë•Œê¹Œì§€ í•©ì‚°ëœ ì´ ì ìˆ˜ê°€ ê°€ì¥ ë†’ì€ ê²½ìš°ë¥¼ ë°˜í™˜í•œë‹¤.

## ì•ŒíŒŒë² íƒ€ ê°€ì§€ì¹˜ê¸°

<u>minmax.py</u>

```python
def alphabeta(board:Board, 
              maximizing:bool, 
              original_player:Piece, 
              max_depth:int = 8, 
              alpha:float = float("-inf"), 
              beta:float = float("inf")) -> float:
    if board.is_win or board.is_draw or max_depth == 0:
        return board.evaluate(original_player)

    if maximizing:
        for move in board.legal_moves:
            result: float = alphabeta(board.move(move), 
                                      False, 
                                      original_player, 
                                      max_depth - 1, 
                                      alpha, 
                                      beta)
            alpha = max(result, alpha)
            if beta <= alpha:
                break
        return alpha
    else:
        for move in board.legal_moves:
            result = alphabeta(board.move(move), 
                               True, 
                               original_player, 
                               max_depth - 1, 
                               alpha, 
                               beta)
            beta = min(result, beta)
            if beta <= alpha:
                break
        return beta
```

ìµœì†ŒìµœëŒ€ ì•Œê³ ë¦¬ì¦˜ì—ì„œëŠ” íƒìƒ‰ ê¹Šì´ê°€ ê¹Šì–´ì§ˆìˆ˜ë¡ ë¶ˆí•„ìš”í•œ íƒìƒ‰ì´ ë°œìƒí•œë‹¤. ì´ë¯¸ íƒìƒ‰í•œ ìœ„ì¹˜ë³´ë‹¤ ë‚®ì€ ì ìˆ˜ë¥¼ ê°€ì§„ íƒìƒ‰ ìœ„ì¹˜ë¥¼ ì œê±°(ê°€ì§€ì¹˜ê¸°)í•œë‹¤ë©´, ë³´ë‹¤ íš¨ìœ¨ì ì¸ íƒìƒ‰ ê³¼ì •ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤. 

**ì•ŒíŒŒ**ëŠ” í˜„ì¬ê¹Œì§€ ë°œê²¬ëœ ìì‹ ì˜ ìµœê³ ì˜ ìµœëŒ€í™” ì›€ì§ì„ í‰ê°€ë¥¼ ë‚˜íƒ€ë‚´ë©°, **ë² íƒ€**ëŠ” í˜„ì¬ê¹Œì§€ ë°œê²¬ëœ ìƒëŒ€ì˜ ìµœê³ ì˜ ìµœì†Œí™” ì›€ì§ì„ í‰ê°€ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤. ë² íƒ€ê°€ ì•ŒíŒŒë³´ë‹¤ í¬ì§€ ì•Šë‹¤ë©´ í•´ë‹¹ íƒìƒ‰ì€ ë¬´ì˜ë¯¸í•˜ë¯€ë¡œ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ ì œì™¸ì‹œí‚¨ë‹¤.

## ìµœì ì˜ ìˆ˜ ì°¾ê¸°

<u>minmax.py</u>

```python
def find_best_move(board:Board, max_depth:int = 8) -> Move:
    best_eval:float = float("-inf")
    best_move:Move = Move(-1)
    for move in board.legal_moves:
        result:float = alphabeta(board.move(move), False, board.turn, max_depth)
        if result > best_eval:
            best_eval = result
            best_move = move
    return best_move
```

ë³´ë‹¤ íš¨ìœ¨ì ì¸ ì•ŒíŒŒë² íƒ€ ê°€ì§€ì¹˜ê¸°ë¥¼ ì‚¬ìš©í•œë‹¤.

---

# ì ìš©: í‹±íƒí† 

<u>tictactoe.py</u>

```python
#   0 | 1 | 2
# ----+---+----
#   3 | 4 | 5
# ----+---+----
#   6 | 7 | 8

from __future__ import annotations
from typing import List
from enum import Enum
from board import Piece, Board, Move


class TTTPiece(Piece, Enum):
    X = "X"
    O = "O"
    E = " "

    @property
    def opposite(self) -> TTTPiece:
        if self == TTTPiece.X:
            return TTTPiece.O
        elif self == TTTPiece.O:
            return TTTPiece.X
        else:
            return TTTPiece.E

    def __str__(self) -> str:   # repr ì‚¬ìš© X
        return self.value


class TTTBoard(Board):
    def __init__(self, 
                 position:List[TTTPiece] = [TTTPiece.E] * 9,
                 turn:TTTPiece = TTTPiece.X) -> None:
        self.position:List[TTTPiece] = position
        self._turn:TTTPiece = turn

    @property
    def turn(self) -> Piece:
        return self._turn

    def move(self, location:Move) -> Board:
        temp_position:List[TTTPiece] = self.position.copy()
        temp_position[location] = self._turn
        return TTTBoard(temp_position, self._turn.opposite)

    @property
    def legal_moves(self) -> List[Move]:
        return [Move(l) for l in range(len(self.position)) if self.position[l] == TTTPiece.E]

    @property
    def is_win(self) -> bool:
        return self.position[0] == self.position[1] and self.position[0] == self.position[2] and self.position[0] != TTTPiece.E or\
               self.position[3] == self.position[4] and self.position[3] == self.position[5] and self.position[3] != TTTPiece.E or\
               self.position[6] == self.position[7] and self.position[6] == self.position[8] and self.position[6] != TTTPiece.E or\
               self.position[0] == self.position[3] and self.position[0] == self.position[6] and self.position[0] != TTTPiece.E or\
               self.position[1] == self.position[4] and self.position[1] == self.position[7] and self.position[1] != TTTPiece.E or\
               self.position[2] == self.position[5] and self.position[2] == self.position[8] and self.position[2] != TTTPiece.E or\
               self.position[0] == self.position[4] and self.position[0] == self.position[8] and self.position[0] != TTTPiece.E or\
               self.position[2] == self.position[4] and self.position[2] == self.position[6] and self.position[2] != TTTPiece.E

    def evaluate(self, player:Piece) -> float:
        if self.is_win and self.turn == player:
            return -1
        elif self.is_win and self.turn != player:
            return 1
        else:
            return 0

    def __repr__(self) -> str:
        return f"""
        {self.position[0]}|{self.position[1]}|{self.position[2]}
        -----
        {self.position[3]}|{self.position[4]}|{self.position[5]}
        -----
        {self.position[6]}|{self.position[7]}|{self.position[8]}
        """
```

í‹±íƒí†  ê²Œì„ì—ì„œ í”Œë ˆì´ì–´ëŠ” X ë˜ëŠ” Oì˜ ë§ì„ ê°€ì§€ê³  ì‹œì‘í•œë‹¤. 3 x 3 í¬ê¸°ì˜ ê²Œì„ íŒì—ì„œ ê°€ë¡œ, ì„¸ë¡œ, ëŒ€ê°ì„  ê´€ê³„ ì—†ì´ í•œ ì¤„ì„ ë§Œë“¤ë©´ ìŠ¹ë¦¬í•˜ë©°, ë¹„ì–´ ìˆëŠ” ìœ„ì¹˜ë¼ë©´ ì–´ë””ë“  ë§ì„ ë†“ì„ ìˆ˜ ìˆì„ ìˆ˜ ìˆë‹¤.

<u>tictactoe_ai.py</u>

```python
from minmax import find_best_move
from tictactoe import TTTBoard
from board import Move, Board

board:Board = TTTBoard()


def get_player_move() -> Move:
    player_move:Move = Move(-1)
    while player_move not in board.legal_moves:
        play:int = int(input("ì´ë™í•  ìœ„ì¹˜ë¥¼ ì…ë ¥í•˜ì„¸ìš” (0-8): "))
        player_move = Move(play)
    return player_move


if __name__ == "__main__":
    while True:
        human_move:Move = get_player_move()
        board = board.move(human_move)
        if board.is_win:
            print("ë‹¹ì‹ ì´ ì´ê²¼ìŠµë‹ˆë‹¤!")
            break
        elif board.is_draw:
            print("ë¹„ê²¼ìŠµë‹ˆë‹¤!")
            break
        computer_move:Move = find_best_move(board)
        print(f"ì»´í“¨í„°ê°€ {computer_move}(ìœ¼)ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.")
        board = board.move(computer_move)
        print(board)
        if board.is_win:
            print("ì»´í“¨í„°ê°€ ì´ê²¼ìŠµë‹ˆë‹¤!")
            break
        elif board.is_draw:
            print("ë¹„ê²¼ìŠµë‹ˆë‹¤!")
            break
```

---

# ì ìš©: ì»¤ë„¥íŠ¸í¬

<u>connectfour.py</u>

```python
# â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡
# â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡
# â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡
# â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡
# â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡
# â–¡ â–¡ â–¡ â–¡ â–¡ â–¡ â–¡

from __future__ import annotations
from typing import List, Optional, Tuple
from enum import Enum
from board import Piece, Board, Move


class C4Piece(Piece, Enum):
    B = "B"
    R = "R"
    E = " "

    @property
    def opposite(self) -> C4Piece:
        if self == C4Piece.B:
            return C4Piece.R
        elif self == C4Piece.R:
            return C4Piece.B
        else:
            return C4Piece.E
    
    def __str__(self) -> str:
        return self.value


def generate_segments(num_columns:int,
                      num_rows:int,
                      segment_length:int):

    # ì„¸ê·¸ë¨¼íŠ¸ - ë„¤ ê°œì˜ ê²©ì ìœ„ì¹˜ ë¦¬ìŠ¤íŠ¸
    # ì„¸ê·¸ë¨¼íŠ¸ê°€ ëª¨ë‘ ê°™ì€ ìƒ‰ì´ë©´ í•´ë‹¹ ìƒ‰ì˜ í”Œë ˆì´ì–´ê°€ ìŠ¹ë¦¬
    # ìˆ˜ì§ ì„¸ê·¸ë¨¼íŠ¸ ìƒì„±
    segments:List[List[Tuple[int, int]]] = []
    for c in range(num_columns):
        for r in range(num_rows - segment_length + 1):
            segment:List[Tuple[int, int]] = []
            for t in range(segment_length):
                segment.append((c, r + t))
            segments.append(segment)
    
    # ìˆ˜í‰ ì„¸ê·¸ë¨¼íŠ¸ ìƒì„±
    for c in range(num_columns - segment_length + 1):
        for r in range(num_rows):
            segment = []
            for t in range(segment_length):
                segment.append((c + t, r))
            segments.append(segment)

    # ëŒ€ê°ì„  ì„¸ê·¸ë¨¼íŠ¸ ìƒì„± (ì™¼ìª½ ì•„ë˜ -> ì˜¤ë¥¸ìª½ ìœ„)
    for c in range(num_columns - segment_length + 1):
        for r in range(num_rows - segment_length + 1):
            segment = []
            for t in range(segment_length):
                segment.append((c + t, r + t))
            segments.append(segment)
    
    # ëŒ€ê°ì„  ì„¸ê·¸ë¨¼íŠ¸ ìƒì„± (ì™¼ìª½ ìœ„ -> ì˜¤ë¥¸ìª½ ì•„ë˜)
    for c in range(num_columns - segment_length + 1):
        for r in range(segment_length - 1, num_rows):
            segment = []
            for t in range(segment_length):
                segment.append((c + t, r - t))
            segments.append(segment)

    return segments


class C4Board(Board):
    NUM_ROWS:int = 6
    NUM_COLUMNS:int = 7
    SEGMENT_LENGTH:int = 4
    SEGMENTS:List[List[Tuple[int, int]]] = generate_segments(NUM_COLUMNS, NUM_ROWS, SEGMENT_LENGTH)

    class Column:
        def __init__(self) -> None:
            self._container:List[C4Piece] = []

        @property
        def full(self) -> bool:
            return len(self._container) == C4Board.NUM_ROWS

        def push(self, item:C4Piece) -> None:
            if self.full:
                raise OverflowError("ê²©ì ì—´ ë²”ìœ„ì— ë²—ì–´ë‚  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            self._container.append(item)

        def __getitem__(self, index:int) -> C4Piece:
            if index > len(self._container) - 1:
                return C4Piece.E
            return self._container[index]

        def __repr__(self) -> str:
            return repr(self._container)

        def copy(self) -> C4Board.Column:
            temp: C4Board.Column = C4Board.Column()
            temp._container = self._container.copy()
            return temp

    def __init__(self, 
                 position:Optional[List[C4Board.Column]] = None,
                 turn:C4Piece = C4Piece.B) -> None:
        if position is None:
            self.position:List[C4Board.Column] = [C4Board.Column() for _ in range(C4Board.NUM_COLUMNS)]
        else:
            self.position = position
        self._turn:C4Piece = turn

    @property
    def turn(self) -> Piece:
        return self._turn

    def move(self, location:Move) -> Board:
        temp_position:List[C4Board.Column] = self.position.copy()
        for c in range(C4Board.NUM_COLUMNS):
            temp_position[c] = self.position[c].copy()
        temp_position[location].push(self._turn)
        return C4Board(temp_position, self._turn.opposite)

    @property
    def legal_moves(self) -> List[Move]:
        return [Move(c) for c in range(C4Board.NUM_COLUMNS) if not self.position[c].full]

    def _count_segment(self, segment:List[Tuple[int, int]]) -> Tuple[int, int]:
        black_count:int = 0
        red_count:int = 0
        for column, row in segment:
            if self.position[column][row] == C4Piece.B:
                black_count += 1
            elif self.position[column][row] == C4Piece.R:
                red_count += 1
        return black_count, red_count

    @property
    def is_win(self) -> bool:
        for segment in C4Board.SEGMENTS:
            black_count, red_count = self._count_segment(segment)
            if black_count == 4 or red_count == 4:
                return True
        return False

    def _evaluate_segment(self, 
                          segment:List[Tuple[int, int]], 
                          player:Piece) -> float:
        black_count, red_count = self._count_segment(segment)
        if red_count > 0 and black_count > 0:
            return 0
        count:int = max(red_count, black_count)
        score:float = 0
        if count == 2:
            score = 1
        elif count == 3:
            score = 100
        elif count == 4:
            score = 1_000_000

        color:C4Piece = C4Piece.B
        if red_count > black_count:
            color = C4Piece.R

        if color != player:
            return -score
        return score

    def evaluate(self, player:Piece) -> float:
        total:float = 0
        for segment in C4Board.SEGMENTS:
            total += self._evaluate_segment(segment, player)
        return total

    def __repr__(self) -> str:
        display:str = ""
        for r in reversed(range(C4Board.NUM_ROWS)):
            display += "|"
            for c in range(C4Board.NUM_COLUMNS):
                display += f"{self.position[c][r]}" + "|"
            display += "\n"
        return display
```

í‹±íƒí†  ê²Œì„ì—ì„œ ê²Œì„ íŒì˜ í¬ê¸°ê°€ 7 x 6ë¡œ ì¦ê°€í–ˆìœ¼ë©°, 4ì¤„(segment)ì„ ì™„ì„±í•´ì•¼ ìŠ¹ë¦¬í•œë‹¤. ë˜í•œ ëª¨ë“  ë¹ˆ ê³µê°„ì´ ì í•©í•œ ê²ƒì€ ì•„ë‹ˆë‹¤. ê° ì—´ì€ ë°”ë‹¥ë¶€í„° ì±„ì›Œì•¼ í•œë‹¤. Moveì˜ ì í•©ì„±ì„ ê²€ì‚¬í•˜ê¸° ìœ„í•´ ë‚´ë¶€ì— **Column** í´ë˜ìŠ¤ë¥¼ ì‘ì„±í•œë‹¤.

<u>connectfour_ai.py</u>

```python
from minmax import find_best_move
from connectfour import C4Board
from board import Move, Board

board:Board = C4Board()


def get_player_move() -> Move:
    player_move:Move = Move(-1)
    while player_move not in board.legal_moves:
        play:int = int(input("ì´ë™í•  ìœ„ì¹˜ë¥¼ ì…ë ¥í•˜ì„¸ìš” (0-6): "))
        player_move = Move(play)
    return player_move


if __name__ == "__main__":
    while True:
        human_move:Move = get_player_move()
        board = board.move(human_move)
        if board.is_win:
            print("ë‹¹ì‹ ì´ ì´ê²¼ìŠµë‹ˆë‹¤!")
            break
        elif board.is_draw:
            print("ë¹„ê²¼ìŠµë‹ˆë‹¤!")
            break
        computer_move:Move = find_best_move(board, 3)
        print(f"ì»´í“¨í„°ê°€ {computer_move}ì—´ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤.")
        board = board.move(computer_move)
        print(board)
        if board.is_win:
            print("ì»´í“¨í„°ê°€ ì´ê²¼ìŠµë‹ˆë‹¤!")
            break
        elif board.is_draw:
            print("ë¹„ê²¼ìŠµë‹ˆë‹¤!")
            break
```

---

# ì—°ìŠµë¬¸ì œ

## ğŸ“ 8-1

1. *Practice question*

   í‹±íƒí† ì— ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•˜ì—¬ **legal_moves**, **is_win**, **is_draw** ì†ì„±ì´ ì˜ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•˜ë¼.

ì•Œê³ ë¦¬ì¦˜ ìˆ˜ì—… ì‹œê°„ì— **assert**ë¬¸(ê°€ì • ì„¤ì •ë¬¸)ì„ ì‚¬ìš©í•œ ì  ìˆë‹¤. ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í•˜ë©´ ì—ëŸ¬ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ì„±ì§ˆì„ ì´ìš©í•˜ë©´ ì£¼ì–´ì§„ ì•Œê³ ë¦¬ì¦˜ì´ ì˜ ì‘ë™í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆë‹¤. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬ì¸ **unittest** ëª¨ë“ˆì€ í…ŒìŠ¤íŠ¸ë¥¼ êµ¬ì„±í•˜ê³  ì‹¤í–‰í•˜ëŠ” ë° í’ë¶€í•œ ë„êµ¬ ëª¨ìŒì„ ì œê³µí•˜ê³  ìˆë‹¤. ì•ì„œ ì‘ì„±í•œ í‹±íƒí†  ê²Œì„ì—ì„œ 3ê°€ì§€ ìƒí™©ì„ í…ŒìŠ¤íŠ¸í•˜ì—¬, ê·¸ë•Œë§ˆë‹¤ ì•Œê³ ë¦¬ì¦˜ì´ ì´ìƒì ì¸ ìˆ˜ë¥¼ ì°¾ëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

> https://docs.python.org/ko/3/library/unittest.html

<u>tictactoe_tests.py</u>

```python
import unittest
from typing import List
from minmax import find_best_move
from tictactoe import TTTPiece, TTTBoard
from board import Move


class TTTMINmaxTestCase(unittest.TestCase):
    # Xê°€ ìŠ¹ë¦¬í•˜ëŠ” ì´ë™
    def test_easy_position(self):
        to_win_easy_position:List[TTTPiece] = [TTTPiece.X, TTTPiece.O, TTTPiece.X,
                                               TTTPiece.X, TTTPiece.E, TTTPiece.O,
                                               TTTPiece.E, TTTPiece.E, TTTPiece.O]
        test_board1:TTTBoard = TTTBoard(to_win_easy_position, TTTPiece.X)
        answer1:Move = find_best_move(test_board1)
        self.assertEqual(answer1, 6)

    # Oì˜ ìŠ¹ë¦¬ë¥¼ ë°©í•´í•˜ëŠ” ì´ë™
    def test_block_position(self):
        to_block_position:List[TTTPiece] = [TTTPiece.X, TTTPiece.E, TTTPiece.E,
                                            TTTPiece.E, TTTPiece.E, TTTPiece.O,
                                            TTTPiece.E, TTTPiece.X, TTTPiece.O]
        test_board2:TTTBoard = TTTBoard(to_block_position, TTTPiece.X)
        answer2:Move = find_best_move(test_board2)
        self.assertEqual(answer2, 2)

    # ë‚¨ì€ ë‘ í„´ì„ ê³ ë ¤í•œ ìµœì„ ì˜ ì´ë™
    def test_hard_position(self):
        to_win_hard_position:List[TTTPiece] = [TTTPiece.X, TTTPiece.E, TTTPiece.E,
                                               TTTPiece.E, TTTPiece.E, TTTPiece.O,
                                               TTTPiece.O, TTTPiece.X, TTTPiece.E]
        test_board3:TTTBoard = TTTBoard(to_win_hard_position, TTTPiece.X)
        answer3:Move = find_best_move(test_board3)
        self.assertEqual(answer3, 1)


if __name__ == "__main__":
    unittest.main()
```

ìœ„ ì½”ë“œëŠ” ì±…ì— ë‚˜ì˜¨ í‹±íƒí†  ê²Œì„ì—ì„œì˜ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ì´ë‹¤. ì´ í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ì„¸ ê°€ì§€ì˜ íŠ¹ì •í•œ ìƒí™©(ë³´ë“œ íŒ)ì´ ì£¼ì–´ì§„ë‹¤. ì´ë²ˆ í„´ì— ìŠ¹ë¦¬í•  ìˆ˜ ìˆë‹¤ë©´ ìŠ¹ë¦¬í•˜ëŠ” ìˆ˜ë¥¼ ë‘ì–´ì•¼ í•œë‹¤. ë‹¤ìŒ í„´ì— ìƒëŒ€ê°€ ìŠ¹ë¦¬í•  ìˆ˜ ìˆì„ ë•Œ, ì´ë¥¼ ë°©í•´í•˜ëŠ” ìˆ˜ë¥¼ ë‘ì–´ì•¼ í•œë‹¤. ì–´ë–¤ ìƒí™©ë„ ì•„ë‹ˆë¼ë©´, ìµœì†ŒìµœëŒ€ ì•Œê³ ë¦¬ì¦˜(ë˜ëŠ” ì•ŒíŒŒë² íƒ€ ê°€ì§€ì¹˜ê¸°)ë¥¼ í†µí•´ íƒìƒ‰ ê¹Šì´ ë‚´ì—ì„œ ê°€ì¥ ìŠ¹ë¦¬ ê°€ëŠ¥ì„±ì´ ë†’ì€ ìˆ˜ë¥¼ ë‘ì–´ì•¼ í•œë‹¤. íœì„ êº¼ë‚´ ì¢…ì´ì— ëª‡ ë²ˆ ë„ì ì—¬ ë³¸ë‹¤ë©´, ìš°ë¦¬ëŠ” ì„¸ ê²½ìš°ì˜ ë‹µì„ ì•Œ ìˆ˜ ìˆë‹¤. ì´ì œ ë‚¨ì€ ê±´ êµ¬í•œ ë‹µì„ **assertEqual** ë©”ì„œë“œì— ì§€ì •í•˜ëŠ” ì¼ ë¿ì´ë‹¤.

> í…ŒìŠ¤íŠ¸ ëŒ€ìƒì´ ë˜ëŠ” ë©”ì„œë“œì˜ ì´ë¦„ì€ ë¬´ì¡°ê±´ testë¡œ ì‹œì‘í•´ì•¼ í•œë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ëŒ€ìƒì—ì„œ ì œì™¸ëœë‹¤.

<u>Terminal</u>

```
...
----------------------------------------------------------------------
Ran 3 tests in 0.003s

OK
```

ëª¨ë“  ì¡°ê±´ì„ ë§Œì¡±í•´ í…ŒìŠ¤íŠ¸ê°€ ì„±ê³µì ìœ¼ë¡œ ëë‚¬ë‹¤ë©´ ìœ„ì™€ ê°™ì€ ê²°ê³¼ê°€ ì¶œë ¥ëœë‹¤. ì´ì œ ë¬¸ì œë¡œ ëŒì•„ê°€ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ë©”ì„œë“œë¥¼ ì¶”ê°€í•œë‹¤(í•„ìëŠ” íŒŒì¼ì„ ë¶„ë¦¬í•˜ì˜€ìŒ).

<u>_practice_question_8_1.py</u>

```python
import unittest
from typing import List
from tictactoe import TTTPiece, TTTBoard
from board import Move


class TTTMoreTest(unittest.TestCase):
    # legal_moves
    def test_legal_moves(self):
        position1:List[TTTPiece] = [
            TTTPiece.X, TTTPiece.O, TTTPiece.X,
            TTTPiece.X, TTTPiece.E, TTTPiece.O,
            TTTPiece.E, TTTPiece.E, TTTPiece.O
        ]
        test_board1:TTTBoard = TTTBoard(position1, TTTPiece.X)
        answer1:List[Move] = test_board1.legal_moves
        self.assertEqual(answer1, [4, 6, 7])

    # is_win
    def test_is_win(self):
        position2:List[TTTPiece] = [
            TTTPiece.E, TTTPiece.X, TTTPiece.E,
            TTTPiece.E, TTTPiece.X, TTTPiece.O,
            TTTPiece.E, TTTPiece.X, TTTPiece.O
        ]
        test_board2:TTTBoard = TTTBoard(position2, TTTPiece.X)
        answer2:Move = test_board2.is_win
        self.assertEqual(answer2, True)

    # is_draw
    def test_is_draw(self):
        position3:List[TTTPiece] = [
            TTTPiece.X, TTTPiece.O, TTTPiece.O,
            TTTPiece.O, TTTPiece.X, TTTPiece.X,
            TTTPiece.X, TTTPiece.X, TTTPiece.O
        ]
        test_board3:TTTBoard = TTTBoard(position3, TTTPiece.X)
        answer3:Move = test_board3.is_draw
        self.assertEqual(answer3, True)


if __name__ == "__main__":
    unittest.main()
```

<u>Terminal</u>

```
...
----------------------------------------------------------------------
Ran 3 tests in 0.001s

OK
```

ì„¸ ì†ì„± ëª¨ë‘ ì˜ ì‘ë™í•œë‹¤.

## ğŸ“ 8-2

1. *Practice question*

   ì»¤ë„¥íŠ¸í¬ì— ëŒ€í•œ ìµœì†ŒìµœëŒ€ ì•Œê³ ë¦¬ì¦˜ì˜ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•˜ë¼.



```python
import unittest
from typing import List
from minmax import find_best_move
from connectfour import C4Piece, C4Board
from board import Move


class C4MINmaxTestCase(unittest.TestCase):
    # Bê°€ ìŠ¹ë¦¬í•˜ëŠ” ì´ë™
    def test_easy_position(self):
        to_win_easy_position:List[C4Board.Column] = [
            C4Board.Column(),
            C4Board.Column(),
            C4Board.Column(),
            C4Board.Column(),
            C4Board.Column(),
            C4Board.Column(),
            C4Board.Column()
        ]
        to_win_easy_position[0].push(C4Piece.B)
        to_win_easy_position[1].push(C4Piece.R)
        to_win_easy_position[0].push(C4Piece.B)
        to_win_easy_position[1].push(C4Piece.R)
        to_win_easy_position[0].push(C4Piece.B)
        to_win_easy_position[1].push(C4Piece.R)
        test_board1:C4Board = C4Board(to_win_easy_position, C4Piece.B)
        answer1:Move = find_best_move(test_board1, 3)
        self.assertEqual(answer1, 0)

    # Rì˜ ìŠ¹ë¦¬ë¥¼ ë°©í•´í•˜ëŠ” ì´ë™
    def test_block_position(self):
        to_block_position:List[C4Board.Column] = [
            C4Board.Column(),
            C4Board.Column(),
            C4Board.Column(),
            C4Board.Column(),
            C4Board.Column(),
            C4Board.Column(),
            C4Board.Column()
        ]
        to_block_position[0].push(C4Piece.B)
        to_block_position[1].push(C4Piece.R)
        to_block_position[0].push(C4Piece.B)
        to_block_position[1].push(C4Piece.R)
        to_block_position[2].push(C4Piece.B)
        to_block_position[1].push(C4Piece.R)
        test_board2:C4Board = C4Board(to_block_position, C4Piece.B)
        answer2:Move = find_best_move(test_board2, 3)
        self.assertEqual(answer2, 1)


if __name__ == "__main__":
    unittest.main()
```

| Bê°€ ìŠ¹ë¦¬í•˜ëŠ” ì´ë™ | Rì˜ ìŠ¹ë¦¬ë¥¼ ë°©í•´í•˜ëŠ” ì´ë™ |
| ----------------- | ------------------------ |
|                   |                          |



## ğŸ“ 8-3

1. *Practice question*

   **tictactoe_ai.py**ì™€ **connectfour_ai.py**ì˜ ì½”ë“œëŠ” ê±°ì˜ ë¹„ìŠ·í•˜ë‹¤. ì´ ë‘ ì½”ë“œë¥¼ ë‘ ê²Œì„ ëª¨ë‘ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ë‘ ë©”ì„œë“œë¡œ ì‘ì„±í•˜ì—¬ ë¦¬íŒ©í† ë§í•˜ë¼.



## ğŸ“ 8-4

1. *Practice question*

   ì»´í“¨í„° í”Œë ˆì´ì–´ê°€ ìì‹ ê³¼ ê²Œì„í•  ìˆ˜ ìˆë„ë¡ **connectfour_ai.py** ì½”ë“œë¥¼ ë³€ê²½í•´ë³´ì. ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ì™€ ë‘ ë²ˆì§¸ í”Œë ˆì´ì–´ ì¤‘ ëˆ„ê°€ ë” ë§ì´ ì´ê¸°ëŠ”ê°€? ë§¤ë²ˆ ê°™ì€ ì„ ìˆ˜ê°€ ì´ê¸°ëŠ”ê°€?

<u>connectfour.py</u>

```python
class C4Piece(Piece, Enum):
    B = "â– "
    R = "â–¡"
    E = " "
```

ê²Œì„ ì§„í–‰ì„ ë³´ê¸° í¸í•˜ë„ë¡ Bì™€ R ëŒ€ì‹  ë³´ë‹¤ ì§ê´€ì ì¸ ê¸°í˜¸ë¥¼ ì‚¬ìš©í–ˆë‹¤. 

<u>_practice_question_8_4.py</u>

```python
...

if __name__ == "__main__":
    while True:
        player1_move:Move = find_best_move(board, 3)
        print(f"Player1ì´(ê°€) {player1_move}ì—´ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤.")
        board = board.move(player1_move)
        print(board)
        if board.is_win:
            print("Player1ì´(ê°€) ì´ê²¼ìŠµë‹ˆë‹¤!")
            break
        elif board.is_draw:
            print("ë¹„ê²¼ìŠµë‹ˆë‹¤!")
            break
        player2_move:Move = find_best_move(board, 3)
        print(f"Player2ì´(ê°€) {player2_move}ì—´ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤.")
        board = board.move(player2_move)
        print(board)
        if board.is_win:
            print("Player2ì´(ê°€) ì´ê²¼ìŠµë‹ˆë‹¤!")
            break
        elif board.is_draw:
            print("ë¹„ê²¼ìŠµë‹ˆë‹¤!")
            break
```

<u>Terminal</u>

```
Player1ì´(ê°€) 2ì—´ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤.
| | | | | | | |
| | | | | | | |
| | | | | | | |
| | | | | | | |
| | | | | | | |
| | |â– | | | | |

...

Player2ì´(ê°€) 5ì—´ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤.
|â–¡|â–¡|â– |â–¡|â–¡|â–¡|â–¡|
|â–¡|â– |â– |â–¡|â– |â– |â– |
|â– |â–¡|â–¡|â–¡|â– |â–¡|â–¡|
|â–¡|â– |â– |â– |â–¡|â– |â– |
|â– |â–¡|â–¡|â– |â– |â–¡|â–¡|
|â–¡|â– |â– |â– |â–¡|â– |â– |

Player2ì´(ê°€) ì´ê²¼ìŠµë‹ˆë‹¤!
```

ë‘ í”Œë ˆì´ì–´ì˜ **max_depth**ê°€ ê°™ì€ ê²½ìš°(3) í•­ìƒ ë˜‘ê°™ì€ ì§„í–‰ìœ¼ë¡œ Player2ê°€ ìŠ¹ë¦¬í•œë‹¤. í•˜ì§€ë§Œ Player1ì˜ max_depthë¥¼ 4ë¡œ ì¦ê°€ì‹œí‚¤ë©´ ìµœì ì˜ ì´ë™ì„ ê³„ì‚°í•˜ëŠ” ê³¼ì •ì—ì„œ ë” ë§ì€ ì—°ì‚° ê³¼ì •ì„ ê±°ì¹˜ë¯€ë¡œ Player1ì´ ìŠ¹ë¦¬í•  ìˆ˜ ìˆë‹¤.

## ğŸ“ 8-5

1. *Practice question*

   **connectfour_ai.py**ì—ì„œ í‰ê°€ ë°©ë²•ì„ ìµœì í™”í•˜ì—¬ ê°™ì€ ì‹œê°„ ë‚´ì— ë” ë†’ì€ íƒìƒ‰ ê¸¸ì´ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ë°©ë²•ì„ ì°¾ì•„ë³´ë¼(ê¸°ì¡´ ì½”ë“œë¥¼ í”„ë¡œíŒŒì¼ë§í•˜ê±°ë‚˜ ë‹¤ë¥¸ ë°©ë²•ì„ ì‚¬ìš©í•´ë„ ì¢‹ë‹¤).



## ğŸ“ 8-6

1. *Practice question*

   í•©ë²•ì ì¸ ì²´ìŠ¤ ì´ë™ ìƒì„± ë° ì²´ìŠ¤ ê²Œì„ ìƒíƒœ ìœ ì§€ ê´€ë¦¬ë¥¼ ìœ„í•´ ì´ ì¥ì—ì„œ ê°œë°œí•œ **alphabeta()** í•¨ìˆ˜ë¥¼ íŒŒì´ì¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ í•¨ê»˜ ì‚¬ìš©í•˜ì—¬ ì²´ìŠ¤ AIë¥¼ ê°œë°œí•˜ë¼.

â€‹	
