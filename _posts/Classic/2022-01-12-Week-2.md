---
layout: post
title: "Week-2 : ê²€ìƒ‰ ë¬¸ì œ"
meta: "Week-2"
categories: Classic
tags: Python
---

* content
{:toc}
# DNA ê²€ìƒ‰

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-2-1.png?raw=true)

```python
from enum import IntEnum
from typing import Tuple, List

Nucleotide:IntEnum = IntEnum('Nucleotide', ('A', 'C', 'G', 'T'))
Codon = Tuple[Nucleotide, Nucleotide, Nucleotide]
Gene = List[Codon]

gene_str:str = "ACGTGGCTCTCTAACGTACGTACGTACGGGGTTTATATATACCCTAGGACTCCCTTT"
```

- **ë‰´í´ë ˆì˜¤íƒ€ì´ë“œ**(Nucleotide)

  A, C, G, T ì¤‘ í•˜ë‚˜ë¡œ í‘œí˜„í•œë‹¤.

> *Note*
>
> **Enum** ëª¨ë“ˆì„ ì‚¬ìš©í•´ íŒŒì´ì¬ì—ì„œë„ ì—´ê±° íƒ€ì…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

- **ì½”ëˆ**(Codon)

  ì„¸ ê°œì˜ ë‰´í´ë ˆì˜¤íƒ€ì´ë“œë¡œ êµ¬ì„±ëœë‹¤.

- **ìœ ì „ì**(Gene)

  ë‹¤ìˆ˜ì˜ ì½”ëˆìœ¼ë¡œ êµ¬ì„±ëœë‹¤. 

> *Note*
>
> **íƒ€ì… ì•¨ë¦¬ì–´ìŠ¤**(Type alias)ë¥¼ ì‚¬ìš©í•´ ê¸´ íƒ€ì…ëª… ëŒ€ì‹  ì§§ì€ ë³„ì¹­ì„ ì§€ì •í•¨ìœ¼ë¡œì¨, íƒ€ì… íŒíŠ¸ê°€ ê¸¸ì–´ì§ˆ ë•Œ ë°œìƒí•˜ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ Codonì€ 3ê°œì˜ Nucleotideë¡œ êµ¬ì„±ëœ Tuple íƒ€ì…ì´ë¯€ë¡œ Tuple[Nucleotide, Nucleotide, Nucleotide]ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ê¸´ íƒ€ì…ëª…ì€ ë³€ìˆ˜ ì„ ì–¸ ê³¼ì •ì´ ë²ˆê±°ë¡œìš¸ ë¿ ì•„ë‹ˆë¼ ì½”ë“œì˜ ì§ê´€ì„±ê³¼ ê°„ê²°ì„±ì„ í•´ì¹˜ë¯€ë¡œ Codonì´ë¼ê³  ì¤„ì—¬ í‘œí˜„í•œë‹¤.

```python
def string_to_gene(s:str) -> Gene:
    gene:Gene = []
    for i in range(0, len(s), 3):
        if (i + 2) >= len(s):
            return gene
        codon:Codon = (Nucleotide[s[i]]), Nucleotide[s[i+1]], Nucleotide[s[i+2]]
        gene.append(codon)
    return gene

my_gene:Gene = string_to_gene(gene_str)
```

ê²€ìƒ‰ ì‘ì—…ì„ ì‹œí–‰í•˜ê¸° ì•ì„œ ë‰´í´ë ˆì˜¤íƒ€ì´ë“œë¡œ êµ¬ì„±ëœ ë¬¸ìì—´ì„ 3ê¸€ìì”© ëŠì–´ì„œ ìœ ì „ìë¥¼ ìƒì„±í•œë‹¤.



## ğŸ’¾ Generic

```python
from __future__ import annotations
from typing import TypeVar, Iterable, Sequence, Generic, List, Callable, Set, Deque, Dict, Any, Optional
from typing_extensions import Protocol
from heapq import heappush, heappop
```

```python
T = TypeVar('T')
C = TypeVar("C", bound="Comparable")
```

```python
class Comparable(Protocol):
    def __eq__(self, other:Any) -> bool:
        ...
    def __lt__(self:C, other:C) -> bool:
        ...
    def __gt__(self:C, other:C) -> bool:
        return (not self < other) and self != other
    def __le__(self:C, other:C) -> bool:
        return self < other or self == other
    def __ge__(self:C, other:C) -> bool:
        return not self < other
```



## ì„ í˜• ê²€ìƒ‰

```python
def linear_contains(gene:Gene, key_codon:Codon) -> bool:
    for codon in gene:
        if codon == key_codon:
            return True
    return False
```

```python
def linear_contains(iterable:Iterable[T], key:T) -> bool:
    for item in iterable:
        if item == key:
            return True
    return False
C = TypeVar("C", bound="Comparable")
```



## ì´ì§„ ê²€ìƒ‰

```python
def binary_contains(gene:Gene, key_codon:Codon) -> bool:
    low:int = 0
    high:int = len(gene) - 1
    while low <= high:
        mid:int = (low + high) // 2
        if gene[mid] < key_codon:
            low = mid + 1
        elif gene[mid] > key_codon:
            high = mid - 1
        else:
            return True
    return False
```

```python
def binary_contains(sequence:Sequence[C], key:C) -> bool:
    low:int = 0
    high:int = len(sequence) - 1
    while low <= high:
        mid:int = (low + high) // 2
        if sequence[mid] < key:
            low = mid + 1
        elif sequence[mid] > key:
            high= mid - 1
        else:
            return True
        return False
```

---

# ë¯¸ë¡œ ì°¾ê¸°

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-2-2.png?raw=true)



ë¨¼ì € ë¯¸ë¡œ ì°¾ê¸° ì•Œê³ ë¦¬ì¦˜ì— í•„ìš”í•œ ëª¨ë“ˆì„ importí•œë‹¤.

```python
from enum import Enum
from typing import List, NamedTuple, Callable, Optional
import random
from math import sqrt
from generic_search import Node, node_to_path, dfs, bfs, astar
```



```python
class Cell(str, Enum):
    EMPTY   = " "
    BLOCKED = "X"
    START   = "S"
    GOAL    = "G"
    PATH    = "*"

class MazeLocation(NamedTuple):
    row:int
    column:int
```



```python
class Maze:
    def __init__(self, rows:int = 10, columns:int = 10,
                sparseness:float = 0.2,
                start:MazeLocation = MazeLocation(0, 0),
                goal:MazeLocation = MazeLocation(9, 9)) -> None:
        self._rows:int = rows
        self._columns:int = columns
        self.start:MazeLocation = start
        self.goal:MazeLocation = goal
        self._grid:List[List[Cell]] = [[Cell.EMPTY for c in range(columns)] for r in range(rows)]
        self._randomly_fill(rows, columns, sparseness)
        self._grid[start.row][start.column] = Cell.START
        self._grid[goal.row][goal.column] = Cell.GOAL
        
    def _randomly_fill(self, rows:int, columns:int, sparseness:float):
        for row in range(rows):
            for column in range(columns):
                if random.uniform(0, 1.0) < sparseness:
                    self._grid[row][column] = Cell.BLOCKED

    def __repr__(self) -> str:
        output:str = ""
        for row in self._grid:
            output += " ".join([c.value for c in row]) + "\n"
        return output

    def goal_test(self, ml:MazeLocation) -> bool:
        return ml == self.goal

    def successors(self, ml:MazeLocation) -> List[MazeLocation]:
        locations:List[MazeLocation] = []
        if ml.row + 1    < self._rows    and self._grid[ml.row + 1][ml.column] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row + 1, ml.column))
        if ml.row - 1    >= 0            and self._grid[ml.row - 1][ml.column] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row - 1, ml.column))
        if ml.column + 1 < self._columns and self._grid[ml.row][ml.column + 1] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row, ml.column + 1))
        if ml.column - 1 >= 0            and self._grid[ml.row][ml.column - 1] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row, ml.column - 1))
        return locations

    def mark(self, path:List[MazeLocation]):
        for maze_location in path:
            self._grid[maze_location.row][maze_location.column] = Cell.PATH
        self._grid[self.start.row][self.start.column] = Cell.START
        self._grid[self.goal.row][self.goal.column] = Cell.GOAL

    def clear(self, path:List[MazeLocation]):
        for maze_location in path:
            self._grid[maze_location.row][maze_location.column] = Cell.EMPTY
        self._grid[self.start.row][self.start.column] = Cell.START
        self._grid[self.goal.row][self.goal.column] = Cell.GOAL
```



```python
if __name__ == "__main__":
    m:Maze = Maze()
    print(m)
```

```python
S               X  

  X
    X     X       X

          X
X     X
      X       X

    X X X     X   G
```



## ğŸ’¾ Generic

```python
class Node(Generic[T]):
    def __init__(self, state:T, parent:Optional[Node], cost:float = 0.0, heuristic:float = 0.0):
        self.state:T = state
        self.parent:Optional[Node] = parent
        self.cost:float = cost
        self.heuristic:float = heuristic

    def __lt__(self, other:Node) -> bool:
        return (self.cost + self.heuristic) < (other.cost + other.heuristic)
```

```python
def node_to_path(node:Node[T]) -> List[T]:
    path:List[T] = [node.state]
    while node.parent is not None:
        node = node.parent
        path.append(node.state)
    path.reverse()
    return path
```



## ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)

Stackì„ ì‚¬ìš©í•œë‹¤.

```python
class Stack(Generic[T]):
    def __init__(self) -> None:
        self._container:List[T] = []

    @property
    def empty(self) -> bool:
        return not self._container
    def push(self, item:T) -> None:
        self._container.append(item)
    def pop(self) -> T:
        return self._container.pop()
    def __repr__(self) -> str:
        return repr(self._container)
```

> *Note*
>
> **@property**

```python
def dfs(initial:T, 
        goal_test:Callable[[T], bool], 
        successors:Callable[[T], List[T]]) -> Optional[Node[T]]:
    frontier:Stack[Node[T]] = Stack()
    frontier.push(Node(initial, None))
    explored:Set[T] = {initial}

    while not frontier.empty:
        current_node:Node[T] = frontier.pop()
        current_state:T = current_node.state
        if goal_test(current_state):
            return current_node
        for child in successors(current_state):
            if child in explored:
                continue
            explored.add(child)
            frontier.push(Node(child, current_node))
    return None
```



```python
if __name__ == "__main__":
    solution1:Optional[Node[MazeLocation]] = dfs(m.start, m.goal_test, m.successors)
    if solution1 is None: print("ê¹Šì´ ìš°ì„  íƒìƒ‰ìœ¼ë¡œ ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        path1:List[MazeLocation] = node_to_path(solution1)
        m.mark(path1)
        print(m)
        m.clear(path1)
```

```python
S * * * * * * * X
              * *
  X   * * * *   *
    X *   X * * * X
  * * *
  *       X
X * * X
    * X       X
    * * * * * * * *
    X X X     X   G
```



## ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS)

```python
class Queue(Generic[T]):
    def __init__(self) -> None:
        self._container:Deque[T] = Deque()

    @property
    def empty(self) -> bool:
        return not self._container
    def push(self, item:T) -> None:
        self._container.append(item)
    def pop(self) -> T:
        return self._container.popleft()
    def __repr__(self) -> str:
        return repr(self._container)
```



```python
def bfs(initial:T, 
        goal_test:Callable[[T], bool], 
        successors:Callable[[T], List[T]]) -> Optional[Node[T]]:
    frontier:Queue[Node[T]] = Queue()
    frontier.push(Node(initial, None))
    explored:Set[T] = {initial}

    while not frontier.empty:
        current_node:Node[T] = frontier.pop()
        current_state:T = current_node.state
        if goal_test(current_state):
            return current_node
        for child in successors(current_state):
            if child in explored:
                continue
            explored.add(child)
            frontier.push(Node(child, current_node))
    return None
```



```python
if __name__ == "__main__":
    solution2:Optional[Node[MazeLocation]] = bfs(m.start, m.goal_test, m.successors)
    if solution2 is None: print("ë„ˆë¹„ ìš°ì„  íƒìƒ‰ìœ¼ë¡œ ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        path2:List[MazeLocation] = node_to_path(solution2)
        m.mark(path2)
        print(m)
        m.clear(path2)
```



```python
S               X
*
* X
*   X     X       X
*
* *       X
X *   X
  *   X       X
  * * * * * * * *
    X X X     X * G
```



## A* ì•Œê³ ë¦¬ì¦˜

```python
class PriorityQueue(Generic[T]):
    def __init__(self) -> None:
        self._container: List[T] = []
    
    @property
    def empty(self) -> bool:
        return not self._container
    def push(self, item:T) -> None:
        heappush(self._container, item)
    def pop(self) -> T:
        return heappop(self._container)
    def __repr__(self) -> str:
        return repr(self._container)
```



```python
def astar(initial:T, 
          goal_test:Callable[[T], bool], 
          successors:Callable[[T], List[T]], 
          heuristic:Callable[[T], float]) -> Optional[Node[T]]:
    frontier:PriorityQueue[Node[T]] = PriorityQueue()
    frontier.push(Node(initial, None, 0.0, heuristic(initial)))
    explored:Dict[T, float] = {initial: 0.0}

    while not frontier.empty:
        current_node:Node[T] = frontier.pop()
        current_state:T = current_node.state
        if goal_test(current_state):
            return current_node
        for child in successors(current_state):
            new_cost:float = current_node.cost + 1
            if child not in explored or explored[child] > new_cost:
                explored[child] = new_cost
                frontier.push(Node(child, current_node, new_cost, heuristic(child)))
    return None
```

```python
# ë§¨í•´íŠ¼ ê±°ë¦¬
def manhattan_distance(goal:MazeLocation) -> Callable[[MazeLocation], float]:
    def distance(ml:MazeLocation) -> float:
        xdist:int = abs(ml.column - goal.column)
        ydist:int = abs(ml.row - goal.row)
        return (xdist + ydist)
    return distance
```

```python
# ìœ í´ë¦¬ë“œ ê±°ë¦¬
def euclidean_distance(goal:MazeLocation) -> Callable[[MazeLocation], float]:
    def distance(ml:MazeLocation) -> float:
        xdist:int = ml.column - goal.column
        ydist:int = ml.row - goal.row
        return sqrt((xdist * xdist) + (ydist * ydist))
    return distance
```

> *Note*
>
> í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/distance-1.png?raw=true)

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/distance-2.png?raw=true)

```python
if __name__ == "__main__":
    distance:Callable[[MazeLocation], float] = manhattan_distance(m.goal)
    solution3:Optional[Node[MazeLocation]] = astar(m.start, m.goal_test, m.successors, distance)
    if solution3 is None: print("A* ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        path3:List[MazeLocation] = node_to_path(solution3)
        m.mark(path3)
        print(m)
```

```python
S               X
*
* X
*   X     X       X
* *
  * * * * X
X     X * * * * * *
      X       X   *
                  *
    X X X     X   G
```



---

# ì„ êµì‚¬ì™€ ì‹ì¸ì¢…

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-2-3.png?raw=true)

```python
from __future__ import annotations
from typing import List, Optional
from generic_search import bfs, Node, node_to_path

MAX_NUM:int = 3

class MCState:
    def __init__(self, missionaries:int, cannibals:int, boat:bool) -> None:
        self.wm:int = missionaries
        self.wc:int = cannibals
        self.em:int = MAX_NUM - self.wm
        self.ec:int = MAX_NUM - self.wc
        self.boat:bool = boat

    def __repr__(self) -> str:
        return (f"ì„œìª½ ê°•ë‘‘ì—ëŠ” {self.wm}ëª…ì˜ ì„ êµì‚¬ì™€ {self.wc}ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.\n"
                f"ë™ìª½ ê°•ë‘‘ì—ëŠ” {self.em}ëª…ì˜ ì„ êµì‚¬ì™€ {self.ec}ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.\n"
                f"ë°°ëŠ” {'ì„œ' if self.boat else 'ë™'}ìª½ì— ìˆë‹¤.")
    
    def goal_test(self) -> bool:
        return self.is_legal and self.em == MAX_NUM and self.ec == MAX_NUM

    @property
    def is_legal(self) -> bool:
        if self.wm < self.wc and self.wm > 0:
            return False
        if self.em < self.ec and self.em > 0:
            return False
        return True

    def successors(self) -> List[MCState]:
        sucs:List[MCState] = []
        if self.boat:   # ì„œìª½ ê°•ë‘‘ì— ìˆëŠ” ë°°
            if self.wm > 1:
                sucs.append(MCState(self.wm - 2, self.wc, not self.boat))
            if self.wm > 0:
                sucs.append(MCState(self.wm - 1, self.wc, not self.boat))
            if self.wc > 1:
                sucs.append(MCState(self.wm, self.wc - 2, not self.boat))
            if self.wc > 0:
                sucs.append(MCState(self.wm, self.wc - 1, not self.boat))
            if (self.wc > 0) and (self.wm > 0):
                sucs.append(MCState(self.wm - 1, self.wc - 1, not self.boat))
        else:           # ë™ìª½ ê°•ë‘‘ì— ìˆëŠ” ë°°
            if self.em > 1:
                sucs.append(MCState(self.wm + 2, self.wc, not self.boat))
            if self.em > 0:
                sucs.append(MCState(self.wm + 1, self.wc, not self.boat))
            if self.ec > 1:
                sucs.append(MCState(self.wm, self.wc + 2, not self.boat))
            if self.ec > 0:
                sucs.append(MCState(self.wm, self.wc + 1, not self.boat))
            if (self.ec > 0) and (self.em > 0):
                sucs.append(MCState(self.wm + 1, self.wc + 1, not self.boat))
        return [x for x in sucs if x.is_legal]
```

```python
def display_solution(path:List[MCState]):
    if len(path) == 0:
        return
    old_state:MCState = path[0]
    print(old_state)
    for current_state in path[1:]:
        if current_state.boat:
            print("{}ëª…ì˜ ì„ êµì‚¬ì™€ {}ëª…ì˜ ì‹ì¸ì¢…ì´ ë™ìª½ ê°•ë‘‘ì—ì„œ ì„œìª½ ê°•ë‘‘ìœ¼ë¡œ ê°”ë‹¤.\n"
                  .format(old_state.em - current_state.em, old_state.ec - current_state.ec))
        else:
            print("{}ëª…ì˜ ì„ êµì‚¬ì™€ {}ëª…ì˜ ì‹ì¸ì¢…ì´ ë™ìª½ ê°•ë‘‘ì—ì„œ ì„œìª½ ê°•ë‘‘ìœ¼ë¡œ ê°”ë‹¤.\n"
                  .format(old_state.wm - current_state.wm, old_state.wc - current_state.wc))
        print(current_state)
        old_state = current_state
```

```python
if __name__ == "__main__":
    start:MCState = MCState(MAX_NUM, MAX_NUM, True)
    solution:Optional[Node[MCState]] = bfs(start, MCState.goal_test, MCState.successors)
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    else:
        path:List[MCState] = node_to_path(solution)
        display_solution(path)
```

