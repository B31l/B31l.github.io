---
layout: post
meta: "Week-9"
title: "Week-9: 기타 문제"
categories: Classic
tags: Python
mathjax: true
---

* content
{:toc}
# 배낭 문제

<u>knapsack.py</u>

```python
from tokenize import Name
from typing import NamedTuple, List


class Item(NamedTuple):
    name:str
    weight:int
    value:float


def knapsack(items:List[Item], max_capacity:int) -> List[Item]:
    table:List[List[float]] = [[0.0 for _ in range(max_capacity + 1)] for _ in range(len(items) + 1)]
    for i, item in enumerate(items):
        for capacity in range(1, max_capacity + 1):
            previous_items_value:float = table[i][capacity]
            if capacity >= item.weight:
                value_freeing_weight_for_item:float = table[i][capacity - item.weight]
                table[i + 1][capacity] = max(value_freeing_weight_for_item + item.value, previous_items_value)
            else:
                table[i + 1][capacity] = previous_items_value
    solution:List[Item] = []
    capacity = max_capacity
    for i in range(len(items), 0, -1):
        if table[i - 1][capacity] != table[i][capacity]:
            solution.append(items[i - 1])
            capacity -= items[i - 1].weight
    return solution


if __name__ == "__main__":
    items:List[Item] = [Item("TV", 50, 500),
                        Item("촛대", 2, 300),
                        Item("오디오", 35, 400),
                        Item("노트북", 3, 1000),
                        Item("식량", 15, 50),
                        Item("옷", 20, 800),
                        Item("보석", 1, 4000),
                        Item("책", 100, 300),
                        Item("프린터", 18, 30),
                        Item("냉장고", 200, 700),
                        Item("그림", 10, 1000)]
    print(knapsack(items, 75))
```



<u>Terminal</u>

```
[Item(name='그림', weight=10, value=1000), Item(name='보석', weight=1, value=4000), Item(name='옷', weight=20, value=800), Item(name='노트북', weight=3, value=1000), Item(name='오디오', weight=35, value=400), Item(name='촛대', weight=2, value=300)]
```



---

# 외판원 문제

<u>tsp.py</u>

```python
from typing import Dict, List, Iterable, Tuple
from itertools import permutations


vt_distances:Dict[str, Dict[str, int]] = {
    "러틀랜드": {
        "벌링턴": 67,
        "화이트 리버 정션": 46,
        "베닝턴": 55,
        "브래틀보로": 75
    },
    "벌링턴": {
        "러틀랜드": 67,
        "화이트 리버 정션": 91,
        "베닝턴": 122,
        "브래틀보로": 153
    },
    "화이트 리버 정션": {
        "러틀랜드": 46,
        "벌링턴": 91,
        "베닝턴": 98,
        "브래틀보로": 65
    },
    "베닝턴": {
        "러틀랜드": 55,
        "벌링턴": 122,
        "화이트 리버 정션": 98,
        "브래틀보로": 40
    },
    "브래틀보로": {
        "러틀랜드": 75,
        "벌링턴": 153,
        "화이트 리버 정션": 65,
        "베닝턴": 40
    }
}


vt_cities:Iterable[str] = vt_distances.keys()
city_permutations:Iterable[Tuple[str, ...]] = permutations(vt_cities)
tsp_paths:List[Tuple[str, ...]] = [c + (c[0],) for c in city_permutations]


if __name__ == "__main__":
    best_path:Tuple[str, ...]
    min_distance:int = 99999999999
    for path in tsp_paths:
        distance:int = 0
        last:str = path[0]
        for next in path[1:]:
            distance += vt_distances[last][next]
            last = next
        if distance < min_distance:
            min_distance = distance
            best_path = path
    print(f"최단 경로는 {best_path}이고, {min_distance} 마일입니다.")
```



<u>Terminal</u>

```
최단 경로는 ('러틀랜드', '벌링턴', '화이트 리버 정션', '브래틀보로', '베닝턴', '러틀랜드')이고, 318 마일입니다.
```



---

# 전화번호 니모닉

<u>phone_number_mnemonics.py</u>

```python
from typing import Dict, Tuple, Iterable, List
from itertools import product


phone_mapping:Dict[str, Tuple[str, ...]] = {
    "1": ("1",),
    "2": ("a", "b", "c"),
    "3": ("d", "e", "f"),
    "4": ("g", "h", "i"),
    "5": ("j", "k", "l"),
    "6": ("m", "n", "o"),
    "7": ("p", "q", "r", "s"),
    "8": ("t", "u", "v"),
    "9": ("w", "x", "y", "z"),
    "0": ("0",),
}


def possible_mnemonics(phone_number:str) -> Iterable[Tuple[str, ...]]:
    letter_tuples:List[Tuple[str, ...]] = []
    for digit in phone_number:
        letter_tuples.append(phone_mapping.get(digit, (digit,)))
    return product(*letter_tuples)


if __name__ == "__main__":
    phone_number:str = input("전화번호를 입력해주세요: ")
    print("가능한 니모닉 목록: ")
    for mnemonic in possible_mnemonics(phone_number):
        print("".join(mnemonic))
```



<u>Terminal</u>

```
전화번호를 입력해주세요: 2024738
가능한 니모닉 목록: 
a0agpdt
a0agpdu

...

c0cisfu
c0cisfv
```



---

# 연습문제

## 📝 9-1

1. *Practice question*

   4장의 그래프 프렐임워크를 사용하여 외판원 문제 코드를 다시 작성하라.





## 📝 9-2

1. *Practice question*

   5장에서 배운 유전 알고리즘을 사용하여 외판원 문제를 구현하라. 이 장에서 설명한 버몬트 주 도시의 간단한 데이터셋부터 시작한다. 유전 알고리즘이 짧은 시간 내에 최적의 답을 제공하는가? 그런 다음 점점 더 많은 도시를 추가하여 문제를 풀어보라. 유전 알고리즘은 얼마나 잘 유지되는가? 인터넷에서 외판원 문제를 위해 특별히 제작된 많은 데이터셋을 찾을 수 있다. 문제 분석의 효율성을 확인하기 위한 테스트 프레임워크를 구현하라.





## 📝 9-3

1. *Practice question*

   전화번호 니모닉 프로그램에 사전 기능을 추가하여 유효한 단어가 포함된 순열만 반환하라.





