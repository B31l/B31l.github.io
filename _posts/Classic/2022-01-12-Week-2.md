---
layout: post
title: "Week-2 : ê²€ìƒ‰ ë¬¸ì œ"
meta: "Week-2"
categories: Classic
tags: Python
---

* content
{:toc}
# ì„œë¡ 

ì„¸ ê°œì˜ ë¬¸ì œì— ì‚¬ìš©ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì€ ì œë„¤ë¦­ í”„ë¡œê·¸ë˜ë° ê¸°ë²•ì„ í†µí•´ ì¼ë°˜í™”í•œ ë’¤ ê´‘ë²”ìœ„í•œ ë¬¸ì œì— ì ìš©í•  ìˆ˜ ìˆë‹¤. ì•Œê³ ë¦¬ì¦˜ì€ generic_search íŒŒì¼ì— ì €ì¥í•œë‹¤.

ë³¸ ë¬¸ì„œì—ì„œ ì œë„¤ë¦­ í”„ë¡œê·¸ë˜ë°ì„ ì‚¬ìš©í•œ ì±•í„°ëŠ” ğŸ’¾ë¥¼, ì—°ìŠµë¬¸ì œë¥¼ í‘¼ ì±•í„°ëŠ” ğŸ“ì„ í‘œì‹œí–ˆë‹¤.

ì‹œì‘í•˜ê¸° ì•ì„œ ë‹¤ìŒ ëª¨ë“ˆì„ importí•´ íƒ€ì… íŒíŠ¸ì™€ í™ ì‚¬ìš©ì„ ì¤€ë¹„í•œë‹¤.

```python
# import
from __future__ import annotations
from typing import TypeVar, Iterable, Sequence, Generic, List, Callable, Set, Deque, Dict, Any, Optional
from typing_extensions import Protocol
from heapq import heappush, heappop
```

---

# DNA ê²€ìƒ‰

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-2-1.png?raw=true)

```python
# import
from enum import IntEnum
from typing import Tuple, List
```

## DNAì˜ êµ¬ì¡°

- **ë‰´í´ë ˆì˜¤íƒ€ì´ë“œ**(Nucleotide)

  A, C, G, T ì¤‘ í•˜ë‚˜ë¡œ í‘œí˜„í•œë‹¤.

```python
Nucleotide:IntEnum = IntEnum('Nucleotide', ('A', 'C', 'G', 'T'))
```

> *Note*
>
> **Enum** ëª¨ë“ˆì„ ì‚¬ìš©í•´ íŒŒì´ì¬ì—ì„œë„ ì—´ê±° íƒ€ì…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. í›„ìˆ í•  ì´ì§„ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì—ì„œ ë‰´í´ë ˆì˜¤íƒ€ì´ë“œì— ëŒ€í•œ ë¹„êµê°€ ë°œìƒí•˜ë¯€ë¡œ ë¹„êµ ì—°ì‚°ìë¥¼ ì§€ì›í•˜ëŠ” **IntEnum** íƒ€ì…ì„ ì‚¬ìš©í•œë‹¤. 

- **ì½”ëˆ**(Codon)

  ì„¸ ê°œì˜ ë‰´í´ë ˆì˜¤íƒ€ì´ë“œë¡œ êµ¬ì„±ëœë‹¤.

```python
Codon = Tuple[Nucleotide, Nucleotide, Nucleotide]
```

  ![](https://sandbox.dodona.be/en/activities/1424446086/description/Yn99UqMgqip_9ACf/media/codons.png)

  ğŸ›´ <https://dodona.ugent.be/en/activities/1424446086/>

- **ìœ ì „ì**(Gene)

  ë‹¤ìˆ˜ì˜ ì½”ëˆìœ¼ë¡œ êµ¬ì„±ëœë‹¤. 
  
```python
Gene = List[Codon]
```

> *Note*
>
> **íƒ€ì… ì•¨ë¦¬ì–´ìŠ¤**(Type alias)ë¥¼ ì‚¬ìš©í•´ ê¸´ íƒ€ì…ëª… ëŒ€ì‹  ì§§ì€ ë³„ì¹­ì„ ì§€ì •í•¨ìœ¼ë¡œì¨, íƒ€ì… íŒíŠ¸ê°€ ê¸¸ì–´ì§ˆ ë•Œ ë°œìƒí•˜ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ Codonì€ 3ê°œì˜ Nucleotideë¡œ êµ¬ì„±ëœ Tuple íƒ€ì…ì´ë¯€ë¡œ Tuple[Nucleotide, Nucleotide, Nucleotide]ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ê¸´ íƒ€ì…ëª…ì€ ë³€ìˆ˜ ì„ ì–¸ ê³¼ì •ì´ ë²ˆê±°ë¡œìš¸ ë¿ ì•„ë‹ˆë¼ ì½”ë“œì˜ ì§ê´€ì„±ê³¼ ê°„ê²°ì„±ì„ í•´ì¹˜ë¯€ë¡œ Codonìœ¼ë¡œ ì§§ê²Œ í‘œí˜„í•œë‹¤.

ê²€ìƒ‰ ì‘ì—…ì„ ì‹œí–‰í•˜ê¸° ì•ì„œ ì£¼ì–´ì§„ ë‰´í´ë ˆì˜¤íƒ€ì´ë“œë¡œ êµ¬ì„±ëœ ë¬¸ìì—´ì„ 3ê¸€ìì”© ëŠì–´ì„œ ìœ ì „ì ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•œë‹¤.

```python
def string_to_gene(s:str) -> Gene:
    gene:Gene = []
    for i in range(0, len(s), 3):
        if (i + 2) >= len(s):
            return gene
        codon:Codon = (Nucleotide[s[i]]), Nucleotide[s[i+1]], Nucleotide[s[i+2]]
        gene.append(codon)
    return gene

gene_str:str = "ACGTGGCTCTCTAACGTACGTACGTACGGGGTTTATATATACCCTAGGACTCCCTTT"
my_gene:Gene = string_to_gene(gene_str)
```

## ì„ í˜• ê²€ìƒ‰

ìœ ì „ì ë¦¬ìŠ¤íŠ¸ê°€ íŠ¹ì • ì½”ëˆ(Key)ë¥¼ í¬í•¨í•˜ê³  ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ê³¼ì •ì„ **ê²€ìƒ‰**ì´ë¼ê³  í•˜ë©°, ë‘ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

**ì„ í˜• ê²€ìƒ‰**(ë˜ëŠ” ìˆœì°¨ ê²€ìƒ‰)ì€ ìœ ì „ì ë¦¬ìŠ¤íŠ¸ì˜ ëª¨ë“  ì½”ëˆì— ëŒ€í•´ Keyì™€ ë¹„êµí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì´ë£¨ì–´ì§„ë‹¤. ë§Œì•½ ê°’ì´ ê°™ë‹¤ë©´ ê²€ìƒ‰ ì„±ê³µì´ë¯€ë¡œ Trueë¥¼ ë¦¬í„´í•˜ê³ , ê°’ì´ ë‹¤ë¥´ë‹¤ë©´ ë‹¤ìŒ ì½”ëˆìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤. Keyì™€ ê°™ì€ ì½”ëˆì´ í•˜ë‚˜ë„ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ê²€ìƒ‰ ì‹¤íŒ¨ì´ë¯€ë¡œ Falseë¥¼ ë¦¬í„´í•œë‹¤.

ì„ í˜• ê²€ìƒ‰ì€ ë¦¬ìŠ¤íŠ¸ ë‚´ ì›ì†Œì˜ ê°œìˆ˜ê°€ Nì¼ ë•Œ ìµœëŒ€ Në²ˆì˜ ë¹„êµê°€ ì´ë£¨ì–´ì§€ë©°, ë”°ë¼ì„œ **O(N)**ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°–ëŠ”ë‹¤.

```python
def linear_contains(gene:Gene, key_codon:Codon) -> bool:
    for codon in gene:
        if codon == key_codon:
            return True
    return False
```

## ğŸ’¾ ì„ í˜• ê²€ìƒ‰ì˜ ì¼ë°˜í™”

ë°©ê¸ˆ ì‘ì„±í•œ ì•Œê³ ë¦¬ì¦˜ì€ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì—ëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤. ë”°ë¼ì„œ ì¼ë°˜í™” ê³¼ì •ì„ ê±°ì¹˜ëŠ” ê³¼ì •ì´ í•„ìš”í•˜ë‹¤.

| ê¸°ì¡´ ì•Œê³ ë¦¬ì¦˜                                                | ì¼ë°˜í™” ì•Œê³ ë¦¬ì¦˜                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| **ê²€ìƒ‰í•  ê°’: Codon**<br>3ê°œì˜ Nucleotide íƒ€ì…ìœ¼ë¡œ êµ¬ì„±ëœ Tuple íƒ€ì… | **ê²€ìƒ‰í•  ê°’ T**<br>ì‚¬ìš©ì ì •ì˜ íƒ€ì…ìœ¼ë¡œ, ì–´ë–¤ íƒ€ì…ë„ ìƒê´€ì—†ìŒ |
| **ê²€ìƒ‰ì˜ ë²”ìœ„: Gene**<br>Codon íƒ€ì…ìœ¼ë¡œ êµ¬ì„±ëœ List íƒ€ì…     | **ê²€ìƒ‰ì˜ ë²”ìœ„ Iterable[T]**<br>Të¡œ êµ¬ì„±ëœ Iterable(str, list, tuple, dict, set ë“±) íƒ€ì… |

`TypeVar`ì„ ì‚¬ìš©í•´ ì‚¬ìš©ì ì •ì˜ íƒ€ì… `T`ë¥¼ í‘œí˜„í•œë‹¤.

```python
T = TypeVar('T')
```

ì´ì œ Codonê³¼ Geneì„ ê°ê° Tì™€ Iterable[T]ë¡œ ì¹˜í™˜í•´ ì„ í˜• ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ ì¼ë°˜í™”í•œë‹¤. 

```python
def linear_contains(iterable:Iterable[T], key:T) -> bool:
    for item in iterable:
        if item == key:
            return True
    return False
```

## ì´ì§„ ê²€ìƒ‰

ì´ì§„ ê²€ìƒ‰ì€ ìœ ì „ì ë¦¬ìŠ¤íŠ¸ì˜ ì„ì˜ì˜ ì½”ëˆê³¼ Keyì˜ ëŒ€ì†Œ ê´€ê³„ë¥¼ ë¹„êµí•œ ë’¤, íƒìƒ‰ ë²”ìœ„ë¥¼ ì¢íˆëŠ” ë°©ì‹ìœ¼ë¡œ ì´ë£¨ì–´ì§„ë‹¤. ì„ì˜ì˜ ê°’ì´ ì°¾ê³ ì í•˜ëŠ” ê°’ë³´ë‹¤ í¬ë‹¤ë©´ ë” ì‘ì€ ë²”ìœ„ì—ì„œ ì„ì˜ì˜ ê°’ì„ ì¬ì§€ì •í•˜ë©°, ë°˜ëŒ€ë¡œ ì„ì˜ì˜ ê°’ì´ ì°¾ê³ ì í•˜ëŠ” ê°’ë³´ë‹¤ ì‘ë‹¤ë©´ ë” í° ë²”ìœ„ì—ì„œ ì„ì˜ì˜ ê°’ì„ ì¬ì§€ì •í•œë‹¤. ë§Œì•½ ë‘ ê°’ì´ ê°™ë‹¤ë©´ ê²€ìƒ‰ ì„±ê³µì´ë¯€ë¡œ Trueë¥¼ ë¦¬í„´í•˜ê³ , íƒìƒ‰ ë²”ìœ„ë¥¼ ë” ì´ìƒ ì¢íˆì§€ ëª»í•œë‹¤ë©´ ê²€ìƒ‰ ì‹¤íŒ¨ì´ë¯€ë¡œ Falseë¥¼ ë¦¬í„´í•œë‹¤.

ë‹¨, ìœ„ ë°©ë²•ì´ ì„±ë¦½í•˜ê¸° ìœ„í•´ì„œëŠ” ìœ ì „ì ë¦¬ìŠ¤íŠ¸ê°€ ì •ë ¬ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤.

ì´ì§„ ê²€ìƒ‰ì€ ë¦¬ìŠ¤íŠ¸ ë‚´ ì›ì†Œì˜ ê°œìˆ˜ê°€ Nì¼ ë•Œ ìµœëŒ€ logNë²ˆì˜ ë¹„êµê°€ ì´ë£¨ì–´ì§€ë©°, ë”°ë¼ì„œ **O(logN)**ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°–ëŠ”ë‹¤.

```python
def binary_contains(gene:Gene, key_codon:Codon) -> bool:
    low:int = 0
    high:int = len(gene) - 1
    while low <= high:
        mid:int = (low + high) // 2
        if gene[mid] < key_codon:
            low = mid + 1
        elif gene[mid] > key_codon:
            high = mid - 1
        else:
            return True
    return False
```

## ğŸ’¾ ì´ì§„ ê²€ìƒ‰ì˜ ì¼ë°˜í™”

ì„ í˜• ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ì´ì§„ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ ì—­ì‹œ ì¼ë°˜í™”í•  ìˆ˜ ìˆë‹¤.

| ê¸°ì¡´ ì•Œê³ ë¦¬ì¦˜                                                | ì¼ë°˜í™” ì•Œê³ ë¦¬ì¦˜                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| **ê²€ìƒ‰í•  ê°’: Codon**<br>3ê°œì˜ Nucleotide íƒ€ì…ìœ¼ë¡œ êµ¬ì„±ëœ Tuple íƒ€ì… | **ê²€ìƒ‰í•  ê°’ C**<br>ì‚¬ìš©ì ì •ì˜ íƒ€ì…ìœ¼ë¡œ, ë¹„êµ ì—°ì‚°ì„ ì§€ì›í•´ì•¼ í•¨ |
| **ê²€ìƒ‰ì˜ ë²”ìœ„: Gene**<br>Codon íƒ€ì…ìœ¼ë¡œ êµ¬ì„±ëœ List íƒ€ì…     | **ê²€ìƒ‰ì˜ ë²”ìœ„ Sequence[C]**<br>Cë¡œ êµ¬ì„±ëœ Sequence(str, list, tuple) íƒ€ì… |

ì´ì§„ ê²€ìƒ‰ì€ ì„ í˜• ê²€ìƒ‰ê³¼ ë‹¤ë¥´ê²Œ ë¹„êµ ì—°ì‚°ì´ ì´ë£¨ì–´ì§€ë¯€ë¡œ ì´ë¥¼ ì§€ì›í•˜ëŠ” ìƒˆë¡œìš´ ì‚¬ìš©ì ì •ì˜ íƒ€ì…ì„ ë§Œë“¤ì–´ì•¼ í•œë‹¤. ë˜í•œ ê²€ìƒ‰ì˜ ë²”ìœ„ê°€ ì •ë ¬ë˜ì–´ ìˆì–´ì•¼ í•˜ë¯€ë¡œ Iterable ëŒ€ì‹  Sequenceë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

> *Note*
>
> **Sequence** íƒ€ì…ì€ Iterable íƒ€ì… ì¤‘ì—ì„œë„ ìˆœì„œê°€ ìˆëŠ” íƒ€ì…ì„ ì˜ë¯¸í•œë‹¤. ì¦‰, ì¸ë±ì‹±ê³¼ ìŠ¬ë¼ì´ì‹±ì„ ì§€ì›í•´ì•¼ í•œë‹¤. **ì •ë ¬** ì—­ì‹œ ì›ì†Œë¥¼ ìˆœì„œëŒ€ë¡œ ì¬ë°°ì—´í•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ë¯€ë¡œ, ì˜¤ì§ Sequence íƒ€ì…ì—ì„œë§Œ ì§€ì›í•œë‹¤.

`TypeVar`ì„ ì‚¬ìš©í•´ ë¹„êµ ì—°ì‚°ì„ ì§€ì›í•˜ëŠ” ì‚¬ìš©ì ì •ì˜ íƒ€ì… `C`ë¥¼ í‘œí˜„í•œë‹¤.

```python
C = TypeVar("C", bound="Comparable")
```

ë¹„êµ ì—°ì‚°ìë¥¼ êµ¬í˜„í•˜ëŠ” Comparable í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•œë‹¤.

```python
class Comparable(Protocol):
    def __eq__(self, other:Any) -> bool:
        ...
    def __lt__(self:C, other:C) -> bool:
        ...
    def __gt__(self:C, other:C) -> bool:
        return (not self < other) and self != other
    def __le__(self:C, other:C) -> bool:
        return self < other or self == other
    def __ge__(self:C, other:C) -> bool:
        return not self < other
```

ì´ì œ Codonê³¼ Geneì„ ê°ê° Cì™€ Sequence[C]ë¡œ ì¹˜í™˜í•´ ì„ í˜• ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ ì¼ë°˜í™”í•œë‹¤. 

```python
def binary_contains(sequence:Sequence[C], key:C) -> bool:
    low:int = 0
    high:int = len(sequence) - 1
    while low <= high:
        mid:int = (low + high) // 2
        if sequence[mid] < key:
            low = mid + 1
        elif sequence[mid] > key:
            high= mid - 1
        else:
            return True
        return False
```

## ğŸ“ ì—°ìŠµë¬¸ì œ 1

ì´ì§„ ê²€ìƒ‰ì˜ ì‹œê°„ë³µì¡ë„ëŠ” O(logN)ì´ë¯€ë¡œ, O(N)ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§€ëŠ” ì„ í˜• ê²€ìƒ‰ì— ë¹„í•´ í›¨ì”¬ íš¨ìœ¨ì ì´ë‹¤.

| ì„ í˜• ê²€ìƒ‰ | ì´ì§„ ê²€ìƒ‰ |
| --------- | --------- |
| O(N)      | O(logN)   |

ë‘ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì˜ íš¨ìœ¨ ì°¨ì´ë¥¼ ì§ê´€ì ìœ¼ë¡œ ì•Œ ìˆ˜ ìˆë„ë¡ time ëª¨ë“ˆì„ ì‚¬ìš©í•´ íŠ¹ì • ìˆ«ìë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ì¸¡ì •í•œë‹¤.

```python
from generic_search import linear_contains, binary_contains
import time

my_list = [x for x in range(1_000_000)]
test = [55555, 714285, 1000000]
```

1ë¶€í„° 1,000,000ê¹Œì§€ì˜ ìˆ«ìê°€ ìˆœì„œëŒ€ë¡œ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•œ ë’¤, ì„¸ ê°œì˜ ìˆ«ì 55,555, 714,285, 1,000,000ì„ ê²€ìƒ‰í•˜ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ì¸¡ì •í•œë‹¤.

**ì„ í˜• ê²€ìƒ‰**

```python
for i in test:
    start = time.time()
    linear_contains(my_list, i)
    end = time.time()
    print(f"{i}ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : {(end - start) * 1000} ms")
```

```
55555ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 1.9969940185546875 ms
714285ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 21.904706954956055 ms
1000000ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 33.91003608703613 ms
```

**ì´ì§„ ê²€ìƒ‰**

```python
for i in test:
    start = time.time()
    binary_contains(my_list, i)
    end = time.time()
    print(f"{i}ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : {(end - start) * 1000} ms")
```

```
55555ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 0.0 ms  
714285ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 0.0 ms 
1000000ë¥¼ ì°¾ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ : 0.0 ms
```

ì„ í˜• ê²€ìƒ‰ì—ì„œëŠ” Nì´ ìµœëŒ€ 100ë§Œì´ë©°, ìˆ«ìì˜ í¬ê¸°ê°€ ì»¤ì§ˆìˆ˜ë¡ ê²€ìƒ‰ì— í•„ìš”í•œ ë¹„êµ íšŸìˆ˜ê°€ ë§ì•„ì§€ë¯€ë¡œ ê²€ìƒ‰í•˜ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì€ ìˆ«ìì™€ ë¹„ë¡€í•œë‹¤.

ì„ í˜• ê²€ìƒ‰ ì—­ì‹œ ë¹ ë¥¸ ì†ë„ë¡œ ì´ë£¨ì–´ì§€ì§€ë§Œ, ì´ì§„ ê²€ìƒ‰ì—ì„œ logNì€ 20ë„ ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì„ í˜• ê²€ìƒ‰ê³¼ëŠ” ë¹„êµí•  ìˆ˜ ì—†ì„ ì •ë„ë¡œ ë¹ ë¥´ë‹¤.

---

# ë¯¸ë¡œ ì°¾ê¸°

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-2-2.png?raw=true)

```python
# import
from enum import Enum
from typing import List, NamedTuple, Callable, Optional
import random
from math import sqrt
from generic_search import Node, node_to_path, dfs, bfs, astar
```

## ë¯¸ë¡œ ìƒì„±

2ì°¨ì› ê²©ìì˜ ë¯¸ë¡œë¥¼ ìƒì„±í•œ ë’¤, ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë¯¸ë¡œ ì°¾ê¸° ì•Œê³ ë¦¬ì¦˜ì„ ì‘ì„±í•œë‹¤. 

**Cell** í´ë˜ìŠ¤ì—ì„œëŠ” ë¯¸ë¡œì—ì„œì˜ ê° ì¹¸ì˜ ìƒíƒœë¥¼ í‘œì‹œí•œë‹¤.

```python
class Cell(str, Enum):
    EMPTY   = " "
    BLOCKED = "X"
    START   = "S"
    GOAL    = "G"
    PATH    = "*"
```

**MazeLocation** í´ë˜ìŠ¤ì—ì„œëŠ” **ë„¤ì„ë“œíŠœí”Œ**(NamedTuple)ì„ ì‚¬ìš©í•´ ë¯¸ë¡œì—ì„œ ê° ì¹¸ì˜ ìœ„ì¹˜ë¥¼ í–‰ê³¼ ì—´ë¡œ ë‚˜íƒ€ë‚¸ë‹¤.

```python
class MazeLocation(NamedTuple):
    row:int
    column:int
```

**Maze** í´ë˜ìŠ¤ì—ì„œëŠ” ë¯¸ë¡œë¥¼ ìƒì„±í•œë‹¤.

```python
class Maze:
    def __init__(self, rows:int = 10, columns:int = 10,
                sparseness:float = 0.2,
                start:MazeLocation = MazeLocation(0, 0),
                goal:MazeLocation = MazeLocation(9, 9)) -> None:
        self._rows:int = rows
        self._columns:int = columns
        self.start:MazeLocation = start
        self.goal:MazeLocation = goal
        self._grid:List[List[Cell]] = [[Cell.EMPTY for c in range(columns)] for r in range(rows)]
        self._randomly_fill(rows, columns, sparseness)
        self._grid[start.row][start.column] = Cell.START
        self._grid[goal.row][goal.column] = Cell.GOAL
        
    def _randomly_fill(self, rows:int, columns:int, sparseness:float):
        for row in range(rows):
            for column in range(columns):
                if random.uniform(0, 1.0) < sparseness:
                    self._grid[row][column] = Cell.BLOCKED

    def __repr__(self) -> str:
        output:str = ""
        for row in self._grid:
            output += " ".join([c.value for c in row]) + "\n"
        return output

    def goal_test(self, ml:MazeLocation) -> bool:
        return ml == self.goal

    def successors(self, ml:MazeLocation) -> List[MazeLocation]:
        locations:List[MazeLocation] = []
        if ml.row + 1    < self._rows    and self._grid[ml.row + 1][ml.column] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row + 1, ml.column))
        if ml.row - 1    >= 0            and self._grid[ml.row - 1][ml.column] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row - 1, ml.column))
        if ml.column + 1 < self._columns and self._grid[ml.row][ml.column + 1] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row, ml.column + 1))
        if ml.column - 1 >= 0            and self._grid[ml.row][ml.column - 1] != Cell.BLOCKED:
            locations.append(MazeLocation(ml.row, ml.column - 1))
        return locations

    def mark(self, path:List[MazeLocation]):
        for maze_location in path:
            self._grid[maze_location.row][maze_location.column] = Cell.PATH
        self._grid[self.start.row][self.start.column] = Cell.START
        self._grid[self.goal.row][self.goal.column] = Cell.GOAL

    def clear(self, path:List[MazeLocation]):
        for maze_location in path:
            self._grid[maze_location.row][maze_location.column] = Cell.EMPTY
        self._grid[self.start.row][self.start.column] = Cell.START
        self._grid[self.goal.row][self.goal.column] = Cell.GOAL
```

- **init**

  í¬ê¸°(rows, columns) ë° ë§‰íŒ ê³µê°„ì´ ì°¨ì§€í•˜ëŠ” ë¹„ìœ¨(sparseness)ì„ ë°”íƒ•ìœ¼ë¡œ ë¯¸ë¡œë¥¼ ìƒì„±í•œ ë’¤, íŠ¹ì • ì¹¸ì— ì‹œì‘ ìœ„ì¹˜ì™€ ì¢…ë£Œ ìœ„ì¹˜ë¥¼ í‘œì‹œí•œë‹¤.

- **_randomly_fill**

  ë¯¸ë¡œì˜ ì¼ì • ë¶€ë¶„ì„ ë¬´ì‘ìœ„ë¡œ ë§‰íŒ ê³µê°„ Cell.BLOCKEDìœ¼ë¡œ ë°”ê¾¼ë‹¤. sparsenessê°€ 0.2ë©´ ì•½ 20%ì˜ ê³µê°„ì´ ë§‰íˆê²Œ ëœë‹¤.

- **repr**

  ë¯¸ë¡œë¥¼ ì¶œë ¥í•œë‹¤.

- **goal_test**

  ë§ì´ ì¢…ë£Œ ìœ„ì¹˜ì— ë„ë‹¬í–ˆëŠ”ì§€ í™•ì¸í•œë‹¤.

- **successors**

  í•´ë‹¹ ìœ„ì¹˜ì—ì„œ ë§ì´ ì´ë™ ê°€ëŠ¥í•œ ìœ„ì¹˜ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜í•œë‹¤. ë¯¸ë¡œì˜ ê°€ì¥ìë¦¬ì— ìœ„ì¹˜í•˜ê±°ë‚˜ ìƒí•˜ì¢Œìš°ì— ë§‰íŒ ê³µê°„ì´ ìˆë‹¤ë©´ ê·¸ë§Œí¼ ê²½ë¡œëŠ” ì œí•œëœë‹¤.

- **mark**

  ë§ì˜ ì´ë™ ê²½ë¡œë¥¼ Cell.PATHë¡œ í‘œì‹œí•œë‹¤.

- **clear**

  ë¯¸ë¡œë¥¼ ì´ˆê¸°í™”í•œë‹¤. ëª¨ë“  ì¹¸ì„ Cell.EMPTYë¡œ ë°”ê¾¸ë©´ ëœë‹¤. 

ë¯¸ë¡œê°€ ì˜ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸í•œë‹¤.

```python
if __name__ == "__main__":
    m:Maze = Maze()
    print(m)
```

```python
S               X  

  X
    X     X       X

          X
X     X
      X       X

    X X X     X   G
```

## ğŸ’¾ Nodeì™€ ê²½ë¡œ ì¶œë ¥

```python
class Node(Generic[T]):
    def __init__(self, state:T, parent:Optional[Node], cost:float = 0.0, heuristic:float = 0.0):
        self.state:T = state
        self.parent:Optional[Node] = parent
        self.cost:float = cost
        self.heuristic:float = heuristic

    def __lt__(self, other:Node) -> bool:
        return (self.cost + self.heuristic) < (other.cost + other.heuristic)
```

- stateëŠ” ìƒíƒœ
- parentëŠ” ì´ì „ ê²½ë¡œ
- costì™€ heuristicì€ ë¹„ìš©

ë¬¸ìì—´ìœ¼ 

```python
def node_to_path(node:Node[T]) -> List[T]:
    path:List[T] = [node.state]
    while node.parent is not None:
        node = node.parent
        path.append(node.state)
    path.reverse()
    return path
```



## ğŸ’¾ ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)

Stackì„ ì‚¬ìš©í•œë‹¤.

```python
class Stack(Generic[T]):
    def __init__(self) -> None:
        self._container:List[T] = []

    @property
    def empty(self) -> bool:
        return not self._container
    def push(self, item:T) -> None:
        self._container.append(item)
    def pop(self) -> T:
        return self._container.pop()
    def __repr__(self) -> str:
        return repr(self._container)
```

> *Note*
>
> **@property** ë°ì½”ë ˆì´í„°ë¥¼ ì‚¬ìš©í•´ ë©”ì„œë“œê°€ get ì—­í• ì„ í•œë‹¤ëŠ” ê²ƒì„ ëª…ì‹œí•  ìˆ˜ ìˆë‹¤.

```python
def dfs(initial:T, 
        goal_test:Callable[[T], bool], 
        successors:Callable[[T], List[T]]) -> Optional[Node[T]]:
    frontier:Stack[Node[T]] = Stack()
    frontier.push(Node(initial, None))
    explored:Set[T] = {initial}

    while not frontier.empty:
        current_node:Node[T] = frontier.pop()
        current_state:T = current_node.state
        if goal_test(current_state):
            return current_node
        for child in successors(current_state):
            if child in explored:
                continue
            explored.add(child)
            frontier.push(Node(child, current_node))
    return None
```



```python
if __name__ == "__main__":
    solution1:Optional[Node[MazeLocation]] = dfs(m.start, m.goal_test, m.successors)
    if solution1 is None: print("ê¹Šì´ ìš°ì„  íƒìƒ‰ìœ¼ë¡œ ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        path1:List[MazeLocation] = node_to_path(solution1)
        m.mark(path1)
        print(m)
        m.clear(path1)
```

```python
S * * * * * * * X
              * *
  X   * * * *   *
    X *   X * * * X
  * * *
  *       X
X * * X
    * X       X
    * * * * * * * *
    X X X     X   G
```



## ğŸ’¾ ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS)

```python
class Queue(Generic[T]):
    def __init__(self) -> None:
        self._container:Deque[T] = Deque()

    @property
    def empty(self) -> bool:
        return not self._container
    def push(self, item:T) -> None:
        self._container.append(item)
    def pop(self) -> T:
        return self._container.popleft()
    def __repr__(self) -> str:
        return repr(self._container)
```



```python
def bfs(initial:T, 
        goal_test:Callable[[T], bool], 
        successors:Callable[[T], List[T]]) -> Optional[Node[T]]:
    frontier:Queue[Node[T]] = Queue()
    frontier.push(Node(initial, None))
    explored:Set[T] = {initial}

    while not frontier.empty:
        current_node:Node[T] = frontier.pop()
        current_state:T = current_node.state
        if goal_test(current_state):
            return current_node
        for child in successors(current_state):
            if child in explored:
                continue
            explored.add(child)
            frontier.push(Node(child, current_node))
    return None
```



```python
if __name__ == "__main__":
    solution2:Optional[Node[MazeLocation]] = bfs(m.start, m.goal_test, m.successors)
    if solution2 is None: print("ë„ˆë¹„ ìš°ì„  íƒìƒ‰ìœ¼ë¡œ ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        path2:List[MazeLocation] = node_to_path(solution2)
        m.mark(path2)
        print(m)
        m.clear(path2)
```



```python
S               X
*
* X
*   X     X       X
*
* *       X
X *   X
  *   X       X
  * * * * * * * *
    X X X     X * G
```



## ğŸ’¾ A* ì•Œê³ ë¦¬ì¦˜

```python
class PriorityQueue(Generic[T]):
    def __init__(self) -> None:
        self._container: List[T] = []
    
    @property
    def empty(self) -> bool:
        return not self._container
    def push(self, item:T) -> None:
        heappush(self._container, item)
    def pop(self) -> T:
        return heappop(self._container)
    def __repr__(self) -> str:
        return repr(self._container)
```



```python
def astar(initial:T, 
          goal_test:Callable[[T], bool], 
          successors:Callable[[T], List[T]], 
          heuristic:Callable[[T], float]) -> Optional[Node[T]]:
    frontier:PriorityQueue[Node[T]] = PriorityQueue()
    frontier.push(Node(initial, None, 0.0, heuristic(initial)))
    explored:Dict[T, float] = {initial: 0.0}

    while not frontier.empty:
        current_node:Node[T] = frontier.pop()
        current_state:T = current_node.state
        if goal_test(current_state):
            return current_node
        for child in successors(current_state):
            new_cost:float = current_node.cost + 1
            if child not in explored or explored[child] > new_cost:
                explored[child] = new_cost
                frontier.push(Node(child, current_node, new_cost, heuristic(child)))
    return None
```

## ìœ í´ë¦¬ë“œ ê±°ë¦¬ì™€ ë§¨í•´íŠ¼ ê±°ë¦¬

ìœ í´ë¦¬ë“œ ê±°ë¦¬ëŠ” **ìœ í´ë¦¬ë“œ ê¸°í•˜í•™**ì—ì„œ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì´ë‹¤. 

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/distance-1.png?raw=true)

```python
# ìœ í´ë¦¬ë“œ ê±°ë¦¬
def euclidean_distance(goal:MazeLocation) -> Callable[[MazeLocation], float]:
    def distance(ml:MazeLocation) -> float:
        xdist:int = ml.column - goal.column
        ydist:int = ml.row - goal.row
        return sqrt((xdist * xdist) + (ydist * ydist))
    return distance
```

> *Note*
>
> í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°

ë§¨í•´íŠ¼ ê±°ë¦¬ëŠ” **íƒì‹œ ê¸°í•˜í•™**ì—ì„œ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì´ë‹¤. 

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/distance-2.png?raw=true)

```python
# ë§¨í•´íŠ¼ ê±°ë¦¬
def manhattan_distance(goal:MazeLocation) -> Callable[[MazeLocation], float]:
    def distance(ml:MazeLocation) -> float:
        xdist:int = abs(ml.column - goal.column)
        ydist:int = abs(ml.row - goal.row)
        return (xdist + ydist)
    return distance
```

A* ì•Œê³ ë¦¬ì¦˜ì˜ íš¨ìœ¨

```python
if __name__ == "__main__":
    distance:Callable[[MazeLocation], float] = manhattan_distance(m.goal)
    solution3:Optional[Node[MazeLocation]] = astar(m.start, m.goal_test, m.successors, distance)
    if solution3 is None: print("A* ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê¸¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
    else:
        path3:List[MazeLocation] = node_to_path(solution3)
        m.mark(path3)
        print(m)
```

```python
S               X
*
* X
*   X     X       X
* *
  * * * * X
X     X * * * * * *
      X       X   *
                  *
    X X X     X   G
```



## ğŸ“ ì—°ìŠµë¬¸ì œ 2

---

# ì„ êµì‚¬ì™€ ì‹ì¸ì¢…

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-2-3.png?raw=true)

```python
# import
from __future__ import annotations
from typing import List, Optional
from generic_search import bfs, Node, node_to_path
```

## ì œë„¤ë¦­ í”„ë¡œê·¸ë˜ë°ì˜ í˜

```python
MAX_NUM:int = 3

class MCState:
    def __init__(self, missionaries:int, cannibals:int, boat:bool) -> None:
        self.wm:int = missionaries
        self.wc:int = cannibals
        self.em:int = MAX_NUM - self.wm
        self.ec:int = MAX_NUM - self.wc
        self.boat:bool = boat

    def __repr__(self) -> str:
        return (f"ì„œìª½ ê°•ë‘‘ì—ëŠ” {self.wm}ëª…ì˜ ì„ êµì‚¬ì™€ {self.wc}ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.\n"
                f"ë™ìª½ ê°•ë‘‘ì—ëŠ” {self.em}ëª…ì˜ ì„ êµì‚¬ì™€ {self.ec}ëª…ì˜ ì‹ì¸ì¢…ì´ ìˆë‹¤.\n"
                f"ë°°ëŠ” {'ì„œ' if self.boat else 'ë™'}ìª½ì— ìˆë‹¤.")
    
    def goal_test(self) -> bool:
        return self.is_legal and self.em == MAX_NUM and self.ec == MAX_NUM

    @property
    def is_legal(self) -> bool:
        if self.wm < self.wc and self.wm > 0:
            return False
        if self.em < self.ec and self.em > 0:
            return False
        return True

    def successors(self) -> List[MCState]:
        sucs:List[MCState] = []
        if self.boat:   # ì„œìª½ ê°•ë‘‘ì— ìˆëŠ” ë°°
            if self.wm > 1:
                sucs.append(MCState(self.wm - 2, self.wc, not self.boat))
            if self.wm > 0:
                sucs.append(MCState(self.wm - 1, self.wc, not self.boat))
            if self.wc > 1:
                sucs.append(MCState(self.wm, self.wc - 2, not self.boat))
            if self.wc > 0:
                sucs.append(MCState(self.wm, self.wc - 1, not self.boat))
            if (self.wc > 0) and (self.wm > 0):
                sucs.append(MCState(self.wm - 1, self.wc - 1, not self.boat))
        else:           # ë™ìª½ ê°•ë‘‘ì— ìˆëŠ” ë°°
            if self.em > 1:
                sucs.append(MCState(self.wm + 2, self.wc, not self.boat))
            if self.em > 0:
                sucs.append(MCState(self.wm + 1, self.wc, not self.boat))
            if self.ec > 1:
                sucs.append(MCState(self.wm, self.wc + 2, not self.boat))
            if self.ec > 0:
                sucs.append(MCState(self.wm, self.wc + 1, not self.boat))
            if (self.ec > 0) and (self.em > 0):
                sucs.append(MCState(self.wm + 1, self.wc + 1, not self.boat))
        return [x for x in sucs if x.is_legal]
```

```python
def display_solution(path:List[MCState]):
    if len(path) == 0:
        return
    old_state:MCState = path[0]
    print(old_state)
    for current_state in path[1:]:
        if current_state.boat:
            print("{}ëª…ì˜ ì„ êµì‚¬ì™€ {}ëª…ì˜ ì‹ì¸ì¢…ì´ ë™ìª½ ê°•ë‘‘ì—ì„œ ì„œìª½ ê°•ë‘‘ìœ¼ë¡œ ê°”ë‹¤.\n"
                  .format(old_state.em - current_state.em, old_state.ec - current_state.ec))
        else:
            print("{}ëª…ì˜ ì„ êµì‚¬ì™€ {}ëª…ì˜ ì‹ì¸ì¢…ì´ ë™ìª½ ê°•ë‘‘ì—ì„œ ì„œìª½ ê°•ë‘‘ìœ¼ë¡œ ê°”ë‹¤.\n"
                  .format(old_state.wm - current_state.wm, old_state.wc - current_state.wc))
        print(current_state)
        old_state = current_state
```

```python
if __name__ == "__main__":
    start:MCState = MCState(MAX_NUM, MAX_NUM, True)
    solution:Optional[Node[MCState]] = bfs(start, MCState.goal_test, MCState.successors)
    if solution is None:
        print("ë‹µì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    else:
        path:List[MCState] = node_to_path(solution)
        display_solution(path)
```

## ğŸ“ ì—°ìŠµë¬¸ì œ 3
