---
layout: post
title: "(2-1) DNA ê²€ìƒ‰"
meta: "ðŸŽ² DNA Search"
categories: Classic
tags: Python
---

* content
{:toc}


# DNA ê²€ìƒ‰

## DNAì˜ êµ¬ì¡°

```python
from enum import IntEnum
from typing import Tuple, List

Nucleotide:IntEnum = IntEnum('Nucleotide', ('A', 'C', 'G', 'T'))
Codon = Tuple[Nucleotide, Nucleotide, Nucleotide]
Gene = List[Codon]

gene_str:str = "ACGTGGCTCTCTAACGTACGTACGTACGGGGTTTATATATACCCTAGGACTCCCTTT"
```

- **ë‰´í´ë ˆì˜¤íƒ€ì´ë“œ**(Nucleotide)

  A, C, G, T ì¤‘ í•˜ë‚˜ë¡œ í‘œí˜„í•œë‹¤.

1. Enum

- **ì½”ëˆ**(Codon)

  ì„¸ ê°œì˜ ë‰´í´ë ˆì˜¤íƒ€ì´ë“œë¡œ êµ¬ì„±ëœë‹¤.

- **ìœ ì „ìž**(Gene)

  ë‹¤ìˆ˜ì˜ ì½”ëˆìœ¼ë¡œ êµ¬ì„±ëœë‹¤. 

1. Codonì€ Nucleotideë¡œ êµ¬ì„±ëœ Tupleì´ë¯€ë¡œ íƒ€ìž… ížŒíŠ¸ë¥¼ í‘œì‹œí•  ë•Œ Tuple[Nucleotide, Nucleotide, Nucleotide]ë¡œ í‘œì‹œëœë‹¤. í•˜ì§€ë§Œ Codon íƒ€ìž…ì˜ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œë§ˆë‹¤ ê¸´ íƒ€ìž…ëª…ì„ í‘œì‹œí•œë‹¤ë©´ ë²ˆê±°ë¡œìš¸ ë¿ë”ëŸ¬ ì½”ë“œì˜ ì§ê´€ì„±ê³¼ ê°„ê²°ì„±ì„ í•´ì¹œë‹¤. **íƒ€ìž… ì•¨ë¦¬ì–´ìŠ¤**(Type alias)ë¥¼ ì‚¬ìš©í•˜ë©´ ê¸´ íƒ€ìž…ëª… ëŒ€ì‹  ì§§ì€ ë³„ì¹­ì„ ì‚¬ìš©í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.

```python
def string_to_gene(s:str) -> Gene:
    gene:Gene = []
    for i in range(0, len(s), 3):
        if (i + 2) >= len(s):
            return gene
        codon:Codon = (Nucleotide[s[i]]), Nucleotide[s[i+1]], Nucleotide[s[i+2]]
        gene.append(codon)
    return gene

my_gene:Gene = string_to_gene(gene_str)
```

ê²€ìƒ‰ ìž‘ì—…ì„ ì‹œí–‰í•˜ê¸° ì•žì„œ ë‰´í´ë ˆì˜¤íƒ€ì´ë“œë¡œ êµ¬ì„±ëœ ë¬¸ìžì—´ì„ 3ê¸€ìžì”© ëŠì–´ì„œ ìœ ì „ìžë¥¼ ìƒì„±í•œë‹¤.

## ì„ í˜• ê²€ìƒ‰

```python
# 2.1.2 ì„ í˜• ê²€ìƒ‰
def linear_contains(gene:Gene, key_codon:Codon) -> bool:
    for codon in gene:
        if codon == key_codon:
            return True
    return False
```

```python
# 2.1.4 ì œë„¤ë¦­ ê²€ìƒ‰
def linear_contains(iterable:Iterable[T], key:T) -> bool:
    for item in iterable:
        if item == key:
            return True
    return False
C = TypeVar("C", bound="Comparable")
```



## ì´ì§„ ê²€ìƒ‰

```python
# 2.1.3 ì´ì§„ ê²€ìƒ‰
def binary_contains(gene:Gene, key_codon:Codon) -> bool:
    low:int = 0
    high:int = len(gene) - 1
    while low <= high:
        mid:int = (low + high) // 2
        if gene[mid] < key_codon:
            low = mid + 1
        elif gene[mid] > key_codon:
            high = mid - 1
        else:
            return True
    return False
```

```python
# 2.1.4 ì œë„¤ë¦­ ê²€ìƒ‰
def binary_contains(sequence:Sequence[C], key:C) -> bool:
    low:int = 0
    high:int = len(sequence) - 1
    while low <= high:
        mid:int = (low + high) // 2
        if sequence[mid] < key:
            low = mid + 1
        elif sequence[mid] > key:
            high= mid - 1
        else:
            return True
        return False
```

---

# Generic

```python
# 2.1.4 ì œë„¤ë¦­ ê²€ìƒ‰
from __future__ import annotations
from typing import TypeVar, Iterable, Sequence, Generic, List, Callable, Set, Deque, Dict, Any, Optional
from typing_extensions import Protocol
from heapq import heappush, heappop

T = TypeVar('T')
C = TypeVar("C", bound="Comparable")

class Comparable(Protocol):
    def __eq__(self, other:Any) -> bool:
        ...
    def __lt__(self:C, other:C) -> bool:
        ...
    def __gt__(self:C, other:C) -> bool:
        return (not self < other) and self != other
    def __le__(self:C, other:C) -> bool:
        return self < other or self == other
    def __ge__(self:C, other:C) -> bool:
        return not self < other
```
