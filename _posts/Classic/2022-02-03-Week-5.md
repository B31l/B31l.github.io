---
layout: post
meta: "Week-5"
title: "Week-5: ìœ ì „ ì•Œê³ ë¦¬ì¦˜"
categories: Classic
tags: Python
mathjax: true
---

* content
{:toc}
# ì œë„¤ë¦­

## ìœ ì „ ì•Œê³ ë¦¬ì¦˜ì˜ ì „ê°œ

ìœ ì „ ì•Œê³ ë¦¬ì¦˜ì€ ì í•©í•œ ê°œì²´ê°€ ì‚´ì•„ë‚¨ëŠ” **ìì—° ì„ íƒ**<sup>natural selection</sup>ì˜ ë§¤ì»¤ë‹ˆì¦˜ê³¼ ë§¤ìš° ìœ ì‚¬í•˜ë‹¤. 

ì¶”ìš´ ì§€ë°©ì˜ ìƒë¬¼ì„ ì˜ˆì‹œë¡œ ë“¤ì–´ë³´ì. ê¸´ í„¸ê³¼ ë‘êº¼ìš´ í”¼í•˜ì§€ë°©ì„ ê°€ì§„ ê°œì²´ëŠ” ìƒì¡´ì— ì ì‘í•  ìˆ˜ ìˆìœ¼ë©°, ê·¸ë ‡ì§€ ì•Šì€ ê°œì²´ì— ë¹„í•´ ì‚´ì•„ë‚¨ê³  ë²ˆì‹í•  í™•ë¥ ì´ í¬ë‹¤. ë”°ë¼ì„œ ì‹œê°„ì´ ì§€ë‚˜ê³  ì„¸ëŒ€ê°€ êµì²´ë ìˆ˜ë¡ í™˜ê²½ì— ì í•©í•œ ê°œì²´ëŠ” ì¦ê°€í•˜ë©°, ì í•©í•˜ì§€ ì•Šì€ ê°œì²´ëŠ” ì ì°¨ ê°ì†Œí•˜ë‹¤ ëë‚´ ì‚¬ë¼ì§„ë‹¤.

### 1. ìƒì„±

ì„¸ë¡œìš´ ìƒˆëŒ€ë¥¼ ì‹œì‘í•œë‹¤. ê° ì„¸ëŒ€ëŠ” ì—¼ìƒ‰ì²´ë¡œ ì´ë£¨ì–´ì ¸ ìˆê³ , ~

### 2. ì¸¡ì •

ì í•©ë„ê°€ íŠ¹ì • ì„ê³—ê°’ì„ ë„˜ì—ˆì„ ê²½ìš° ì•Œê³ ë¦¬ì¦˜ì„ ì¢…ë£Œí•œë‹¤.

### 3. ì„ íƒ

ì¬ìƒì‚°ì„ ìœ„í•´ ê°€ì¥ ë†’ì€ ì í•©ë„ë¥¼ ê°€ì§ˆ í™•ë¥ ì´ ë†’ì€ ê°œì²´ë¥¼ ì„ íƒí•œë‹¤.

- **ë£°ë ›íœ  ì„ íƒ**
- **í† ë„ˆë¨¼íŠ¸ ì„ íƒ**

### 4. í¬ë¡œìŠ¤ì˜¤ë²„

ì¼ë¶€ ì„ íƒëœ ì—¼ìƒ‰ì²´ë¥¼ ê²°í•©í•œë‹¤.

### 5. ëŒì—°ë³€ì´

ì¼ë¶€ ì—¼ìƒ‰ì²´ëŠ” ë¬´ì‘ìœ„ë¡œ ë°”ë€ë‹¤.



## Chromosome í´ë˜ìŠ¤

ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•´ êµ¬í˜„í•œë‹¤.

<u>chromosome.py</u>

```python
from __future__ import annotations
from typing import TypeVar, Tuple, Type
from abc import ABC, abstractmethod

# íƒ€ì…ì´ Tì¸ ë³€ìˆ˜ëŠ” Chromoosome í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ í˜¹ì€ ì„œë¸Œí´ë˜ìŠ¤ì—¬ì•¼ í•œë‹¤.
T = TypeVar("T", bound="Chromosome")


class Chromosome(ABC):
    @abstractmethod
    def fitness(self) -> float:
        ...
    
    @classmethod
    @abstractmethod
    def random_instance(cls:Type[T]) -> T:
        ...

    @abstractmethod
    def crossover(self:T, other:T) -> Tuple[T, T]:
        ...

    @abstractmethod
    def mutate(self) -> None:
        ...
```

ë©”ì„œë“œê°€ ìˆ˜í–‰í•˜ëŠ” ì—­í• ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

- **fitness**
- **random_instance**
- **crossover**
- **mutate**

> *Note*
>
> íŒŒì´ì¬ì—ì„œëŠ” ë°ì½”ë ˆì´í„° **@classmethod** ë˜ëŠ” @staticmethodë¥¼ ì‚¬ìš©í•´ ì •ì  ë©”ì„œë“œë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤. 

## GeneticAlgorithm í´ë˜ìŠ¤

<u>genetic_algorithm.py</u>

```python
from __future__ import annotations
from typing import Type, TypeVar, Generic, List, Tuple, Callable
from enum import Enum
from random import choices, random
from heapq import nlargest
from statistics import mean
from chromosome import Chromosome

# ì¦‰ íƒ€ì… CëŠ” Chromosomeì˜ ë©”ì„œë“œë¥¼ ê°–ëŠ”ë‹¤.
C = TypeVar("C", bound=Chromosome)


class GeneticAlgorithm(Generic[C]):
    SelectionType = Enum("SelectionType", "ROULETTE TOURNAMENT")
    
    def __init__(self, 
                 initial_population:List[C],
                 threshold:float,
                 max_generations:int = 100,
                 mutation_chance:float = 0.01,
                 crossover_chance:float = 0.7,
                 selection_type:SelectionType = SelectionType.TOURNAMENT) -> None:
        self._population:List[C] = initial_population
        self._threshold:float = threshold
        self._max_generations:int = max_generations
        self._mutation_chance:float = mutation_chance
        self._crossover_chance:float = crossover_chance
        self._selection_type:GeneticAlgorithm.SelectionType = selection_type
        self._fitness_key:Callable = type(self._population[0]).fitness

    def _pick_roulette(self, wheel:List[float]) -> Tuple[C, C]:
        return tuple(choices(self._population, weights=wheel, k=2))

    def _pick_tournament(self, num_participants:int) -> Tuple[C, C]:
        participants:List[C] = choices(self._population, k=num_participants)
        return tuple(nlargest(2, participants, key=self._fitness_key))

    def _reproduce_and_replace(self) -> None:
        new_population:List[C] = []
        while len(new_population) < len(self._population):
            # ë¶€ëª¨ ì„ íƒ
            if self._selection_type == GeneticAlgorithm.SelectionType.ROULETTE:
                parents:Tuple[C, C] = self._pick_roulette(
                    [x.fitness() for x in self._population]
                )
            else:
                parents = self._pick_tournament(
                    len(self._population) // 2
                )
            # í¬ë¡œìŠ¤ì˜¤ë²„
            if random() < self._crossover_chance:
                new_population.extend(parents[0].crossover(parents[1]))
            else:
                new_population.extend(parents)
        if len(new_population) > len(self._population):
            new_population.pop()
        self._population = new_population

    def _mutate(self) -> None:
        for individudal in self._population:
            if random() < self._mutation_chance:
                individudal.mutate()

    def run(self) -> C:
        best:C = max(self._population, key=self._fitness_key)
        for generation in range(self._max_generations):
            if best.fitness() >= self._threshold:
                return best
            print(f"ì„¸ëŒ€ {generation} ìµœìƒ {best.fitness()} í‰ê·  {mean(map(self._fitness_key, self._population))}")
            self._reproduce_and_replace()
            self._mutate()
            highest:C = max(self._population, key=self._fitness_key)
            if highest.fitness() > best.fitness():
                best = highest
        
        return best
```

ë©”ì„œë“œê°€ ìˆ˜í–‰í•˜ëŠ” ì—­í• ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

- **pick_roulette**ì™€ **pick_tournamen**
- **reproduce_and_replace**
- **mutate**
- **run**

---

# ì ìš©

ìœ ì „ ì•Œê³ ë¦¬ì¦˜ì€ ~ì— ì‚¬ìš©ëœë‹¤.

ê° ìœ ì „ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œëŠ” ë‹¤ë¥¸ **ì—¼ìƒ‰ì²´**<sup>Chromosome</sup>ë¥¼ ê°–ëŠ”ë‹¤.

## ê°„ë‹¨í•œ ë°©ì •ì‹

1. ë°©ì •ì‹ $6x - x^2 + 4y - y^2$ì´ ìµœëŒ“ê°’ì´ ë˜ëŠ” $x$ì™€ $y$ë¥¼ êµ¬í•˜ë¼.

ìˆ˜í•™ì ìœ¼ë¡œ ì ‘ê·¼í•˜ë©´ í¸ë¯¸ë¶„<sup>partial derivative</sup>ì„ ì‚¬ìš©í•´ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

```python
import sympy as sp

x, y, z = sp.symbols("x y z")
f = 6*x - x**2 + 4*y - y**2

df_dx = sp.diff(f, x)   # ë³€ìˆ˜ xì— ëŒ€í•´ í¸ë¯¸ë¶„
df_dy = sp.diff(f, y)   # ë³€ìˆ˜ yì— ëŒ€í•´ í¸ë¯¸ë¶„

max_x = sp.solve(df_dx, x)
max_y = sp.solve(df_dy, y)

print("x =", *max_x)    # 3
print("y =", *max_y)    # 2
```

ìœ„ì—ì„œ ì‚´í´ ë³¸ ë°©ì •ì‹ ë¬¸ì œë¥¼ ìœ ì „ ì•Œê³ ë¦¬ì¦˜ã…‡

<u>simple_equation.py</u>

```python
from __future__ import annotations
from typing import Tuple, List
from chromosome import Chromosome
from genetic_algorithm import GeneticAlgorithm
from random import randrange, random
from copy import deepcopy


class SimpleEquation(Chromosome):
    def __init__(self, x:int, y:int) -> None:
        self.x:int = x
        self.y:int = y

    def fitness(self) -> float:
        return (6 * self.x) - (self.x * self.x) + (4 * self.y) - (self.y * self.y)

    @classmethod
    def random_instance(cls) -> SimpleEquation:
        return SimpleEquation(randrange(100), randrange(100))

    def crossover(self, other:SimpleEquation) -> Tuple[SimpleEquation, SimpleEquation]:
        child1:SimpleEquation = deepcopy(self)
        child2:SimpleEquation = deepcopy(other)
        child1.y = other.y
        child2.y = self.y
        return child1, child2   # yë¥¼ ì„œë¡œ ë°”ê¾¼ë‹¤.

    def mutate(self) -> None:
        if random() > 0.5:
            if random() > 0.5:
                self.x += 1
            else:
                self.x -= 1
        else:
            if random() > 0.5:
                self.y += 1
            else:
                self.y -= 1
    
    def __repr__(self) -> str:
        return f"X: {self.x} Y: {self.y} ì í•©ë„: {self.fitness()}"


if __name__ == "__main__":
    initial_population:List[SimpleEquation] =\
        [SimpleEquation.random_instance() for _ in range(20)]
    ga:GeneticAlgorithm[SimpleEquation] =\
        GeneticAlgorithm(initial_population=initial_population,
                         threshold=13.0,
                         max_generations=100,
                         mutation_chance=0.1,
                         crossover_chance=0.7)
    result:SimpleEquation = ga.run()
    print(result)
```



## SEND+MORE=MONEY

ë³µë©´ì‚° í¼ì¦ SEND+MORE=MONEY

<u>send_more_money2.py</u>

```python
from __future__ import annotations
from typing import Tuple, List
from chromosome import Chromosome
from genetic_algorithm import GeneticAlgorithm
from random import shuffle, sample
from copy import deepcopy


class SendMoreMoney2(Chromosome):
    def __init__(self, letters:List[str]) -> None:
        self.letters:List[str] = letters

    def fitness(self) -> float:
        s:int = self.letters.index("S")
        e:int = self.letters.index("E")
        n:int = self.letters.index("N")
        d:int = self.letters.index("D")
        m:int = self.letters.index("M")
        o:int = self.letters.index("O")
        r:int = self.letters.index("R")
        y:int = self.letters.index("Y")
        send:int = s * 1000 + e * 100 + n * 10 + d
        more:int = m * 1000 + o * 100 + r * 10 + e
        money:int = m * 10000 + o * 1000 + n * 100 + e * 10 + y
        difference:int = abs(money - (send + more))
        return 1 / (difference + 1)

    @classmethod
    def random_instance(cls) -> SendMoreMoney2:
        letters = ["S", "E", "N", "D", "M", "O", "R", "Y", " ", " "]
        shuffle(letters)
        return SendMoreMoney2(letters)

    def crossover(self, other:SendMoreMoney2) -> Tuple[SendMoreMoney2, SendMoreMoney2]:
        child1:SendMoreMoney2 = deepcopy(self)
        child2:SendMoreMoney2 = deepcopy(other)
        idx1, idx2 = sample(range(len(self.letters)), k=2)
        l1, l2 = child1.letters[idx1], child2.letters[idx2]
        child1.letters[child1.letters.index(l2)], child1.letters[idx2] = child1.letters[idx2], l2
        child2.letters[child2.letters.index(l1)], child2.letters[idx1] = child2.letters[idx1], l1
        return child1, child2

    def mutate(self) -> None:
        idx1, idx2 = sample(range(len(self.letters)), k=2)
        self.letters[idx1], self.letters[idx2] = self.letters[idx2], self.letters[idx1]

    def __repr__(self) -> str:
        s:int = self.letters.index("S")
        e:int = self.letters.index("E")
        n:int = self.letters.index("N")
        d:int = self.letters.index("D")
        m:int = self.letters.index("M")
        o:int = self.letters.index("O")
        r:int = self.letters.index("R")
        y:int = self.letters.index("Y")
        send:int = s * 1000 + e * 100 + n * 10 + d
        more:int = m * 1000 + o * 100 + r * 10 + e
        money:int = m * 10000 + o * 1000 + n * 100 + e * 10 + y
        difference:int = abs(money - (send + more))
        return f"{send} + {more} = {money} ì°¨ì´: {difference}"


if __name__ == "__main__":
    initial_population:List[SendMoreMoney2] =\
        [SendMoreMoney2.random_instance() for _ in range(1000)]
    ga:GeneticAlgorithm[SendMoreMoney2] =\
        GeneticAlgorithm(initial_population=initial_population,
                         threshold=1.0,
                         max_generations=1000,
                         mutation_chance=0.2,
                         crossover_chance=0.7,
                         selection_type=GeneticAlgorithm.SelectionType.ROULETTE)
    result:SendMoreMoney2 = ga.run()
    print(result)
```



## ë¦¬ìŠ¤íŠ¸ ì••ì¶•

<u>list_compression.py</u>

```python
from __future__ import annotations
from genericpath import getsize
from typing import Tuple, List, Any
from chromosome import Chromosome
from genetic_algorithm import GeneticAlgorithm
from random import shuffle, sample
from copy import deepcopy
from zlib import compress
from sys import getsizeof
from pickle import dumps

PEOPLE:List[str] = ["Michael", "Sarah", "Joshua", "Narine", 
                    "David", "Sajid", "Melanie", "Daniel", 
                    "Wei", "Dean", "brian", "Murat", "Lisa"]


class ListCompression(Chromosome):
    def __init__(self, lst:List[Any]) -> None:
        self.lst:List[Any] = lst
    
    @property
    def bytes_compressed(self) -> int:
        return getsizeof(compress(dumps(self.lst)))

    def fitness(self) -> float:
        return 1 / self.bytes_compressed

    @classmethod
    def random_instance(cls) -> ListCompression:
        mylst:List[str] = deepcopy(PEOPLE)
        shuffle(mylst)
        return ListCompression(mylst)

    def crossover(self, other:ListCompression) -> Tuple[ListCompression, ListCompression]:
        child1:ListCompression = deepcopy(self)
        child2:ListCompression = deepcopy(other)
        idx1, idx2 = sample(range(len(self.lst)), k=2)
        l1, l2 = child1.lst[idx1], child2.lst[idx2]
        child1.lst[child1.lst.index(l2)], child1.lst[idx2] = child1.lst[idx2], l2
        child2.lst[child2.lst.index(l1)], child2.lst[idx1] = child2.lst[idx1], l1
        return child1, child2

    def mutate(self) -> None:
        idx1, idx2 = sample(range(len(self.lst)), k=2)
        self.lst[idx1], self.lst[idx2] = self.lst[idx2], self.lst[idx1]

    def __repr__(self) -> str:
        return f"ìˆœì„œ: {self.lst} ë°”ì´íŠ¸:{self.bytes_compressed}"


if __name__ == "__main__":
    initial_population:List[ListCompression] =\
        [ListCompression.random_instance() for _ in range(100)]
    ga:GeneticAlgorithm[ListCompression] =\
        GeneticAlgorithm(initial_population=initial_population,
                         threshold=1.0,
                         max_generations=100,
                         mutation_chance=0.2,
                         crossover_chance=0.7,
                         selection_type=GeneticAlgorithm.SelectionType.TOURNAMENT)
    result:ListCompression = ga.run()
    print(result)
```



---

# ì—°ìŠµë¬¸ì œ

## ğŸ“ 5-1

1. *Practice question*

   ì²´ê° í™•ë¥ <sup>diminishing probability</sup>ì„ ê¸°ë°˜ìœ¼ë¡œ ë‘ ë²ˆì§¸ í˜¹ì€ ì„¸ ë²ˆì§¸ë¡œ ê°€ì¥ ì¢‹ì€ ì—¼ìƒ‰ì²´ë¥¼ ì„ íƒí•  ìˆ˜ ìˆëŠ” ê³ ê¸‰ í† ë„ˆë¨¼íŠ¸ ì„ íƒ ìœ í˜•ì„ **GeneticAlgorithm** í´ë˜ìŠ¤ì— ì¶”ê°€í•˜ë¼.

...



## ğŸ“ 5-2

1. *Practice question*

   3ì¥ì˜ ì œì•½ ì¶©ì¡± ë¬¸ì œ í”„ë ˆì„ì›Œí¬ì— ìœ ì „ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì„ì˜ì˜ ì œì•½ ì¶©ì¡± ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ìƒˆë¡œìš´ ë©”ì„œë“œë¥¼ ì¶”ê°€í•˜ë¼. ì í•©ë„ì˜ ê°€ëŠ¥í•œ ì¸¡ì •ì€ ì—¼ìƒ‰ì²´ì— ì˜í•´ í•´ê²°ë˜ëŠ” ì œì•½ ì¡°ê±´ì˜ ìˆ˜ë‹¤.

...



## ğŸ“ 5-3

1. *Practice question*

   **Chromosome** í´ë˜ìŠ¤ë¥¼ ìƒì†ë°›ëŠ” **BitString** í´ë˜ìŠ¤ë¥¼ ìƒì„±í•˜ë¼. ë¹„íŠ¸ ë¬¸ìì—´ì— ëŒ€í•´ì„œëŠ” 1ì¥ì„ ì°¸ì¡°í•œë‹¤. ê·¸ë¦¬ê³  ìƒˆë¡œ ìƒì„±í•œ í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ 5.3ì ˆ 'ê°„ë‹¨í•œ ë°©ì •ì‹' ë¬¸ì œë¥¼ í•´ê²°í•˜ë¼. ë¬¸ì œë¥¼ ì–´ë–»ê²Œ ë¹„íŠ¸ ë¬¸ìì—´ë¡œ ì¸ì½”ë”©í•  ìˆ˜ ìˆì„ê¹Œ?

...

