---
layout: post
title: "Week-3: 제약 충족 문제"
meta: "Week-3"
categories: Classic
tags: Python
---

* content
{:toc}
# 제약 충족 문제



## Constraint

<u>Constraint 클래스</u>

```python
from typing import Generic, TypeVar, Dict, List, Optional
from abc import ABC, abstractmethod

V = TypeVar('V') # 변수(Variable) 타입
D = TypeVar('D') # 도메인(Domain) 타입


class Constraint(Generic[V, D], ABC):
    """
    * 추상 베이스 클래스
    제약 조건 변수  : Constraint.variables
    """
    def __init__(self, variables:List[V]) -> None:
        self.variables = variables                              # variables     : 제약 조건 변수

    # 제약 조건이 충족되었는지 검사한다.
    @abstractmethod
    def satisfied(self, assignment:Dict[V, D]) -> bool:
        ...
```

`Constraint` 클래스는 

## CSP

<u>CSP 클래스</u>

```python
class CSP(Generic[V, D]):
    """
    * 핵심 클래스
    변수            : self.variables
    도메인          : self.domains
    제약 조건       : self.constraints
    """
    def __init__(self, variables:List[V], domains:Dict[V, List[D]]) -> None:

        # 1. 변수 및 도메인을 저장한다.
        self.variables:List[V] = variables                      # variables     : List[V]
        self.domains:Dict[V, List[D]] = domains                 # domains       : { V : List[D] }

        # 2. 제약 조건 컬렉션을 초기화한다.
        self.constraints:Dict[V, List[Constraint[V, D]]] = {}   # constraints   : { V : List[Constraint[V, D]] }
        for variable in self.variables:                         # {}
            self.constraints[variable] = []                     # { 변수1 : [], 변수2: [], ... }
            if variable not in self.domains:
                raise LookupError("모든 변수에 도메인이 할당되어야 합니다.")

    # 3. 제약 조건을 저장한다.
    def add_constraint(self, constraint:Constraint[V, D]) -> None:
        for variable in constraint.variables:                   
            if variable not in self.variables:
                raise LookupError("제약 조건 변수가 아닙니다.")
            else:
                self.constraints[variable].append(constraint)   # { 변수1 : [제약 조건], 변수 2: [제약 조건], ... }

    # 주어진 변수의 모든 제약 조건을 검사하며 assignment 값이 일관적인지 확인한다.
    def consistent(self, variable:V, assignment:Dict[V, D]) -> bool:
        for constraint in self.constraints[variable]:
            if not constraint.satisfied(assignment):
                return False    # 제약 조건을 충족하지 않음    -> False
        return True         # 할당이 모든 제약 조건을 충족 -> True

    # 백트래킹(backtracking): 깊이 우선 탐색(DFS)과 유사한 방식
    def backtracking_search(self, assignment:Dict[V, D] = {}) -> Optional[Dict[V, D]]:

        # assignment는 모든 변수가 할당될 때 완료된다(기저 조건).
        if len(assignment) == len(self.variables):
            return assignment

        # 할당되지 않은 모든 변수를 가져온다.
        unsigned:List[V] = [v for v in self.variables if v not in assignment]
        
        # 할당되지 않은 첫 번째 변수의 가능한 모든 도메인 값을 가져온다.
        first:V = unsigned[0]
        for value in self.domains[first]:
            local_assignment = assignment.copy()
            local_assignment[first] = value
            
            # local_assignment 값이 일치하면 재귀 호출한다.
            if self.consistent(first, local_assignment):
                result:Optional[Dict[V, D]] = self.backtracking_search(local_assignment)
                if result is not None:
                    return result   # 솔루션 반환
        return None                 # 솔루션 없음
```

CSP 클래스는 변수, 도메인, 제약 조건을 저장한다.

assignment는 변수에 대한 

`consistent` 함수는 **assignment**

`backtracking_search()` 함수는 **assignment**를 깊이 우선 탐색(DFS)과 유사한 방식을 사용해 탐색한 다음 솔루션을 반환한다.



---

# 1. 호주 지도 색칠 문제

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-3-1.png?raw=true)

위 호주 지도를 색칠한다고 가정한다. 3가지 색만 사용해야 하며, 인접한 두 지역은 같은 색을 사용할 수 없다.

변수, 도메인, 제약 조건을 정의하고, 이를 바탕으로 코드를 작성한다.

|           | 타입                 | 설명                                       |
| --------- | -------------------- | ------------------------------------------ |
| 변수(V)   | str                  | 지역 이름                                  |
| 도메인(D) | str                  | 색상 이름                                  |
| 제약 조건 | Constraint[str, str] | 인접한 두 지역은 같은 색으로 칠할 수 없다. |

<u>제약 조건 설정</u>

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional


class MapColoringConstraint(Constraint[str, str]):
    def __init__(self, place1:str, place2:str) -> None:
        super().__init__([place1, place2])
        self.place1:str = place1
        self.place2:str = place2

    def satisfied(self, assignment:Dict[str, str]) -> bool:
        if self.place1 not in assignment or self.place2 not in assignment:
            return True
        return assignment[self.place1] != assignment[self.place2]
```

아직 할당이 이루어지지 않았다

| 어느 한쪽이 할당이 이루어지지 않은 경우                      | 할당이 이루어졌지만 충돌이 발생하지 않은 경우                | 충돌이 발생한 경우                                           |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/australia-1.png?raw=true) | ![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/australia-2.png?raw=true) | ![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/australia-3.png?raw=true) |



<u>main</u>

```python
if __name__ == "__main__":

    # V
    variables:List[str] = ["웨스턴 오스트레일리아", 
                           "노던 준주", 
                           "사우스 오스트레일리아",
                           "퀸즐랜드",
                           "뉴사우스웨일스",
                           "빅토리아",
                           "태즈메이니아"]

    # D
    domains:Dict[str, List[str]] = {}
    for variable in variables:
        domains[variable] = ["빨강", "초록", "파랑"]

    # constraint
    csp:CSP[str, str] = CSP(variables, domains)
    csp.add_constraint(MapColoringConstraint("웨스턴 오스트레일리아", "노던 준주"))
    csp.add_constraint(MapColoringConstraint("웨스턴 오스트레일리아", "사우스 오스트레일리아"))
    csp.add_constraint(MapColoringConstraint("사우스 오스트레일리아", "노던 준주"))
    csp.add_constraint(MapColoringConstraint("퀸즐랜드"             , "노던 준주"))
    csp.add_constraint(MapColoringConstraint("퀸즐랜드"             , "사우스 오스트레일리아"))
    csp.add_constraint(MapColoringConstraint("퀸즐랜드"             , "뉴사우스웨일스"))
    csp.add_constraint(MapColoringConstraint("뉴사우스웨일스"       , "사우스 오스트레일리아"))
    csp.add_constraint(MapColoringConstraint("빅토리아"             , "사우스 오스트레일리아"))
    csp.add_constraint(MapColoringConstraint("빅토리아"             , "뉴사우스웨일스"))
    csp.add_constraint(MapColoringConstraint("빅토리아"             , "태즈메이니아"))
    
    # solution
    solution:Optional[Dict[str, str]] = csp.backtracking_search()
    if solution is None:
        print("답을 찾을 수 없습니다!")
    else:
        print(solution)
```



<u>terminal</u>

```
{'웨스턴 오스트레일리아': '빨강', '노던 준주': '초록', '사우스 오스트레일리아': '파랑', '퀸즐랜드': '빨강', '뉴사우스웨일스': '초록', '빅토리아': '빨강', '태즈메이니아': '초록'}
```

---

# 2. 여덟 퀸 문제

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-3-2.png?raw=true)

체스판에 8개의 퀸을 배치한다고 가정한다. 각 퀸은 3가지 색을 사용해야 한다.

변수, 도메인, 제약 조건을 정의하고, 이를 바탕으로 코드를 작성한다.

|           | 타입                 | 설명                                         |
| --------- | -------------------- | -------------------------------------------- |
| 변수(V)   | int                  | 퀸의 열(1 ~ 8)                               |
| 도메인(D) | int                  | 퀸의 행(1 ~ 8)                               |
| 제약 조건 | Constraint[int, int] | 모든 퀸은 서로 다른 줄 및 대각선에 위치한다. |



<u>제약 조건 설정</u>

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional


class QueensConstraint(Constraint[int, int]):
    def __init__(self, columns:List[int]) -> None:
        super().__init__(columns)
        self.columns:List[int] = columns

    def satisfied(self, assignment:Dict[int, int]) -> bool:
        for q1c, q1r in assignment.items():
            for q2c in range(q1c + 1, len(self.columns) + 1):
                if q2c in assignment:
                    q2r:int = assignment[q2c]
                    if q1r == q2r:                          # 2. 같은 행?
                        return False
                    if abs(q1r - q2r) == abs(q1c - q2c):    # 3. 같은 대각선?
                        return False
        return True
```



<u>main</u>

```python
if __name__ == "__main__":
    
    # V
    columns:List[int] = [1, 2, 3, 4, 5, 6, 7, 8]
    
    # D
    rows:Dict[int, List[int]] = {}
    for column in columns:
        rows[column] = [1, 2, 3, 4, 5, 6, 7, 8]
        
    # constraint
    csp:CSP[int, int] = CSP(columns, rows)
    csp.add_constraint(QueensConstraint(columns))
    
    # solution
    solution:Optional[Dict[int, int]] = csp.backtracking_search()
    if solution is None:
        print("답을 찾을 수 없습니다!")
    else:
        print(solution)
```



<u>terminal</u>

```
{1: 1, 2: 5, 3: 8, 4: 6, 5: 3, 6: 7, 7: 2, 8: 4}
```

---

# 3. SEND+MORE=MONEY

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-3-3.png?raw=true)

변수, 도메인, 제약 조건을 정의한다.

|           | 타입                 | 설명                                         |
| --------- | -------------------- | -------------------------------------------- |
| 변수(V)   | str                  | 문자                                         |
| 도메인(D) | int                  | 문자가 의미하는 숫자(0 ~ 9)                  |
| 제약 조건 | Constraint[str, int] | 서로 다른 문자는 같은 숫자를 나타낼 수 없다. |



<u>제약 조건 설정</u>

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional


class SendMoreMoneyConstraint(Constraint[str, int]):
    def __init__(self, letters:List[str]) -> None:
        super().__init__(letters)
        self.letters:List[str] = letters

    def satisfied(self, assignment:Dict[str, int]) -> bool:
        if len(set(assignment.values())) < len(assignment):
            return False
    
        if len(assignment) == len(self.letters):
            s:int = assignment["S"]
            e:int = assignment["E"]
            n:int = assignment["N"]
            d:int = assignment["D"]
            m:int = assignment["M"]
            o:int = assignment["O"]
            r:int = assignment["R"]
            y:int = assignment["Y"]
            send:int = s * 1000 + e * 100 + n * 10 + d
            more:int = m * 1000 + o * 100 + r * 10 + e
            money:int = m * 10000 + o * 1000 + n * 100 + e * 10 + y
            return send + more == money
        return True
```



<u>main</u>

```python
if __name__ == "__main__":

    # V
    letters:List[str] = ["S", "E", "N", "D", "M", "O", "R", "Y"]

    # D
    possible_digits:Dict[str, List[int]] = {}
    for letter in letters:
        possible_digits[letter] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    possible_digits["M"] = [1]

    # constraint
    csp:CSP[str, int] = CSP(letters, possible_digits)
    csp.add_constraint(SendMoreMoneyConstraint(letters))
    
    # solution
    solution:Optional[Dict[str, int]] = csp.backtracking_search()
    if solution is None:
        print("답을 찾을 수 없습니다!")
    else:
        print(solution)
```



<u>terminal</u>

```
{'S': 9, 'E': 5, 'N': 6, 'D': 7, 'M': 1, 'O': 0, 'R': 8, 'Y': 2}
```

---

# 4. 단어 검색

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-3-4.png?raw=true)

## 문제 나타내기

```python
from typing import NamedTuple, Dict, List, Optional
from random import choice
from string import ascii_uppercase
from csp import Constraint, CSP

Grid = List[List[str]]


class GridLocation(NamedTuple):
    row:int
    column:int
```

`GridLocation` 클래스는 **NamedTuple**을 상속받아 격자 행렬에서의 알파벳 위치를 표시하는 역할을 수행한다.

```python
def generate_grid(rows:int, columns:int) -> Grid:
    return [[choice(ascii_uppercase) for c in range(columns)] for r in range(rows)]

def display_grid(grid:Grid) -> None:
    for row in grid:
        print("".join(row))
```

`generate_grid` 함수는 무작위 알파벳 대문자로 채워진 격자인 2차원 리스트를 생성한다. 

**random.choice**는 입력받은 Sequence에서 무작위 항목을 반환한다. 이때 인자로 "ABCDEFGHIJKLMNOPQRSTUVWXYZ" 대신 **string.ascii_uppercase**를 사용해 간단하게 나타낼 수 있다.

`display_grid` 함수는 격자를 출력한다.

```python
def generate_domain(word:str, grid:Grid) -> List[List[GridLocation]]:
    domain:List[List[GridLocation]] = []
    height:int = len(grid)
    width:int = len(grid[0])
    length:int = len(word)
    for row in range(height):
        for col in range(width):
            columns:range = range(col, col + length + 1)
            rows:range = range(row, row + length + 1)
            if col + length <= width:
                # 1. 
                domain.append([GridLocation(row, c) for c in columns])
                if row + length <= height:
                    # 2.
                    domain.append([GridLocation(r, col + (r - row)) for r in rows])
            if row + length <= height:
                # 3.
                domain.append([GridLocation(r, col) for r in rows])
                if col - length >= 0:
                    # 4.
                    domain.append([GridLocation(r, col - (r - row)) for r in rows])
    return domain
```

`generate_domain` 함수는 

## 문제 해결하기

변수, 도메인, 제약 조건을 정의한다.

|           | 타입                                | 설명                 |
| --------- | ----------------------------------- | -------------------- |
| 변수(V)   | str                                 | 단어                 |
| 도메인(D) | List[GridLocation]                  | 단어의 위치          |
| 제약 조건 | Constraint[str, List[GridLocation]] | 단어는 겹칠 수 없다. |



<u>제약 조건 설정</u>

```python
class WordSearchConstraint(Constraint[str, List[GridLocation]]):
    def __init__(self, words:List[str]) -> None:
        super().__init__(words)
        self.words:List[str] = words

    def satisfied(self, assignment:Dict[str, List[GridLocation]]) -> bool:
        all_locations = [locs for values in assignment.values() for locs in values]
        return len(set(all_locations)) == len(all_locations)
```



<u>main</u>

```python
if __name__ == "__main__":

    # V
    grid:Grid = generate_grid(9, 9)

    # D
    words:List[str] = ["MATTHEW", "JOE", "MARY", "SARAH", "SALLY"]
    locations:Dict[str, List[List[GridLocation]]] = {}
    for word in words:
        locations[word] = generate_domain(word, grid)

    # constraint
    csp:CSP[str, List[GridLocation]] = CSP(words, locations)
    csp.add_constraint(WordSearchConstraint(words))
    
    # solution
    solution:Optional[Dict[str, List[GridLocation]]] = csp.backtracking_search()
    if solution is None:
        print("답을 찾을 수 없습니다!")
    else:
        for word, grid_locations in solution.items():
            if choice([True, False]):
                grid_locations.reverse()
            for index, letter in enumerate(word):
                (row, col) = (grid_locations[index].row, grid_locations[index].column)
                grid[row][col] = letter
        display_grid(grid)
```



<u>terminal</u>

```
IWEHTTAMB
EYRAMGSEE
DNQHOHAIO
YVQGVALNJ
GJTGNRLQE
OURBHAYKK
BSKNZSTBK
MXDXGJUPS
NXUUPWXZY
```



## 📝 연습문제 3-1

1. *Q*

   WordSearchConstraint 클래스를 수정하여 중복 단어를 허용하는 단어 검색을 구현하라.

3-1

---

## 📝 연습문제 3-2

1. *Q*

   회로판 레이아웃 문제



## 📝 연습문제 3-3

1. *Q*

   스도쿠 문제

