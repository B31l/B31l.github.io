---
layout: post
title: "Week-3: 제약 충족 문제"
meta: "Week-3"
categories: Classic
tags: Python
---

* content
{:toc}
# 제약 충족 문제

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Week-3.png?raw=true)

```python
from typing import Generic, TypeVar, Dict, List, Optional
from abc import ABC, abstractmethod
```

```python
V = TypeVar('V') # 변수(Variable) 타입
D = TypeVar('D') # 도메인(Domain) 타입
```



## Constraint

```python
class Constraint(Generic[V, D], ABC):
    """
    * 추상 베이스 클래스
    제약 조건 변수  : Constraint.variables
    """
    def __init__(self, variables:List[V]) -> None:
        self.variables = variables                              # variables     : 제약 조건 변수

    # 제약 조건이 충족되었는지 검사한다.
    @abstractmethod
    def satisfied(self, assignment:Dict[V, D]) -> bool:
        ...
```



## CSP

- 변수
- 도메인
- 제약 조건

```python
class CSP(Generic[V, D]):
    """
    * 핵심 클래스
    변수            : self.variables
    도메인          : self.domains
    제약 조건       : self.constraints
    """
    def __init__(self, variables:List[V], domains:Dict[V, List[D]]) -> None:

        # 1. 변수 및 도메인을 저장한다.
        self.variables:List[V] = variables                      # variables     : List[V]
        self.domains:Dict[V, List[D]] = domains                 # domains       : { V : List[D] }

        # 2. 제약 조건 컬렉션을 초기화한다.
        self.constraints:Dict[V, List[Constraint[V, D]]] = {}   # constraints   : { V : List[Constraint[V, D]] }
        for variable in self.variables:                         # {}
            self.constraints[variable] = []                     # { 변수1 : [], 변수2: [], ... }
            if variable not in self.domains:
                raise LookupError("모든 변수에 도메인이 할당되어야 합니다.")

    # 3. 제약 조건을 저장한다.
    def add_constraint(self, constraint:Constraint[V, D]) -> None:
        for variable in constraint.variables:                   
            if variable not in self.variables:
                raise LookupError("제약 조건 변수가 아닙니다.")
            else:
                self.constraints[variable].append(constraint)   # { 변수1 : [제약 조건1, 제약 조건 2, ...], 변수 2: [], ... }

    # 주어진 변수의 모든 제약 조건을 검사하며 assignment 값이 일관적인지 확인한다.
    def consistent(self, variable:V, assignment:Dict[V, D]) -> bool:
        for constraint in self.constraints[variable]:
            if not constraint.satisfied(assignment):
                return False    # 제약 조건을 충족하지 않음    -> False
            return True         # 할당이 모든 제약 조건을 충족 -> True

    # 백트래킹(backtracking): 깊이 우선 탐색(DFS)과 유사한 방식
    def backgracking_search(self, assignment:Dict[V, D] = {}) -> Optional[Dict[V, D]]:

        # assignment는 모든 변수가 할당될 때 완료된다(기저 조건).
        if len(assignment) == len(self.variables):
            return assignment

        # 할당되지 않은 모든 변수를 가져온다.
        unsigned:List[V] = [v for v in self.variables if v not in assignment]
        
        # 할당되지 않은 첫 번째 변수의 가능한 모든 도메인 값을 가져온다.
        first:V = unsigned[0]
        for value in self.domains[first]:
            local_assignment = assignment.copy()
            local_assignment[first] = value
            
            # local_assignment 값이 일치하면 재귀 호출한다.
            if self.consistent(first, local_assignment):
                result:Optional[Dict[V, D]] = self.backgracking_search(local_assignment)
                if result is not None:
                    return result   # 솔루션 반환
        return None                 # 솔루션 없음
```



---

# 1. 호주 지도 색칠 문제

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional

class MapColoringConstraint(Constraint[str, str]):
    def __init__(self, place1:str, place2:str) -> None:
        super().__init__([place1, place2])
        self.place1:str = place1
        self.place2:str = place2

    def satisfied(self, assignment:Dict[str, str]) -> bool:
        if self.place1 not in assignment or self.place2 not in assignment:
            return True
        return assignment[self.place1] != assignment[self.place2]
```

```python
if __name__ == "__main__":
    variables:List[str] = ["웨스턴 오스트레일리아", 
                           "노던 준주", 
                           "사우스 오스트레일리아",
                           "퀸즐랜드",
                           "뉴사우스웨일스",
                           "빅토리아",
                           "태즈메이니아"]
    domains:Dict[str, List[str]] = {}
    for variable in variables:
        domains[variable] = ["빨강", "초록", "파랑"]
    csp:CSP[str, str] = CSP(variables, domains)
    csp.add_constraint(MapColoringConstraint("웨스턴 오스트레일리아", "노던 준주"))
    csp.add_constraint(MapColoringConstraint("웨스턴 오스트레일리아", "사우스 오스트레일리아"))
    csp.add_constraint(MapColoringConstraint("사우스 오스트레일리아", "노던 준주"))
    csp.add_constraint(MapColoringConstraint("퀸즐랜드"             , "노던 준주"))
    csp.add_constraint(MapColoringConstraint("퀸즐랜드"             , "사우스 오스트레일리아"))
    csp.add_constraint(MapColoringConstraint("퀸즐랜드"             , "뉴사우스웨일스"))
    csp.add_constraint(MapColoringConstraint("뉴사우스웨일스"       , "사우스 오스트레일리아"))
    csp.add_constraint(MapColoringConstraint("빅토리아"             , "사우스 오스트레일리아"))
    csp.add_constraint(MapColoringConstraint("빅토리아"             , "뉴사우스웨일스"))
    csp.add_constraint(MapColoringConstraint("빅토리아"             , "태즈메이니아"))
    
    solution:Optional[Dict[str, str]] = csp.backgracking_search()
    if solution is None:
        print("답을 찾을 수 없습니다!")
    else:
        print(solution)
```

---



# 2. 여덟 퀸 문제

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional

class QueensConstraint(Constraint[int, int]):
    def __init__(self, columns:List[int]) -> None:
        super().__init__(columns)
        self.columns:List[int] = columns

    def satisfied(self, assignment:Dict[int, int]) -> bool:
        for q1c, q1r in assignment.items():
            for q2c in range(q1c + 1, len(self.columns) + 1):
                if q2c in assignment:
                    q2r:int = assignment[q2c]
                    if q1r == q2r:                          # 2. 같은 행?
                        return False
                    if abs(q1r - q2r) == abs(q1c - q2c):    # 3. 같은 대각선?
                        return False
        return True
```

```python
if __name__ == "__main__":
    columns:List[int] = [1, 2, 3, 4, 5, 6, 7, 8]    # V
    rows:Dict[int, List[int]] = {}                  # D
    for column in columns:
        rows[column] = [1, 2, 3, 4, 5, 6, 7, 8]
    csp:CSP[int, int] = CSP(columns, rows)
    csp.add_constraint(QueensConstraint(columns))
    solution:Optional[Dict[int, int]] = csp.backgracking_search()
    if solution is None:
        print("답을 찾을 수 없습니다!")
    else:
        print(solution)
```



---

# 3. SEND+MORE=MONEY

```python
from csp import Constraint, CSP
from typing import Dict, List, Optional

class SendMoreMoneyConstraint(Constraint[str, int]):
    def __init__(self, letters:List[str]) -> None:
        super().__init__(letters)
        self.letters:List[str] = letters

    def satisfied(self, assignment:Dict[str, int]) -> bool:
        if len(set(assignment.values())) < len(assignment):
            return False
    
        if len(assignment) == len(self.letters):
            s:int = assignment["S"]
            e:int = assignment["E"]
            n:int = assignment["N"]
            d:int = assignment["D"]
            m:int = assignment["M"]
            o:int = assignment["O"]
            r:int = assignment["R"]
            y:int = assignment["Y"]
            send:int = s * 1000 + e * 100 + n * 10 + d
            more:int = m * 1000 + o * 100 + r * 10 + e
            money:int = m * 10000 + o * 1000 + n * 100 + e * 10 + y
            return send + more == money
        return True
```

```python
if __name__ == "__main__":
    letters:List[str] = ["S", "E", "N", "D", "M", "O", "R", "Y"]
    possible_digits:Dict[str, List[int]] = {}
    for letter in letters:
        possible_digits[letter] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    possible_digits["M"] = [1]
    csp:CSP[str, int] = CSP(letters, possible_digits)
    csp.add_constraint(SendMoreMoneyConstraint(letters))
    solution:Optional[Dict[str, int]] = csp.backgracking_search()
    if solution is None:
        print("답을 찾을 수 없습니다!")
    else:
        print(solution)
```



---

# 4. 단어 검색

## 개요

```python
from typing import NamedTuple, Dict, List, Optional
from random import choice
from string import ascii_uppercase
from csp import Constraint, CSP

Grid = List[List[str]]


class GridLocation(NamedTuple):
    row:int
    column:int
```

```python
def generate_grid(rows:int, columns:int) -> Grid:
    return [[choice(ascii_uppercase) for c in range(columns)] for r in range(rows)]

def display_grid(grid:Grid) -> None:
    for row in grid:
        print("".join(row))
```

```python
def generate_domain(word:str, grid:Grid) -> List[List[GridLocation]]:
    domain:List[List[GridLocation]] = []
    height:int = len(grid)
    width:int = len(grid[0])
    length:int = len(word)
    for row in range(height):
        for col in range(width):
            columns:range = range(col, col + length + 1)
            rows:range = range(row, row + length + 1)
            if col + length <= width:
                # 1. 
                domain.append([GridLocation(row, c) for c in columns])
                if row + length <= height:
                    # 2.
                    domain.append([GridLocation(r, col + (r - row)) for r in rows])
            if row + length <= height:
                # 3.
                domain.append([GridLocation(r, col) for r in rows])
                if col - length >= 0:
                    # 4.
                    domain.append([GridLocation(r, col - (r - row)) for r in rows])
    return domain
```

## 실행

```python
class WordSearchConstraint(Constraint[str, List[GridLocation]]):
    def __init__(self, words:List[str]) -> None:
        super().__init__(words)
        self.words:List[str] = words

    def satisfied(self, assignment:Dict[str, List[GridLocation]]) -> bool:
        all_locations = [locs for values in assignment.values() for locs in values]
        return len(set(all_locations)) == len(all_locations)
```

```python
if __name__ == "__main__":
    grid:Grid = generate_grid(9, 9)
    words:List[str] = ["MATTHEW", "JOE", "MARY", "SARAH", "SALLY"]
    locations:Dict[str, List[List[GridLocation]]] = {}
    for word in words:
        locations[word] = generate_domain(word, grid)
    csp:CSP[str, List[GridLocation]] = CSP(words, locations)
    csp.add_constraint(WordSearchConstraint(words))
    solution:Optional[Dict[str, List[GridLocation]]] = csp.backgracking_search()
    if solution is None:
        print("답을 찾을 수 없습니다!")
    else:
        for word, grid_locations in solution.items():
            if choice([True, False]):
                grid_locations.reverse()
            for index, letter in enumerate(word):
                (row, col) = (grid_locations[index].row, grid_locations[index].column)
                grid[row][col] = letter
        display_grid(grid)
```



## 📝 연습문제 3-1

1. *Q*

   WordSearchConstraint 클래스를 수정하여 중복 단어를 허용하는 단어 검색을 구현하라.

3-1

---

## 📝 연습문제 3-2

1. *Q*

   회로판 레이아웃 문제



## 📝 연습문제 3-3

1. *Q*

   스도쿠 문제

