---
layout: post
meta: "Week-8"
title: "Week-8: 적대적 탐색"
categories: Classic
tags: Python
mathjax: true
---

* content
{:toc}
# 개요







---

# 제네릭

<u>board.py</u>

```python
# 보드게임 구성 요소

from __future__ import annotations
from typing import NewType, List
from abc import ABC, abstractmethod

# 게임에서의 이동을 나타내는 정수 타입
# 타입 엘리어스의 두 타입은 동등하지만, NewType은 한 타입을 다른 타입의 서브 타입으로 선언한다.
Move = NewType("Move", int)


class Piece:
    @property
    def opposite(self) -> Piece:
        raise NotImplementedError("서브클래스로 구현해야 합니다.")


class Board(ABC):
    # 누구 차례인가?
    @property
    @abstractmethod
    def turn(self) -> Piece:
        ...

    # 현재 위치에서 새 위치로 이동한다.
    @abstractmethod
    def move(self, location:Move) -> Board:
        ...

    # 말은 현재 위치에서 어디로 움직일 수 있는가?
    @property
    @abstractmethod
    def legal_moves(self) -> List[Move]:
        ...

    # 이겼는가?
    @property
    @abstractmethod
    def is_win(self) -> bool:
        ...

    # 무승부인가?
    @property
    def is_draw(self) -> bool:
        return (not self.is_win) and (len(self.legal_moves) == 0)

    # 플레이어의 말 위치를 평가하여 어느 쪽이 유리한지 확인한다.
    @abstractmethod
    def evaluate(self, player:Piece) -> float:
        ...
```







---

# 적용: 틱택토









---

# 적용: 커넥트포











---

# 연습문제

## 📝 8-1

1. *Practice question*

   틱택토에 단위 테스트를 추가하여 **legal_moves**, **is_win**, **is_draw** 속성이 잘 작동하는지 확인하라.



## 📝 8-2

1. *Practice question*

   커넥트포에 대한 최소최대 알고리즘의 단위 테스트를 작성하라.



## 📝 8-3

1. *Practice question*

   **tictactoe_ai.py**와 **connectfour_ai.py**의 코드는 거의 비슷하다. 이 두 코드를 두 게임 모두에서 사용할 수 있도록 두 메서드로 작성하여 리팩토링하라.



## 📝 8-4

1. *Practice question*

   컴퓨터 플레이어가 자신과 게임할 수 있도록 **connectfour_ai.py** 코드를 변경해보자. 첫 번째 플레이어와 두 번째 플레이어 중 누가 더 많이 이기는가? 매번 같은 선수가 이기는가?



## 📝 8-5

1. *Practice question*

   **connectfour_ai.py**에서 평가 방법을 최적화하여 같은 시간 내에 더 높은 탐색 길이를 가능하게 하는 방법을 찾아보라(기존 코드를 프로파일링하거나 다른 방법을 사용해도 좋다).



## 📝 8-6

1. *Practice question*

   합법적인 체스 이동 생성 및 체스 게임 상태 유지 관리를 위해 이 장에서 개발한 **alphabeta()** 함수를 파이썬 라이브러리와 함께 사용하여 체스 AI를 개발하라.

