---
layout: post
title: "(1-1) ì‘ì€ ë¬¸ì œì™€ ë‹¤ì–‘í•œ í’€ì´"
meta: "ğŸ² FIB & OTP"
categories: Classic
tags: Python
---

* content
{:toc}
# í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´

```
1, 1, 2, 3, 5, ...
```

## ì¬ê·€ (Recursion)

ìê¸° ìì‹ ì„ í˜¸ì¶œí•˜ëŠ” ë°©ë²•ì´ë‹¤.

```python
def fib2(n:int) -> int:
    if n < 2:
        return n
    return fib2(n - 1) + fib2(n - 2)
```

ì¬ê·€ë¥¼ ì‚¬ìš©í•˜ë©´ ê°™ì€ ì¸ìì— ëŒ€í•œ í˜¸ì¶œì´ ì¤‘ë³µìœ¼ë¡œ ë°œìƒí•œë‹¤. ì´ëŠ” ì¸ìê°€ ì»¤ì§ˆìˆ˜ë¡ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ì¦ê°€í•œë‹¤.

> ê¸°ì € ì¡°ê±´(ë˜ëŠ” ì¢…ë£Œ ì¡°ê±´)ì„ ì„¤ì •í•˜ì§€ ì•Šìœ¼ë©´ ë¬´í•œ ì¬ê·€ í˜¸ì¶œì˜ êµ´ë ˆì— ë¹ ì§ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¡°ì‹¬í•´ì•¼ í•œë‹¤!

## ë©”ëª¨ì´ì œì´ì…˜ (Memoization)

ì‚¬ì „ ìë£Œí˜•ì— í•¨ìˆ˜ì˜ ë¦¬í„´ê°’ì„ ì €ì¥í•˜ë©´ ë¶ˆí•„ìš”í•œ í˜¸ì¶œì„ ì¤„ì¼ ìˆ˜ ìˆë‹¤.

```python
memo:dict[int:int] = {0: 0, 1: 1}
def fib3(n:int) -> int:
    if n not in memo:
        memo[n] = fib3(n - 1) + fib3(n - 2)
    return memo[n]
```

ë‚´ì¥ ë°ì½”ë ˆì´í„°ì¸ `@lru_cache`ëŠ” í•¨ìˆ˜ì˜ ë¦¬í„´ê°’ì„ ìë™ìœ¼ë¡œ ìºì‹±(ì €ì¥)í•  ìˆ˜ë„ ìˆë‹¤. ë°ì½”ë ˆì´í„°ë¥¼ ì¶”ê°€í•˜ë©´ ìµœì´ˆ í˜¸ì¶œì´ ì•„ë‹Œ ëª¨ë“  í•¨ìˆ˜ í˜¸ì¶œì€ ìºì‹±ëœ ê²°ê³¼ë¥¼ ëŒ€ì‹  ë°˜í™˜í•œë‹¤. maxsizeëŠ” ìºì‹œí•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°œìˆ˜ë¥¼ ì˜ë¯¸í•˜ë©°, `None`ìœ¼ë¡œ ì„¤ì • ì‹œ ìºì‹±ì˜ ì œí•œì´ ì‚¬ë¼ì§„ë‹¤.

```python
from functools import lru_cache
@lru_cache(maxsize=None)
def fib4(n:int) -> int:
    if n < 2:
        return n
    return fib4(n - 1) + fib4(n - 2)
```

ê¸°ì¡´ ì¬ê·€ í•¨ìˆ˜ì™€ êµ¬ì¡°ëŠ” ê°™ë‹¤.

> lru : last recently used

## íŠœí”Œ ì–¸íŒ¨í‚¹ (Tuple unpacking)

ì¬ê·€ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆëŠ” ë¬¸ì œëŠ” ë°˜ë³µë¬¸ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ë„ ìˆë‹¤. íŠœí”Œ ì–¸íŒ¨í‚¹ì€ ì‹œê°„ì , ê³µê°„ì  íš¨ìœ¨ì˜ ë‘ ë§ˆë¦¬ í† ë¼ë¥¼ ëª¨ë‘ ì¡ëŠ” ë°©ë²•ì´ë‹¤.

```python
def fib5(n:int) -> int:
    if n == 0: return n
    last:int = 0
    next:int = 1
    for _ in range(1, n):
        last, next = next, last + next
    return next
```

## ì œë„¤ë ˆì´í„° (Generator)

```python
from typing import Generator
def fib6(n:int) -> Generator[int, None, None]:
    yield 0
    if n > 0: yield 1
    last:int = 0
    next:int = 1
    for _ in range(1, n):
        last, next = next, last + next
        yield next
```

í”¼ë³´ë‚˜ì¹˜ í•¨ìˆ˜ë¥¼ for ë°˜ë³µë¬¸ì—ì„œ ì‚¬ìš©í•˜ëŠ” rangeì™€ ê°™ì€ **ì œë„¤ë ˆì´í„°**ë¡œ ë§Œë“ ë‹¤ë©´, ì´ì „ê¹Œì§€ì˜ ëª¨ë“  ê²°ê³¼ë¥¼ `yield`í•  ìˆ˜ ìˆë‹¤.

```python
for i in fib6(20):
    print(i)
```

```
0
1   
1   
2   
3   
5   
8   
13  
21  
34  
55  
89  
144 
233 
377 
610 
987 
1597
2584
4181
6765
```

ì²˜ìŒì—ëŠ” 0ê³¼ 1ì„ ìƒì„±, ì´í›„ íŠœí”Œ ì–¸íŒ¨í‚¹ ë°©ì‹ìœ¼ë¡œ êµ¬í•œ ê°’ì„ ì°¨ë¡€ë¡œ yieldí•œë‹¤.

---

# ê¹¨ì§€ì§€ ì•ŠëŠ” ì•”í˜¸í™”



![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic_Computer_Science_Problems/encrypt-01.png?raw=true)

```python
from secrets import token_bytes
from typing import Tuple

def random_key(length:int) -> int:
    tb:bytes = token_bytes(length)
    return int.from_bytes(tb, "big")

def encrypt(original:str) -> Tuple[int, int]: # ì•”í˜¸í™”
    original_bytes:bytes = original.encode()
    original_key:int = int.from_bytes(original_bytes, "big")
    dummy:int = random_key(len(original_bytes))
    encrypted:int = original_key ^ dummy
    return dummy, encrypted

def decrypt(key1:int, key2:int) -> str:
    decrypted:int = key1 ^ key2
    temp:bytes = decrypted.to_bytes((decrypted.bit_length() + 7) // 8, "big")
    return temp.decode()
```

- **random_key**ëŠ” `secrets` ëª¨ë“ˆì˜ `token_bytes`ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ ì›ë³¸ ë°ì´í„°ì™€ ê°™ì€ ê¸¸ì´ì˜ ë”ë¯¸ ë°ì´í„°ë¥¼ ìƒì„±í•œë‹¤.

- **encrypt**ëŠ” ë‘ ë°ì´í„°ë¥¼ ì¢…í•©í•´ ì•”í˜¸í™”í•œë‹¤. ê²°ê³¼ë¬¼ë¡œ ë‘ ê°œì˜ í‚¤ë¥¼ ë°˜í™˜í•œë‹¤. (dummy, encrypted)

  original_key, dummy, encryptedì¤‘ ë‘ ê°’ì„ ì•Œê³  ìˆìœ¼ë©´ XOR ì—°ì‚°ì„ í†µí•´ ë‚˜ë¨¸ì§€ í•˜ë‚˜ì˜ ê°’ì„ ì•Œ ìˆ˜ ìˆë‹¤.

  ```
  original_key ^ dummy = encrypted
  dummy ^ encrypted = original_key
  encrypted ^ original_key = dummy
  ```

- ì´ ì„±ì§ˆì„ ì´ìš©í•´ **decrypt**ë¡œ ë‘ ê°œì˜ í‚¤ë¥¼ ì¢…í•©í•´ ë³µí˜¸í™”í•œë‹¤. 

  ì¼ë ¨ì˜ ê³¼ì •ì„ ê±°ì¹œ ë°˜í™˜ê°’ì´ ì›ë˜ì˜ ê°’ê³¼ ê°™ìœ¼ë©´, OTP ì•Œê³ ë¦¬ì¦˜ì´ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•¨ì„ ì•Œ ìˆ˜ ìˆë‹¤.

```python
if __name__ == "__main__":
    original = "One Time Pad!"
    key1, key2 = encrypt(original)
    result:str = decrypt(key1, key2)
    print(original == result)
```

```
True
```

---

# Reference

- ê³ ì „ ì»´í“¨í„° ì•Œê³ ë¦¬ì¦˜ ì¸ íŒŒì´ì¬

  <img src="https://image.aladin.co.kr/product/21766/43/cover500/k382636009_1.jpg" style="zoom:50%;" />

- <https://docs.python.org/3.8/library/functools.html#functools.lru_cache>

