---
layout: post
meta: "Week-4"
title: "Week-4: 그래프 문제"
categories: Classic
tags: Python
---

* content
{:toc}
# 그래프 이론

![](https://raw.githubusercontent.com/CodingRG-HKNU/FoundationsOfAlgorithms/master/slides/images/algo03/algo03-03.png)

✒ **이미지 출처**: <https://codingalzi.github.io/algopy/notebooks/algopy06_Dynamic_Programming_2.html>

그래프는 **정점**(vertex)과 정점들을 연결하는 **이음선**(edge)으로 구성된다. 

각각의 이음선이 **가중치**(weight)를 갖는 그래프를 **가중 그래프**(weighted graph), 그렇지 않은 그래프를 **비가중 그래프**(unweighted graph)라고 한다.

각각의 이음선이 **방향**(direction)을 갖는 그래프를 **유향 그래프**(directed graph; digraph), 그렇지 않은 그래프를 **무향 그래프**(undirected graph)라고  한다.

그래프의 **경로**(path)는 한 정점에서 다른 정점으로 가는 이음선들의 모음이며, 경로의 **길이**(length)가 최소가 되는 경로를 최단 경로라고 한다. 

| 그래프 종류   | 경로의 길이                |
| ------------- | -------------------------- |
| 가중 그래프   | 경로 상에 있는 가중치의 합 |
| 비가중 그래프 | 경로 상에 있는 이음선의 수 |

---

# 비가중 그래프

## 정의

Edge와 Graph 클래스를 정의하고, **TypeVar**을 사용해 정접 타입을 선언한다.

| 속성   | 타입  |
| ------ | ----- |
| 그래프 | Graph |
| 정점   | V     |
| 이음선 | Edge  |

<u>edge.py</u>

```python
from __future__ import annotations
from dataclasses import dataclass


@dataclass  # __init__ 자동 생성
class Edge:
    u:int   # 정점(from)
    v:int   # 정점(to)

    def reversed(self) -> Edge:
        return Edge(self.v, self.u)

    def __repr__(self) -> str:
        return f"{self.u} -> {self.v}"
```
![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Edge.png?raw=true)

**Edge** 클래스는 두 개의 정점으로 구성되어 있다.

> *Note*
>
> **dataclass** 모듈의 **@dataclass** 데코레이터를 사용하면은 특수 메서드를 사용자 정의 클래스에 자동으로 추가할 수 있다. 데코레이터의 매개변수의 기본값은 다음과 같다.
>
> ```python
>@dataclass(init=True, repr=True, eq=True, order=False)
> ```
> 
> - **init** = True
>
>   **\__init__()** 특수 메서드를 생성한다. 이미 정의했다면 이 매개변수는 무시된다.
>
> - **repr** = True
>
>   **\__repr__()** 특수 메서드를 생성한다. 이미 정의했다면 이 매개변수는 무시된다.
>
> - **eq** = True
>
>   **\__eq__()** 특수 메서드를 생성한다. 이미 정의했다면 이 매개변수는 무시된다.
>
> - **order** = True
>
>   **\__lt__()** **\__le__()** **\__gt__()** **\__ge__()**특수 메서드를 생성한다. 이미 정의했다면 **TypeError**가 발생하며, order가 참이고 eq가 거짓이면 **ValueError**가 발생한다.
>
> ✒ **Ref**: <https://docs.python.org/ko/3/library/dataclasses.html>

<u>graph.py (계속)</u>

```python
from typing import TypeVar, Generic, List, Optional
from edge import Edge

V = TypeVar("V")    # 그래프 정점(vertice) 타입


class Graph(Generic[V]):
    def __init__(self, vertices:List[V] = []) -> None:
        self._vertices:List[V] = vertices
        self._edges:List[List[Edge]] = [[] for _ in vertices]

    @property
    def vertex_count(self) -> int:
        return len(self._vertices)          # 반환: 정점의 수

    @property
    def edge_count(self) -> int:
        return sum(map(len, self._edges))   # 반환: Edge의 수
        # map 함수를 통해 _edges 리스트의 각 항목의 길이를 구한 뒤, sum 함수를 사용해 모두 합친다. 

    def add_vertex(self, vertex:V) -> int:
        self._vertices.append(vertex)
        self._edges.append([])
        return self.vertex_count - 1        # 반환: 정점의 인덱스

    # Edge 추가
    def add_edge(self, edge:Edge) -> None:
        self._edges[edge.u].append(edge)
        self._edges[edge.v].append(edge.reversed())
        # 정점 a: a -> b
        # 정점 b: b -> a

    # 정점 인덱스를 사용하여 Edge 추가
    def add_edge_by_indices(self, u:int, v:int) -> None:
        edge:Edge = Edge(u, v)
        self.add_edge(edge)

    # 정점 인덱스를 참조하여 Edge 추가
    def add_edge_by_vertices(self, first:V, second:V) -> None:
        u:int = self._vertices.index(first)
        v:int = self._vertices.index(second)
        self.add_edge_by_indices(u, v)
        # index 함수를 사용하면 위치를 찾을 수 있다.

    # 인덱스 -> 정점
    def vertex_at(self, index:int) -> V:
        return self._vertices[index]

    # 정점 -> 인덱스
    def index_of(self, vertex:V) -> int:
        return self._vertices.index(vertex)

    # 정점 인덱스에 연결된 정점
    def neighbors_for_index(self, index:int) -> List[V]:
        return list(map(self.vertex_at, [e.v for e in self._edges[index]]))
        # 엣지의 모든 끝 점(v)의 각 인덱스에 해당하는 정점의 리스트

    # 정점에 연결된 이웃 정점
    def neighbors_for_vertex(self, vertex:V) -> List[V]:
        return self.neighbors_for_index(self.index_of(vertex))

    # 정점 인덱스에 연결된 Edge
    def edges_for_index(self, index:int) -> List[Edge]:
        return self._edges[index]

    # 정점에 연결된 Edge
    def edges_for_vertex(self, vertex:V) -> List[Edge]:
        return self.edges_for_index(self.index_of(vertex))

    # 그래프 출력
    def __repr__(self) -> str:
        desc:str = ""
        for i in range(self.vertex_count):
            desc += f"{self.vertex_at(i)} -> {self.neighbors_for_index(i)}\n"
        return desc
```

![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Graph.png?raw=true)

**Graph** 클래스는 여러 정점(vertices)과 여러 이음선(edges)으로 구성되어 있다. 그래프의 모든 정점을 항목으로 갖는 리스트(**self.\_vertices**:List[V])와, 모든 이음선을 항목으로 갖는 리스트(**self.\_edges**:List[List[Edge]])를 작성한다. 두 리스트는 동일한 인덱스 규칙을 갖는다. self.\_index 리스트의 x번째 항목은 x번째 정점에서 출발하는 edge로 구성되어 있다.

정점 정보 입력은 Graph 객체를 생성할 때 이루어지는 반면, 이음선 정보 입력은 **add_edge** 메서드를 통해 이루어진다. add_edge 메서드의 매개변수로 Edge 객체를 일일이 입력하는 과정은 번거로우므로, 헬퍼 메서드를 사용해 정점 인덱스 또는 정점 이름을 통해 입력받는다.

## 출력

정점으로 str 타입을 사용한다.

<u>graph.py (계속)</u>

```python
if __name__ == "__main__":
    city_graph:Graph[str] = Graph(
        ["시애틀"       , "샌프란시스코", "로스앤젤레스",
         "리버사이드"   , "피닉스"      , "시카고",
         "보스턴"       , "뉴욕"        , "애틀랜타",
         "마이애미"     , "댈러스"      , "휴스턴",
         "디트로이트"   , "필라델피아"  , "워싱턴"])
                                   
    city_graph.add_edge_by_vertices("시애틀"      , "시카고")
    city_graph.add_edge_by_vertices("시애틀"      , "샌프란시스코")
    city_graph.add_edge_by_vertices("샌프란시스코", "리버사이드")
    city_graph.add_edge_by_vertices("샌프란시스코", "로스앤젤레스")
    city_graph.add_edge_by_vertices("로스앤젤레스", "리버사이드")
    city_graph.add_edge_by_vertices("로스앤젤레스", "피닉스")
    city_graph.add_edge_by_vertices("리버사이드"  , "피닉스")
    city_graph.add_edge_by_vertices("리버사이드"  , "시카고")
    city_graph.add_edge_by_vertices("피닉스"      , "댈러스")
    city_graph.add_edge_by_vertices("피닉스"      , "휴스턴")
    city_graph.add_edge_by_vertices("댈러스"      , "시카고")
    city_graph.add_edge_by_vertices("댈러스"      , "애틀랜타")
    city_graph.add_edge_by_vertices("댈러스"      , "휴스턴")
    city_graph.add_edge_by_vertices("휴스턴"      , "애틀랜타")
    city_graph.add_edge_by_vertices("휴스턴"      , "마이애미")
    city_graph.add_edge_by_vertices("애틀랜타"    , "시카고")
    city_graph.add_edge_by_vertices("애틀랜타"    , "워싱턴")
    city_graph.add_edge_by_vertices("애틀랜타"    , "마이애미")
    city_graph.add_edge_by_vertices("마이애미"    , "워싱턴")
    city_graph.add_edge_by_vertices("시카고"      , "디트로이트")
    city_graph.add_edge_by_vertices("디트로이트"  , "보스턴")
    city_graph.add_edge_by_vertices("디트로이트"  , "워싱턴")
    city_graph.add_edge_by_vertices("디트로이트"  , "뉴욕")
    city_graph.add_edge_by_vertices("보스턴"      , "뉴욕")
    city_graph.add_edge_by_vertices("뉴욕"        , "필라델피아")
    city_graph.add_edge_by_vertices("필라델피아"  , "워싱턴")
    
    print(city_graph) 
```

<s>Console</s>

```
시애틀 -> ['시카고', '샌프란시스코']
샌프란시스코 -> ['시애틀', '리버사이드', '로스앤젤레스']
로스앤젤레스 -> ['샌프란시스코', '리버사이드', '피닉스']
리버사이드 -> ['샌프란시스코', '로스앤젤레스', '피닉스', '시카고']    
피닉스 -> ['로스앤젤레스', '리버사이드', '댈러스', '휴스턴']
시카고 -> ['시애틀', '리버사이드', '댈러스', '애틀랜타', '디트로이트']
보스턴 -> ['디트로이트', '뉴욕']
뉴욕 -> ['디트로이트', '보스턴', '필라델피아']
애틀랜타 -> ['댈러스', '휴스턴', '시카고', '워싱턴', '마이애미']
마이애미 -> ['휴스턴', '애틀랜타', '워싱턴']
댈러스 -> ['피닉스', '시카고', '애틀랜타', '휴스턴']
휴스턴 -> ['피닉스', '댈러스', '애틀랜타', '마이애미']
디트로이트 -> ['시카고', '보스턴', '워싱턴', '뉴욕']
필라델피아 -> ['뉴욕', '워싱턴']
워싱턴 -> ['애틀랜타', '마이애미', '디트로이트', '필라델피아']
```

## 최단 경로

Graph 클래스는 비가중 그래프이므로 이음선의 수가 최소가 되는 경로를 찾는다. 이는 2장에서 학습했던 [너비 우선 탐색](https://b31l.github.io/2022/01/12/Week-2/#-%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89bfs)을 재사용해 구할 수 있다.

**goal_test**는 lambda를, **successors**는 Graph 클래스의 **neighbors_for_vertex** 메서드를 사용해 구현한다.

| 매개변수                            | 인자                            | 설명      |
| ----------------------------------- | ------------------------------- | --------- |
| `initial`:T                         | root                            | 시작 지점 |
| `goal_test`:Callable[[T], bool]     | lambda x: x == goal             | 목표 지점 |
| `successors`:Callable[[T], List[T]] | city_graph.neighbors_for_vertex | 다음 지점 |

**bfs** 함수에 적절한 매개변수를 입력한 뒤, **node_to_path** 함수를 통해 반환값을 리스트로 변환하고 출력한다.

<u>graph.py</u>

```python
if __name__ == "__main__":
	from generic_search import bfs, Node, node_to_path
    
    root = "보스턴"
    goal = "마이애미"

    bfs_result:Optional[Node[V]] = bfs(root, 
                                       lambda x: x == goal, 
                                       city_graph.neighbors_for_vertex)
    if bfs_result is None:
        print("너비 우선 탐색으로 답을 찾을 수 없습니다!")
    else:
        path:List[V] = node_to_path(bfs_result)
        print(f"{root}에서 {goal}까지 최단 경로: ")
        print(path)
```

<s>Console</s>

```
보스턴에서 마이애미까지 최단 경로:
['보스턴', '디트로이트', '워싱턴', '마이애미']
```

> *Note*
>
> 상위 디렉터리의 패키지에 접근하기 위해서는 **sys** 모듈을 사용해 다음과 같이 import한다.
>
> ```python
> import sys
> sys.path.insert(0, '.')
> from ch2.generic_search import bfs, Node, node_to_path
> ```

---

# 가중 그래프

## 재정의

기존의 Edge와 Graph 클래스를 재정의하고, 가중치 속성을 추가한다.

| 속성   | 타입          |
| ------ | ------------- |
| 그래프 | WeightedGraph |
| 정점   | V             |
| 이음선 | WeightedEdge  |
| 가중치 | float         |

<u>weighted_edge.py</u>

```python
from __future__ import annotations
from dataclasses import dataclass
from edge import Edge


@dataclass
class WeightedEdge(Edge):
    weight:float

    def reversed(self) -> WeightedEdge:
        return WeightedEdge(self.v, self.u, self.weight)

    def __lt__(self, other:WeightedEdge) -> bool:
        return self.weight < other.weight

    def __repr__(self) -> str:
        return f"{self.u} {self.weight} -> {self.v}"
```

가중치 매개변수를 추가로 가지므로 기존 메서드들을 재정의해 인자 조건을 만족시킨다. 또한 **\__lt__()** 특수 메서드를 구현해 두 이음선의 가중치를 비교하는 기능을 추가한다.

```python
from typing import TypeVar, Generic, List, Tuple
from graph import Graph
from weighted_edge import WeightedEdge

V = TypeVar("V")    # 그래프 정점(vertice) 타입


class WeightedGraph(Generic[V], Graph[V]):
    def __init__(self, vertices:List[V] = []) -> None:
        self._vertices:List[V] = vertices
        self._edges:List[List[WeightedEdge]] = [[] for _ in vertices]

    def add_edge_by_indices(self, u:int, v:int, weight:float) -> None:
        edge:WeightedEdge = WeightedEdge(u, v, weight)
        self.add_edge(edge)

    def add_edge_by_vertices(self, first:V, second:V, weight:float) -> None:
        u:int = self._vertices.index(first)
        v:int = self._vertices.index(second)
        self.add_edge_by_indices(u, v, weight)

    def neighbors_for_index_with_weights(self, index:int) -> List[Tuple[V, float]]:
        distance_tuples:List[Tuple[V, float]] = []
        for edge in self.edges_for_index(index):
            distance_tuples.append((self.vertex_at(edge.v), edge.weight))
        return distance_tuples

    def __repr__(self) -> str:
        desc:str = ""
        for i in range(self.vertex_count):
            desc += f"{self.vertex_at(i)} -> {self.neighbors_for_index_with_weights(i)}\n"
        return desc
```

Edge 대신 WeightedEdge를 사용하므로 기존 메서드들을 재정의해 인자 조건을 만족시킨다.

## 출력

가중치 인자를 추가로 입력한다.

<u>weighted_graph.py (계속)</u>

```python
if __name__ == "__main__":
    city_graph2:WeightedGraph[str] = WeightedGraph(
        ["시애틀"       , "샌프란시스코", "로스앤젤레스",
         "리버사이드"   , "피닉스"      , "시카고",
         "보스턴"       , "뉴욕"        , "애틀랜타",
         "마이애미"     , "댈러스"      , "휴스턴",
         "디트로이트"   , "필라델피아"  , "워싱턴"])
                                   
    city_graph2.add_edge_by_vertices("시애틀"      , "시카고"      , 1737)
    city_graph2.add_edge_by_vertices("시애틀"      , "샌프란시스코", 678)
    city_graph2.add_edge_by_vertices("샌프란시스코", "리버사이드"  , 386)
    city_graph2.add_edge_by_vertices("샌프란시스코", "로스앤젤레스", 348)
    city_graph2.add_edge_by_vertices("로스앤젤레스", "리버사이드"  , 50)
    city_graph2.add_edge_by_vertices("로스앤젤레스", "피닉스"      , 357)
    city_graph2.add_edge_by_vertices("리버사이드"  , "피닉스"      , 307)
    city_graph2.add_edge_by_vertices("리버사이드"  , "시카고"      , 1704)
    city_graph2.add_edge_by_vertices("피닉스"      , "댈러스"      , 887)
    city_graph2.add_edge_by_vertices("피닉스"      , "휴스턴"      , 1015)
    city_graph2.add_edge_by_vertices("댈러스"      , "시카고"      , 805)
    city_graph2.add_edge_by_vertices("댈러스"      , "애틀랜타"    , 721)
    city_graph2.add_edge_by_vertices("댈러스"      , "휴스턴"      , 225)
    city_graph2.add_edge_by_vertices("휴스턴"      , "애틀랜타"    , 702)
    city_graph2.add_edge_by_vertices("휴스턴"      , "마이애미"    , 968)
    city_graph2.add_edge_by_vertices("애틀랜타"    , "시카고"      , 588)
    city_graph2.add_edge_by_vertices("애틀랜타"    , "워싱턴"      , 543)
    city_graph2.add_edge_by_vertices("애틀랜타"    , "마이애미"    , 604)
    city_graph2.add_edge_by_vertices("마이애미"    , "워싱턴"      , 923)
    city_graph2.add_edge_by_vertices("시카고"      , "디트로이트"  , 238)
    city_graph2.add_edge_by_vertices("디트로이트"  , "보스턴"      , 613)
    city_graph2.add_edge_by_vertices("디트로이트"  , "워싱턴"      , 396)
    city_graph2.add_edge_by_vertices("디트로이트"  , "뉴욕"        , 482)
    city_graph2.add_edge_by_vertices("보스턴"      , "뉴욕"        , 190)
    city_graph2.add_edge_by_vertices("뉴욕"        , "필라델피아"  , 81)
    city_graph2.add_edge_by_vertices("필라델피아"  , "워싱턴"      , 123)
    
    print(city_graph2)
```

<s>Console</s>

```
시애틀 -> [('시카고', 1737), ('샌프란시스코', 678)]
샌프란시스코 -> [('시애틀', 678), ('리버사이드', 386), ('로스앤젤레스', 348)]
로스앤젤레스 -> [('샌프란시스코', 348), ('리버사이드', 50), ('피닉스', 357)]
리버사이드 -> [('샌프란시스코', 386), ('로스앤젤레스', 50), ('피닉스', 307), ('시카고', 1704)]
피닉스 -> [('로스앤젤레스', 357), ('리버사이드', 307), ('댈러스', 887), ('휴스턴', 1015)]
시카고 -> [('시애틀', 1737), ('리버사이드', 1704), ('댈러스', 805), ('애틀랜타', 588), ('디트로이트', 238)]
보스턴 -> [('디트로이트', 613), ('뉴욕', 190)]
뉴욕 -> [('디트로이트', 482), ('보스턴', 190), ('필라델피아', 81)]
애틀랜타 -> [('댈러스', 721), ('휴스턴', 702), ('시카고', 588), ('워싱턴', 543), ('마이애미', 604)]
마이애미 -> [('휴스턴', 968), ('애틀랜타', 604), ('워싱턴', 923)]
댈러스 -> [('피닉스', 887), ('시카고', 805), ('애틀랜타', 721), ('휴스턴', 225)]
휴스턴 -> [('피닉스', 1015), ('댈러스', 225), ('애틀랜타', 702), ('마이애미', 968)]
디트로이트 -> [('시카고', 238), ('보스턴', 613), ('워싱턴', 396), ('뉴욕', 482)]
필라델피아 -> [('뉴욕', 81), ('워싱턴', 123)]
워싱턴 -> [('애틀랜타', 543), ('마이애미', 923), ('디트로이트', 396), ('필라델피아', 123)]
```

## 프림 알고리즘

프림 알고리즘은 그래프의 모든 정점을 최소 이음선 및 최소 가중치를 사용해 연결하는 방법을 제시한다.

- 최소 이음선

  순환 그래프를 **비순환적**(acyclic)인 **신장 트리**(spanning tree)로 수정한다. 이음선 가지치기를 통해 **사이클**(cycle)을 제거할 수 있다.

- 최소 가중치

  **최소 신장 트리**(minimum spanning tree)는 가중치 그래프의 모든 정점을 최소 비용으로 연결한다.

프림 알고리즘은 각 정점에 대해 가장 낮은 가중치를 가진 이음선만을 선택하므로 **탐욕적**이다.

|                         순환 그래프                          |                          신장 트리                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Edge2.png?raw=true) | ![](https://github.com/B31l/B31l.github.io/blob/master/img/Classic/Edge3.png?raw=true) |

<u>priority_queue.py</u>

```python
from typing import TypeVar, Generic, List
from heapq import heappush, heappop

T = TypeVar("T")


class PriorityQueue(Generic[T]):
    def __init__(self) -> None:
        self._container:List[T] = []

    @property
    def empty(self) -> bool:
        return not self._container

    def push(self, item:T) -> None:
        heappush(self._container, item)

    def pop(self) -> T:
        return heappop(self._container)

    def __repr__(self) -> str:
        return repr(self._container)
```

<u>mst.py</u>

```python
from typing import TypeVar, List, Optional
from weighted_graph import WeightedGraph
from weighted_edge import WeightedEdge
from priority_queue import PriorityQueue

V = TypeVar("V")    # 그래프 정점(vertice) 타입
WeightedPath = List[WeightedEdge]


def total_weight(wp:WeightedPath) -> float:
    return sum([e.weight for e in wp])


def mst(wg:WeightedGraph[V], start:int = 0) -> Optional[WeightedPath]:
    """minimum spanning tree"""

    # 시작 정점이 유효하지 않은 경우 None
    if start > (wg.vertex_count - 1) or start < 0:
        return None

    result:WeightedPath = []
    pq:PriorityQueue[WeightedEdge] = PriorityQueue()
    visited:List[bool] = [False] * wg.vertex_count  # 방문한 곳
    def visit(index:int):
        visited[index] = True
        for edge in wg.edges_for_index(index):
            if not visited[edge.v]:
                pq.push(edge)

    visit(start)
    while not pq.empty:
        edge = pq.pop()
        if visited[edge.v]:
            continue
        result.append(edge)
        visit(edge.v)
    return result


def print_weighted_path(wg:WeightedGraph, wp:WeightedPath) -> None:
    for edge in wp:
        print(f"{wg.vertex_at(edge.u)} {edge.weight}> {wg.vertex_at(edge.v)}")
    print(f"가중치 총합: {total_weight(wp)}")
```

- **시작 정점**(start)을 최소 신장 트리에 추가한다.

- 현재 정점에 연결된 최소 가중치의 이음선을 찾는다. 이 과정에서 우선순위 큐가 사용된다. 이음선에 연결된 정점을 최소 신장 트리에 추가하며, 이미 추가된 정점이라면 다음 우선순위를 가진 이음선을 탐색한다. 우선순위 큐가 빌 때까지(모든 정점이 최소 신장 트리에 추가될 때까지) 이 과정을 반복한다.

<u>mst.py (계속)</u>

```python
if __name__ == "__main__":
    ...
    result:Optional[WeightedPath] = mst(city_graph2)
    if result is None:
        print("최소 신장 트리로 답을 찾을 수 없습니다!")
    else:
        print_weighted_path(city_graph2, result)
```

<s>Console</s>

```
시애틀 678> 샌프란시스코
샌프란시스코 348> 로스앤젤레스
로스앤젤레스 50> 리버사이드   
리버사이드 307> 피닉스        
피닉스 887> 댈러스
댈러스 225> 휴스턴
휴스턴 702> 애틀랜타
애틀랜타 543> 워싱턴
워싱턴 123> 필라델피아
필라델피아 81> 뉴욕
뉴욕 190> 보스턴
워싱턴 396> 디트로이트
디트로이트 238> 시카고
애틀랜타 604> 마이애미
가중치 총합: 5372
```

> *Note*
>
> n개의 정점을 모두 연결하기 위해 필요한 이음선의 개수는 n-1개이다. 위 문제는 15개의 정점을 사용하므로 그래프의 신장 트리는 14개의 이음선을 가진다. 모든 정점을 연결하는 과정은 14번 이루어지며, 매번 최소 가중치만을 선택하므로 생성되는 신장 트리는 항상 다른 신장 트리보다 작거나 같은 가중치 총합을 가진다. 따라서 프림 알고리즘은 항상 최소 신장 트리를 생성한다.

## 다익스트라 알고리즘

비가중 그래프의 최단 경로는 너비 우선 탐색을 통해 구할 수 있었다. 가중 그래프의 최단 경로는 이음선의 수가 아닌, 가중치의 합을 기준으로 계산한다. 다익스트라 알고리즘은 그래프의 모든 정점을 최소 이음선 및 최소 가중치를 사용해 연결하는 방법을 제시한다.

다익스트라 알고리즘은 다른 모든 정점으로의 최단 경로(이음선의 모음)와, 그 길이를 반환한다.

<u>dijkstra.py</u>

```python
from __future__ import annotations
from turtle import distance
from typing import TypeVar, List, Optional, Tuple, Dict
from dataclasses import dataclass
from priority_queue import PriorityQueue
from mst import WeightedPath, print_weighted_path
from weighted_graph import WeightedGraph
from weighted_edge import WeightedEdge
from priority_queue import PriorityQueue

V = TypeVar("V")    # 그래프 정점(vertice) 타입


@dataclass
class DijkstraNode:
    vertex:int
    distance:float

    def __lt__(self, other:DijkstraNode) -> bool:
        return self.distance < other.distance

    def __eq__(self, other:DijkstraNode) -> bool:
        return self.distance == other.distance


def dijkstra(wg:WeightedGraph[V], root:V) -> Tuple[List[Optional[float]], Dict[int, WeightedEdge]]:
    first:int = wg.index_of(root)
    distances:List[Optional[float]] = [None] * wg.vertex_count
    distances[first] = 0
    path_dict:Dict[int, WeightedEdge] = {}
    pq:PriorityQueue[DijkstraNode] = PriorityQueue()
    pq.push(DijkstraNode(first, 0))

    while not pq.empty:
        u:int = pq.pop().vertex
        dist_u:float = distances[u]
        for we in wg.edges_for_index(u):
            dist_v:float = distances[we.v]
            if dist_v is None or dist_v > we.weight + dist_u:
                distances[we.v] = we.weight + dist_u
                path_dict[we.v] = we
                pq.push(DijkstraNode(we.v, we.weight + dist_u))
    return distances, path_dict


def distance_array_to_vertex_dict(wg:WeightedGraph[V], distances:List[Optional[float]]) -> Dict[V, Optional[float]]:
    distance_dict:Dict[V, Optional[float]] = {}
    for i in range(len(distances)):
        distance_dict[wg.vertex_at(i)] = distances[i]
    return distance_dict


def path_dict_to_path(start:int, end:int, path_dict:Dict[int, WeightedEdge]) -> WeightedPath:
    if len(path_dict) == 0:
        return []
    edge_path:WeightedPath = []
    e:WeightedEdge = path_dict[end]
    edge_path.append(e)
    while e.u != start:
        e = path_dict[e.u]
        edge_path.append(e)
    return list(reversed(edge_path))
```

- **DijkstraNode**는 현재까지 탐색된 정점의 인덱스와 그 거리를 저장한다. 특수 메서들를 사용해 거리를 기준으로 비교하는 기능을 추가한다. 
- distances 리스트는 root에서 각 정점까지의 거리를 저장한다.
- root의 DijkstraNode를 우선순위 큐에 **push**한다.
- 우선순위 큐에서 가장 가까운 정점을 pop한 뒤, 현재 정점(u)으로 설정한다. 이후 현재 정점에 연결된 모든 이음선을 대상으로 탐색을 시도하며, 새로운 최단 경로가 발견될 때마다 거리와 우선순위 큐를 갱신한다. 우선순위 큐가 빌 때까지 이 과정을 반복한다.

<u>dijkstra.py (계속)</u>

```python
if __name__ == "__main__":
   	 ...
    root = "로스앤젤레스"
    distances, path_dict = dijkstra(city_graph2, root)
    name_distance:Dict[str, Optional[int]] = distance_array_to_vertex_dict(city_graph2, distances)
    print(f"{root}에서의 거리:")
    for key, value in name_distance.items():
        print(f"{key} : {value}")
    print("")

    goal = "보스턴"
    print(f"{root}에서 {goal}까지의 최단 경로:")
    path:WeightedPath = path_dict_to_path(city_graph2.index_of(root), 
                                          city_graph2.index_of(goal), 
                                          path_dict)
    print_weighted_path(city_graph2, path)
```

**distance_array_to_vertex_dict**는 헬퍼 함수로, 작성한 그래프를 다익스트라 알고리즘의 인자로 변환한다. **path_dict_to_path**는 반환값을 출력한다(너비 우선 탐색에서 사용했던 node_to_path 함수와 유사).

<s>Console</s>

```
로스앤젤레스에서의 거리:
시애틀 : 1026     
샌프란시스코 : 348
로스앤젤레스 : 0  
리버사이드 : 50   
피닉스 : 357      
시카고 : 1754     
보스턴 : 2605
뉴욕 : 2474
애틀랜타 : 1965
마이애미 : 2340
댈러스 : 1244
휴스턴 : 1372
디트로이트 : 1992
필라델피아 : 2511
워싱턴 : 2388

로스앤젤레스에서 보스턴까지의 최단 경로:
로스앤젤레스 50> 리버사이드
리버사이드 1704> 시카고
시카고 238> 디트로이트
디트로이트 613> 보스턴
가중치 총합: 2605
```

