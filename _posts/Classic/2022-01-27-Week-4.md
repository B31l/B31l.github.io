---
layout: post
meta: "Week-4"
title: "Week-4: 그래프 문제"
categories: Classic
tags: Python
---

* content
{:toc}
# 그래프 문제

그래프 프레임워크를 구축한다.

## Edge

<u>edge.py</u>

```python
from __future__ import annotations
from dataclasses import dataclass


@dataclass  # __init__ 자동 생성
class Edge:
    u:int   # 정점(from)
    v:int   # 정점(to)

    def reversed(self) -> Edge:
        return Edge(self.v, self.u)

    def __repr__(self) -> str:
        return f"{self.u} -> {self.v}"
```



## Graph

<u>graph.py</u>

```python
from typing import TypeVar, Generic, List, Optional
from edge import Edge

V = TypeVar("V")    # 그래프 정점(vertice) 타입


class Graph(Generic[V]):
    def __init__(self, vertices:List[V] = []) -> None:
        self._vertices:List[V] = vertices
        self._edges:List[List[Edge]] = [[] for _ in vertices]

    @property
    def vertex_count(self) -> int:
        return len(self._vertices)          # 반환: 정점의 수

    @property
    def edge_count(self) -> int:
        return sum(map(len, self._edges))   # 반환: Edge의 수
        # map 함수를 통해 _edges 리스트의 각 항목의 길이를 구한 뒤, sum 함수를 사용해 모두 합친다. 

    def add_vertex(self, vertex:V) -> int:
        self._vertices.append(vertex)
        self._edges.append([])
        return self.vertex_count - 1        # 반환: 정점의 인덱스

    # Edge 추가
    def add_edge(self, edge:Edge) -> None:
        self._edges[edge.u].append(edge)
        self._edges[edge.v].append(edge.reversed())
        # example
        # 정점 a: a -> b
        # 정점 b: b -> a

    # 정점 인덱스를 사용하여 Edge 추가
    def add_edge_by_indices(self, u:int, v:int) -> None:
        edge:Edge = Edge(u, v)
        self.add_edge(edge)

    # 정점 인덱스를 참조하여 Edge 추가
    def add_edge_by_vertices(self, first:V, second:V) -> None:
        u:int = self._vertices.index(first)
        v:int = self._vertices.index(second)
        self.add_edge_by_indices(u, v)
        # index 함수를 사용하면 위치를 찾을 수 있다.

    # 인덱스 -> 정점
    def vertex_at(self, index:int) -> V:
        return self._vertices[index]

    # 정점 -> 인덱스
    def index_of(self, vertex:V) -> int:
        return self._vertices.index(vertex)

    # 정점 인덱스에 연결된 정점
    def neighbors_for_index(self, index:int) -> List[V]:
        return list(map(self.vertex_at, [e.v for e in self._edges[index]]))
        # 엣지의 모든 끝 점(v)의 각 인덱스에 해당하는 정점의 리스트

    # 정점에 연결된 이웃 정점
    def neighbors_for_vertex(self, vertex:V) -> List[V]:
        return self.neighbors_for_index(self.index_of(vertex))

    # 정점 인덱스에 연결된 Edge
    def edges_for_index(self, index:int) -> List[Edge]:
        return self._edges[index]

    # 정점에 연결된 Edge
    def edges_for_vertex(self, vertex:V) -> List[Edge]:
        return self.edges_for_index(self.index_of(vertex))

    # 그래프 출력
    def __repr__(self) -> str:
        desc:str = ""
        for i in range(self.vertex_count):
            desc += f"{self.vertex_at(i)} -> {self.neighbors_for_index(i)}\n"
        return desc
```



<u>graph.py: main</u>

```python
if __name__ == "__main__":
    city_graph:Graph[str] = Graph(
        ["시애틀"       , "샌프란시스코", "로스앤젤레스",
         "리버사이드"   , "피닉스"      , "시카고",
         "보스턴"       , "뉴욕"        , "애틀랜타",
         "마이애미"     , "댈러스"      , "휴스턴",
         "디트로이트"   , "필라델피아"  , "워싱턴"])
                                   
    city_graph.add_edge_by_vertices("시애틀"      , "시카고")
    city_graph.add_edge_by_vertices("시애틀"      , "샌프란시스코")
    city_graph.add_edge_by_vertices("샌프란시스코", "리버사이드")
    city_graph.add_edge_by_vertices("샌프란시스코", "로스앤젤레스")
    city_graph.add_edge_by_vertices("로스앤젤레스", "리버사이드")
    city_graph.add_edge_by_vertices("로스앤젤레스", "피닉스")
    city_graph.add_edge_by_vertices("리버사이드"  , "피닉스")
    city_graph.add_edge_by_vertices("리버사이드"  , "시카고")
    city_graph.add_edge_by_vertices("피닉스"      , "댈러스")
    city_graph.add_edge_by_vertices("피닉스"      , "휴스턴")
    city_graph.add_edge_by_vertices("댈러스"      , "시카고")
    city_graph.add_edge_by_vertices("댈러스"      , "애틀랜타")
    city_graph.add_edge_by_vertices("댈러스"      , "휴스턴")
    city_graph.add_edge_by_vertices("휴스턴"      , "애틀랜타")
    city_graph.add_edge_by_vertices("휴스턴"      , "마이애미")
    city_graph.add_edge_by_vertices("애틀랜타"    , "시카고")
    city_graph.add_edge_by_vertices("애틀랜타"    , "워싱턴")
    city_graph.add_edge_by_vertices("애틀랜타"    , "마이애미")
    city_graph.add_edge_by_vertices("마이애미"    , "워싱턴")
    city_graph.add_edge_by_vertices("시카고"      , "디트로이트")
    city_graph.add_edge_by_vertices("디트로이트"  , "보스턴")
    city_graph.add_edge_by_vertices("디트로이트"  , "워싱턴")
    city_graph.add_edge_by_vertices("디트로이트"  , "뉴욕")
    city_graph.add_edge_by_vertices("보스턴"      , "뉴욕")
    city_graph.add_edge_by_vertices("뉴욕"        , "필라델피아")
    city_graph.add_edge_by_vertices("필라델피아"  , "워싱턴")
    
    print(city_graph)
```



<u>terminal</u>

```
시애틀 -> ['시카고', '샌프란시스코']
샌프란시스코 -> ['시애틀', '리버사이드', '로스앤젤레스']
로스앤젤레스 -> ['샌프란시스코', '리버사이드', '피닉스']
리버사이드 -> ['샌프란시스코', '로스앤젤레스', '피닉스', '시카고']    
피닉스 -> ['로스앤젤레스', '리버사이드', '댈러스', '휴스턴']
시카고 -> ['시애틀', '리버사이드', '댈러스', '애틀랜타', '디트로이트']
보스턴 -> ['디트로이트', '뉴욕']
뉴욕 -> ['디트로이트', '보스턴', '필라델피아']
애틀랜타 -> ['댈러스', '휴스턴', '시카고', '워싱턴', '마이애미']
마이애미 -> ['휴스턴', '애틀랜타', '워싱턴']
댈러스 -> ['피닉스', '시카고', '애틀랜타', '휴스턴']
휴스턴 -> ['피닉스', '댈러스', '애틀랜타', '마이애미']
디트로이트 -> ['시카고', '보스턴', '워싱턴', '뉴욕']
필라델피아 -> ['뉴욕', '워싱턴']
워싱턴 -> ['애틀랜타', '마이애미', '디트로이트', '필라델피아']
```



## 최단 경로 찾기

<u>graph.py: main(계속)</u>

```python
import sys
sys.path.insert(0, '.')
from ch2.generic_search import bfs, Node, node_to_path
```



너비 우선 탐색

<u>graph.py: main(계속)</u>

```python
bfs_result:Optional[Node[V]] = bfs("보스턴", 
                                   lambda x: x == "마이애미", 
                                   city_graph.neighbors_for_vertex)
if bfs_result is None:
    print("너비 우선 탐색으로 답을 찾을 수 없습니다!")
else:
    path:List[V] = node_to_path(bfs_result)
    print("보스턴에서 마이애미까지 최단 경로: ")
    print(path)
```



<u>terminal</u>

```
보스턴에서 마이애미까지 최단 경로:
['보스턴', '디트로이트', '워싱턴', '마이애미']
```



---

# 가중치

## WeightedEdge

<u>weighted_edge.py</u>

```python
from __future__ import annotations
from dataclasses import dataclass
from edge import Edge


@dataclass
class WeightedEdge(Edge):
    weight:float

    def reversed(self) -> WeightedEdge:
        return WeightedEdge(self.v, self.u, self.weight)

    def __lt__(self, other:WeightedEdge) -> bool:
        return self.weight < other.weight

    def __repr__(self) -> str:
        return f"{self.u} {self.weight} -> {self.v}"
```



## WeightedGraph

<u>weighted_graph.py</u>

```python
from typing import TypeVar, Generic, List, Tuple
from graph import Graph
from weighted_edge import WeightedEdge

V = TypeVar("V")    # 그래프 정점(vertice) 타입


class WeightedGraph(Generic[V], Graph[V]):
    def __init__(self, vertices:List[V] = []) -> None:
        self._vertices:List[V] = vertices
        self._edges:List[List[WeightedEdge]] = [[] for _ in vertices]

    def add_edge_by_indices(self, u:int, v:int, weight:float) -> None:
        edge:WeightedEdge = WeightedEdge(u, v, weight)
        self.add_edge(edge)

    def add_edge_by_vertices(self, first:V, second:V, weight:float) -> None:
        u:int = self._vertices.index(first)
        v:int = self._vertices.index(second)
        self.add_edge_by_indices(u, v, weight)

    def neighbors_for_index_with_weights(self, index:int) -> List[Tuple[V, float]]:
        distance_tuples:List[Tuple[V, float]] = []
        for edge in self.edges_for_index(index):
            distance_tuples.append((self.vertex_at(edge.v), edge.weight))
        return distance_tuples

    def __repr__(self) -> str:
        desc:str = ""
        for i in range(self.vertex_count):
            desc += f"{self.vertex_at(i)} -> {self.neighbors_for_index_with_weights(i)}\n"
        return desc
```



<u>weighted_graph.py: main</u>

```python
if __name__ == "__main__":
    city_graph2:WeightedGraph[str] = WeightedGraph(
        ["시애틀"       , "샌프란시스코", "로스앤젤레스",
         "리버사이드"   , "피닉스"      , "시카고",
         "보스턴"       , "뉴욕"        , "애틀랜타",
         "마이애미"     , "댈러스"      , "휴스턴",
         "디트로이트"   , "필라델피아"  , "워싱턴"])
                                   
    city_graph2.add_edge_by_vertices("시애틀"      , "시카고"      , 1737)
    city_graph2.add_edge_by_vertices("시애틀"      , "샌프란시스코", 678)
    city_graph2.add_edge_by_vertices("샌프란시스코", "리버사이드"  , 386)
    city_graph2.add_edge_by_vertices("샌프란시스코", "로스앤젤레스", 348)
    city_graph2.add_edge_by_vertices("로스앤젤레스", "리버사이드"  , 50)
    city_graph2.add_edge_by_vertices("로스앤젤레스", "피닉스"      , 357)
    city_graph2.add_edge_by_vertices("리버사이드"  , "피닉스"      , 307)
    city_graph2.add_edge_by_vertices("리버사이드"  , "시카고"      , 1704)
    city_graph2.add_edge_by_vertices("피닉스"      , "댈러스"      , 887)
    city_graph2.add_edge_by_vertices("피닉스"      , "휴스턴"      , 1015)
    city_graph2.add_edge_by_vertices("댈러스"      , "시카고"      , 805)
    city_graph2.add_edge_by_vertices("댈러스"      , "애틀랜타"    , 721)
    city_graph2.add_edge_by_vertices("댈러스"      , "휴스턴"      , 225)
    city_graph2.add_edge_by_vertices("휴스턴"      , "애틀랜타"    , 702)
    city_graph2.add_edge_by_vertices("휴스턴"      , "마이애미"    , 968)
    city_graph2.add_edge_by_vertices("애틀랜타"    , "시카고"      , 588)
    city_graph2.add_edge_by_vertices("애틀랜타"    , "워싱턴"      , 543)
    city_graph2.add_edge_by_vertices("애틀랜타"    , "마이애미"    , 604)
    city_graph2.add_edge_by_vertices("마이애미"    , "워싱턴"      , 923)
    city_graph2.add_edge_by_vertices("시카고"      , "디트로이트"  , 238)
    city_graph2.add_edge_by_vertices("디트로이트"  , "보스턴"      , 613)
    city_graph2.add_edge_by_vertices("디트로이트"  , "워싱턴"      , 396)
    city_graph2.add_edge_by_vertices("디트로이트"  , "뉴욕"        , 482)
    city_graph2.add_edge_by_vertices("보스턴"      , "뉴욕"        , 190)
    city_graph2.add_edge_by_vertices("뉴욕"        , "필라델피아"  , 81)
    city_graph2.add_edge_by_vertices("필라델피아"  , "워싱턴"      , 123)
    
    print(city_graph2)
```



<u>terminal</u>

```
시애틀 -> [('시카고', 1737), ('샌프란시스코', 678)]
샌프란시스코 -> [('시애틀', 678), ('리버사이드', 386), ('로스앤젤레스', 348)]
로스앤젤레스 -> [('샌프란시스코', 348), ('리버사이드', 50), ('피닉스', 357)]
리버사이드 -> [('샌프란시스코', 386), ('로스앤젤레스', 50), ('피닉스', 307), ('시카고', 1704)]
피닉스 -> [('로스앤젤레스', 357), ('리버사이드', 307), ('댈러스', 887), ('휴스턴', 1015)]
시카고 -> [('시애틀', 1737), ('리버사이드', 1704), ('댈러스', 805), ('애틀랜타', 588), ('디트로이트', 238)]
보스턴 -> [('디트로이트', 613), ('뉴욕', 190)]
뉴욕 -> [('디트로이트', 482), ('보스턴', 190), ('필라델피아', 81)]
애틀랜타 -> [('댈러스', 721), ('휴스턴', 702), ('시카고', 588), ('워싱턴', 543), ('마이애미', 604)]
마이애미 -> [('휴스턴', 968), ('애틀랜타', 604), ('워싱턴', 923)]
댈러스 -> [('피닉스', 887), ('시카고', 805), ('애틀랜타', 721), ('휴스턴', 225)]
휴스턴 -> [('피닉스', 1015), ('댈러스', 225), ('애틀랜타', 702), ('마이애미', 968)]
디트로이트 -> [('시카고', 238), ('보스턴', 613), ('워싱턴', 396), ('뉴욕', 482)]
필라델피아 -> [('뉴욕', 81), ('워싱턴', 123)]
워싱턴 -> [('애틀랜타', 543), ('마이애미', 923), ('디트로이트', 396), ('필라델피아', 123)]
```



## 프림 알고리즘

우선순위 큐

```python
from typing import TypeVar, Generic, List
from heapq import heappush, heappop

T = TypeVar("T")


class PriorityQueue(Generic[T]):
    def __init__(self) -> None:
        self._container:List[T] = []

    @property
    def empty(self) -> bool:
        return not self._container

    def push(self, item:T) -> None:
        heappush(self._container, item)

    def pop(self) -> T:
        return heappop(self._container)

    def __repr__(self) -> str:
        return repr(self._container)
```



최소 신장 트리

```python

```



## 다익스트라 알고리즘

최단 경로 트리

```python
```



---

# 연습문제

## 📝 연습문제 4-1

1. *Q*

   그래프 프레임워크에 에지 및 정점 제거를 위한 메서드를 추가하라.

연습문제 4-1

## 📝 연습문제 4-2

1. *Q*

   그래프 프레임워크에 유향 그래프(digraph)를 사용할 수 있도록 코드를 추가하라.

연습문제 4-2

## 📝 연습문제 4-3

1. *Q*

   그래프 프레임워크를 사용하여 위키피디아 설명되어 있는 것과 같은 [쾨니히스베르크 다리 건너기 문제](https://namu.wiki/w/%EC%BE%A8%EB%8B%88%ED%9E%88%EC%8A%A4%EB%B2%A0%EB%A5%B4%ED%81%AC%20%EB%8B%A4%EB%A6%AC%20%EA%B1%B4%EB%84%88%EA%B8%B0%20%EB%AC%B8%EC%A0%9C)를 증명 또는 반증하라.

연습문제 4-3

