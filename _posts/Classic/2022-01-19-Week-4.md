---
layout: post
meta: "Week-4"
title: "Week-4: 그래프 문제"
categories: Classic
tags: Python
---

* content
{:toc}
# 그래프 문제

블라블라

---

# 그래픽 프레임워크

## Edge

```python
from __future__ import annotations
from dataclasses import dataclass


@dataclass  # __init__ 자동 생성
class Edge:
    u:int   # 정점(from)
    v:int   # 정점(to)

    def reversed(self) -> Edge:
        return Edge(self.v, self.u)

    def __repr__(self) -> str:
        return f"{self.u} -> {self.v}"
```



## Graph

```python
from typing import TypeVar, Generic, List, Optional
from edge import Edge

V = TypeVar("V")    # 그래프 정점(vertice) 타입


class Graph(Generic[V]):
    def __init__(self, vertices:List[V] = []) -> None:
        self._vertices:List[V] = vertices
        self._edges:List[List[Edge]] = [[] for _ in vertices]

    @property
    def vertex_count(self) -> int:
        return len(self._vertices)          # 반환: 정점의 수

    @property
    def edge_count(self) -> int:
        return sum(map(len, self._edges))   # 반환: Edge의 수
        # map 함수를 통해 _edges 리스트의 각 항목의 길이를 구한 뒤, sum 함수를 사용해 모두 합친다. 

    def add_vertex(self, vertex:V) -> int:
        self._vertices.append(vertex)
        self._edges.append([])
        return self.vertex_count - 1        # 반환: 정점의 인덱스

    # Edge 추가
    def add_edge(self, edge:Edge) -> None:
        self._edges[edge.u].append(edge)
        self._edges[edge.v].append(edge.reversed())
        # example
        # 정점 a: a -> b
        # 정점 b: b -> a

    # 정점 인덱스를 사용하여 Edge 추가
    def add_edge_by_indices(self, u:int, v:int) -> None:
        edge:Edge = Edge(u, v)
        self.add_edge(edge)

    # 정점 인덱스를 참조하여 Edge 추가
    def add_edge_by_vertices(self, first:V, second:V) -> None:
        u:int = self._vertices.index(first)
        v:int = self._vertices.index(second)
        self.add_edge_by_indices(u, v)
        # index 함수를 사용하면 위치를 찾을 수 있다.

    # 인덱스 -> 정점
    def vertex_at(self, index:int) -> V:
        return self._vertices[index]

    # 정점 -> 인덱스
    def index_of(self, vertex:V) -> int:
        return self._vertices.index(vertex)

    # 정점 인덱스에 연결된 정점
    def neighbors_for_index(self, index:int) -> List[V]:
        return list(map(self.vertex_at, [e.v for e in self._edges[index]]))
        # 엣지의 모든 끝 점(v)의 각 인덱스에 해당하는 정점의 리스트

    # 정점에 연결된 이웃 정점
    def neighbors_for_vertex(self, vertex:V) -> List[V]:
        return self.neighbors_for_index(self.index_of(vertex))

    # 정점 인덱스에 연결된 Edge
    def edges_for_index(self, index:int) -> List[Edge]:
        return self._edges[index]

    # 정점에 연결된 Edge
    def edges_for_vertex(self, vertex:V) -> List[Edge]:
        return self.edges_for_index(self.index_of(vertex))

    # 그래프 출력
    def __repr__(self) -> str:
        desc:str = ""
        for i in range(self.vertex_count):
            desc += f"{self.vertex_at(i)} -> {self.neighbors_for_index(i)}\n"
        return desc
```



```python
if __name__ == "__main__":
    city_graph:Graph[str] = Graph(
        ["시애틀"       , "샌프란시스코", "로스앤젤레스",
         "리버사이드"   , "피닉스"      , "시카고",
         "보스턴"       , "뉴욕"        , "애틀랜타",
         "마이애미"     , "댈러스"      , "휴스턴",
         "디트로이트"   , "필라델피아"  , "워싱턴"])
                                   
    city_graph.add_edge_by_vertices("시애틀"      , "시카고")
    city_graph.add_edge_by_vertices("시애틀"      , "샌프란시스코")
    city_graph.add_edge_by_vertices("샌프란시스코", "리버사이드")
    city_graph.add_edge_by_vertices("샌프란시스코", "로스앤젤레스")
    city_graph.add_edge_by_vertices("로스앤젤레스", "리버사이드")
    city_graph.add_edge_by_vertices("로스앤젤레스", "피닉스")
    city_graph.add_edge_by_vertices("리버사이드"  , "피닉스")
    city_graph.add_edge_by_vertices("리버사이드"  , "시카고")
    city_graph.add_edge_by_vertices("피닉스"      , "댈러스")
    city_graph.add_edge_by_vertices("피닉스"      , "휴스턴")
    city_graph.add_edge_by_vertices("댈러스"      , "시카고")
    city_graph.add_edge_by_vertices("댈러스"      , "애틀랜타")
    city_graph.add_edge_by_vertices("댈러스"      , "휴스턴")
    city_graph.add_edge_by_vertices("휴스턴"      , "애틀랜타")
    city_graph.add_edge_by_vertices("휴스턴"      , "마이애미")
    city_graph.add_edge_by_vertices("애틀랜타"    , "시카고")
    city_graph.add_edge_by_vertices("애틀랜타"    , "워싱턴")
    city_graph.add_edge_by_vertices("애틀랜타"    , "마이애미")
    city_graph.add_edge_by_vertices("마이애미"    , "워싱턴")
    city_graph.add_edge_by_vertices("시카고"      , "디트로이트")
    city_graph.add_edge_by_vertices("디트로이트"  , "보스턴")
    city_graph.add_edge_by_vertices("디트로이트"  , "워싱턴")
    city_graph.add_edge_by_vertices("디트로이트"  , "뉴욕")
    city_graph.add_edge_by_vertices("보스턴"      , "뉴욕")
    city_graph.add_edge_by_vertices("뉴욕"        , "필라델피아")
    city_graph.add_edge_by_vertices("필라델피아"  , "워싱턴")
    
    print(city_graph)
```



## 최단 경로 찾기

```python
import sys
sys.path.insert(0, '.')
from ch2.generic_search import bfs, Node, node_to_path
```



너비 우선 탐색

```python
bfs_result:Optional[Node[V]] = bfs("보스턴", 
                                   lambda x: x == "마이애미", 
                                   city_graph.neighbors_for_vertex)
if bfs_result is None:
    print("너비 우선 탐색으로 답을 찾을 수 없습니다!")
else:
    path:List[V] = node_to_path(bfs_result)
    print("보스턴에서 마이애미까지 최단 경로: ")
    print(path)
```



---

# 가중치

## WeightedEdge

```python
from __future__ import annotations
from dataclasses import dataclass
from edge import Edge


@dataclass
class WeightedEdge(Edge):
    weight:float

    def reversed(self) -> WeightedEdge:
        return WeightedEdge(self.v, self.u, self.weight)

    def __lt__(self, other:WeightedEdge) -> bool:
        return self.weight < other.weight

    def __repr__(self) -> str:
        return f"{self.u} {self.weight} -> {self.v}"
```



## WeightedGraph

```python
from typing import TypeVar, Generic, List, Tuple
from graph import Graph
from weighted_edge import WeightedEdge

V = TypeVar("V")    # 그래프 정점(vertice) 타입


class WeightedGraph(Generic[V], Graph[V]):
    def __init__(self, vertices:List[V] = []) -> None:
        self._vertices:List[V] = vertices
        self._edges:List[List[WeightedEdge]] = [[] for _ in vertices]

    def add_edge_by_indices(self, u:int, v:int, weight:float) -> None:
        edge:WeightedEdge = WeightedEdge(u, v, weight)
        self.add_edge(edge)

    def add_edge_by_vertices(self, first:V, second:V, weight:float) -> None:
        u:int = self._vertices.index(first)
        v:int = self._vertices.index(second)
        self.add_edge_by_indices(u, v, weight)

    def neighbors_for_index_with_weights(self, index:int) -> List[Tuple[V, float]]:
        distance_tuples:List[Tuple[V, float]] = []
        for edge in self.edges_for_index(index):
            distance_tuples.append((self.vertex_at(edge.v), edge.weight))
        return distance_tuples

    def __repr__(self) -> str:
        desc:str = ""
        for i in range(self.vertex_count):
            desc += f"{self.vertex_at(i)} -> {self.neighbors_for_index_with_weights(i)}\n"
        return desc
```



```python
if __name__ == "__main__":
    city_graph2:WeightedGraph[str] = WeightedGraph(
        ["시애틀"       , "샌프란시스코", "로스앤젤레스",
         "리버사이드"   , "피닉스"      , "시카고",
         "보스턴"       , "뉴욕"        , "애틀랜타",
         "마이애미"     , "댈러스"      , "휴스턴",
         "디트로이트"   , "필라델피아"  , "워싱턴"])
                                   
    city_graph2.add_edge_by_vertices("시애틀"      , "시카고"      , 1737)
    city_graph2.add_edge_by_vertices("시애틀"      , "샌프란시스코", 678)
    city_graph2.add_edge_by_vertices("샌프란시스코", "리버사이드"  , 386)
    city_graph2.add_edge_by_vertices("샌프란시스코", "로스앤젤레스", 348)
    city_graph2.add_edge_by_vertices("로스앤젤레스", "리버사이드"  , 50)
    city_graph2.add_edge_by_vertices("로스앤젤레스", "피닉스"      , 357)
    city_graph2.add_edge_by_vertices("리버사이드"  , "피닉스"      , 307)
    city_graph2.add_edge_by_vertices("리버사이드"  , "시카고"      , 1704)
    city_graph2.add_edge_by_vertices("피닉스"      , "댈러스"      , 887)
    city_graph2.add_edge_by_vertices("피닉스"      , "휴스턴"      , 1015)
    city_graph2.add_edge_by_vertices("댈러스"      , "시카고"      , 805)
    city_graph2.add_edge_by_vertices("댈러스"      , "애틀랜타"    , 721)
    city_graph2.add_edge_by_vertices("댈러스"      , "휴스턴"      , 225)
    city_graph2.add_edge_by_vertices("휴스턴"      , "애틀랜타"    , 702)
    city_graph2.add_edge_by_vertices("휴스턴"      , "마이애미"    , 968)
    city_graph2.add_edge_by_vertices("애틀랜타"    , "시카고"      , 588)
    city_graph2.add_edge_by_vertices("애틀랜타"    , "워싱턴"      , 543)
    city_graph2.add_edge_by_vertices("애틀랜타"    , "마이애미"    , 604)
    city_graph2.add_edge_by_vertices("마이애미"    , "워싱턴"      , 923)
    city_graph2.add_edge_by_vertices("시카고"      , "디트로이트"  , 238)
    city_graph2.add_edge_by_vertices("디트로이트"  , "보스턴"      , 613)
    city_graph2.add_edge_by_vertices("디트로이트"  , "워싱턴"      , 396)
    city_graph2.add_edge_by_vertices("디트로이트"  , "뉴욕"        , 482)
    city_graph2.add_edge_by_vertices("보스턴"      , "뉴욕"        , 190)
    city_graph2.add_edge_by_vertices("뉴욕"        , "필라델피아"  , 81)
    city_graph2.add_edge_by_vertices("필라델피아"  , "워싱턴"      , 123)
    
    print(city_graph2)
```



## 프림 알고리즘

우선순위 큐

```python
from typing import TypeVar, Generic, List
from heapq import heappush, heappop

T = TypeVar("T")


class PriorityQueue(Generic[T]):
    def __init__(self) -> None:
        self._container:List[T] = []

    @property
    def empty(self) -> bool:
        return not self._container

    def push(self, item:T) -> None:
        heappush(self._container, item)

    def pop(self) -> T:
        return heappop(self._container)

    def __repr__(self) -> str:
        return repr(self._container)
```



최소 신장 트리

```python

```



## 다익스트라 알고리즘

최단 경로 트리

```python
```



---

# 연습문제

## 📝 연습문제 4-1

1. *Q*

   그래프 프레임워크에 에지 및 정점 제거를 위한 메서드를 추가하라.

연습문제 4-1

## 📝 연습문제 4-2

1. *Q*

   그래프 프레임워크에 유향 그래프(digraph)를 사용할 수 있도록 코드를 추가하라.

연습문제 4-2

## 📝 연습문제 4-3

1. *Q*

   그래프 프레임워크를 사용하여 위키피디아 설명되어 있는 것과 같은 [쾨니히스베르크 다리 건너기 문제](https://namu.wiki/w/%EC%BE%A8%EB%8B%88%ED%9E%88%EC%8A%A4%EB%B2%A0%EB%A5%B4%ED%81%AC%20%EB%8B%A4%EB%A6%AC%20%EA%B1%B4%EB%84%88%EA%B8%B0%20%EB%AC%B8%EC%A0%9C)를 증명 또는 반증하라.

연습문제 4-3

